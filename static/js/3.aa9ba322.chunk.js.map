{"version":3,"sources":["../node_modules/use-cannon/dist/Provider-654a5dba.js","../node_modules/buffer/index.js","../node_modules/webpack/buildin/global.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js"],"names":["L","Object","prototype","toString","call","process","u","module","require","W","b","G","d","l","Buffer","from","atob","Uint8Array","length","Array","forEach","charCodeAt","String","fromCharCode","apply","Uint16Array","buffer","c","indexOf","Z","substring","Worker","assign","eval","X","Blob","type","m","URL","createObjectURL","children","step","gravity","p","tolerance","y","iterations","a","allowSleep","s","broadphase","V","axisIndex","h","defaultContactMaterial","x","contactEquationStiffness","size","Y","R","invalidate","z","S","K","positions","Float32Array","quaternions","k","n","postMessage","op","props","onmessage","data","requestAnimationFrame","active","current","bodies","reduce","body","target","ray","uuid","terminate","o","worker","buffers","refs","events","createElement","Provider","value","base64","ieee754","isArray","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","arg","encodingOrOffset","this","Error","allocUnsafe","TypeError","ArrayBuffer","array","byteOffset","byteLength","undefined","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","actual","write","slice","fromString","obj","isBuffer","len","checked","copy","val","fromObject","assertSize","i","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","dir","isNaN","arrayIndexOf","lastIndexOf","arr","indexSize","arrLength","valLength","read","buf","readUInt16BE","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","push","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","Math","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","decodeCodePointsArray","exports","SlowBuffer","alloc","INSPECT_MAX_BYTES","global","foo","subarray","e","typedArraySupport","poolSize","_augment","Symbol","species","defineProperty","configurable","fill","allocUnsafeSlow","_isBuffer","compare","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","max","match","join","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","trim","replace","stringtrim","base64clean","src","dst","g","Function","window","b64","lens","getLens","validLen","placeHoldersLen","tmp","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","len2","encodeChunk","lookup","num","output","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","log","LN2"],"mappings":"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","file":"static/js/3.aa9ba322.chunk.js","sourcesContent":["import b,{useState as G,useRef as d,useEffect as l,useMemo as c}from\"react\";import{_ as Z,c as X}from\"./index-cc12da70.js\";import\"three\";import{useThree as m}from\"react-three-fiber\";const L=\"[object process]\"===Object.prototype.toString.call(\"undefined\"!=typeof process?process:0),u=L&&\"function\"==typeof module.require?module.require:null;const W=function(b,G=null,d=!1){const l=L?function(b,G){return Buffer.from(b,\"base64\").toString(G?\"utf16\":\"utf8\")}(b,d):function(b,G){const d=atob(b);if(G){const b=new Uint8Array(d.length);return Array.prototype.forEach.call(b,(b,G,l)=>{l[G]=d.charCodeAt(G)}),String.fromCharCode.apply(null,new Uint16Array(b.buffer))}return d}(b,d),c=l.indexOf(\"\\n\",10)+1,Z=l.substring(c)+(G?\"//# sourceMappingURL=\"+G:\"\");if(u){const b=u(\"worker_threads\").Worker;return function(G){return new b(Z,Object.assign({},G,{eval:!0}))}}const X=new Blob([Z],{type:\"application/javascript\"}),m=URL.createObjectURL(X);return function(b){return new Worker(m,b)}}(\"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwpmdW5jdGlvbiB0KCl7cmV0dXJuKHQ9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHM9YXJndW1lbnRzW2VdO2Zvcih2YXIgaSBpbiBzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLGkpJiYodFtpXT1zW2ldKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBlKHQsZSl7aWYobnVsbD09dClyZXR1cm57fTt2YXIgcyxpLG89e30sbj1PYmplY3Qua2V5cyh0KTtmb3IoaT0wO2k8bi5sZW5ndGg7aSsrKXM9bltpXSxlLmluZGV4T2Yocyk+PTB8fChvW3NdPXRbc10pO3JldHVybiBvfWNsYXNzIHN7Y29uc3RydWN0b3IodD1bMCwwLDAsMCwwLDAsMCwwLDBdKXt0aGlzLmVsZW1lbnRzPXR9aWRlbnRpdHkoKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7dFswXT0xLHRbMV09MCx0WzJdPTAsdFszXT0wLHRbNF09MSx0WzVdPTAsdFs2XT0wLHRbN109MCx0WzhdPTF9c2V0WmVybygpe2NvbnN0IHQ9dGhpcy5lbGVtZW50czt0WzBdPTAsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MCx0WzZdPTAsdFs3XT0wLHRbOF09MH1zZXRUcmFjZSh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHM7ZVswXT10LngsZVs0XT10LnksZVs4XT10Lnp9Z2V0VHJhY2UodD1uZXcgaSl7Y29uc3QgZT10aGlzLmVsZW1lbnRzO3QueD1lWzBdLHQueT1lWzRdLHQuej1lWzhdfXZtdWx0KHQsZT1uZXcgaSl7Y29uc3Qgcz10aGlzLmVsZW1lbnRzLG89dC54LG49dC55LHI9dC56O3JldHVybiBlLng9c1swXSpvK3NbMV0qbitzWzJdKnIsZS55PXNbM10qbytzWzRdKm4rc1s1XSpyLGUuej1zWzZdKm8rc1s3XSpuK3NbOF0qcixlfXNtdWx0KHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5lbGVtZW50cy5sZW5ndGg7ZSsrKXRoaXMuZWxlbWVudHNbZV0qPXR9bW11bHQodCxlPW5ldyBzKXtjb25zdHtlbGVtZW50czppfT10O2ZvcihsZXQgdD0wO3Q8Mzt0KyspZm9yKGxldCBzPTA7czwzO3MrKyl7bGV0IG89MDtmb3IobGV0IGU9MDtlPDM7ZSsrKW8rPWlbdCszKmVdKnRoaXMuZWxlbWVudHNbZSszKnNdO2UuZWxlbWVudHNbdCszKnNdPW99cmV0dXJuIGV9c2NhbGUodCxlPW5ldyBzKXtjb25zdCBpPXRoaXMuZWxlbWVudHMsbz1lLmVsZW1lbnRzO2ZvcihsZXQgZT0wOzMhPT1lO2UrKylvWzMqZSswXT10LngqaVszKmUrMF0sb1szKmUrMV09dC55KmlbMyplKzFdLG9bMyplKzJdPXQueippWzMqZSsyXTtyZXR1cm4gZX1zb2x2ZSh0LGU9bmV3IGkpe2NvbnN0IHM9W107bGV0IG8sbjtmb3Iobz0wO288MTI7bysrKXMucHVzaCgwKTtmb3Iobz0wO288MztvKyspZm9yKG49MDtuPDM7bisrKXNbbys0Km5dPXRoaXMuZWxlbWVudHNbbyszKm5dO3NbM109dC54LHNbN109dC55LHNbMTFdPXQuejtsZXQgcj0zO2NvbnN0IGE9cjtsZXQgbDtsZXQgaDtkb3tpZihvPWEtciwwPT09c1tvKzQqb10pZm9yKG49bysxO248YTtuKyspaWYoMCE9PXNbbys0Km5dKXtsPTQ7ZG97aD00LWwsc1toKzQqb10rPXNbaCs0Km5dfXdoaWxlKC0tbCk7YnJlYWt9aWYoMCE9PXNbbys0Km9dKWZvcihuPW8rMTtuPGE7bisrKXtjb25zdCB0PXNbbys0Km5dL3Nbbys0Km9dO2w9NDtkb3toPTQtbCxzW2grNCpuXT1oPD1vPzA6c1toKzQqbl0tc1toKzQqb10qdH13aGlsZSgtLWwpfX13aGlsZSgtLXIpO2lmKGUuej1zWzExXS9zWzEwXSxlLnk9KHNbN10tc1s2XSplLnopL3NbNV0sZS54PShzWzNdLXNbMl0qZS56LXNbMV0qZS55KS9zWzBdLGlzTmFOKGUueCl8fGlzTmFOKGUueSl8fGlzTmFOKGUueil8fGUueD09PTEvMHx8ZS55PT09MS8wfHxlLno9PT0xLzApdGhyb3ciQ291bGQgbm90IHNvbHZlIGVxdWF0aW9uISBHb3QgeD1bIitlLnRvU3RyaW5nKCkrIl0sIGI9WyIrdC50b1N0cmluZygpKyJdLCBBPVsiK3RoaXMudG9TdHJpbmcoKSsiXSI7cmV0dXJuIGV9ZSh0LGUscyl7aWYodm9pZCAwPT09cylyZXR1cm4gdGhpcy5lbGVtZW50c1tlKzMqdF07dGhpcy5lbGVtZW50c1tlKzMqdF09c31jb3B5KHQpe2ZvcihsZXQgZT0wO2U8dC5lbGVtZW50cy5sZW5ndGg7ZSsrKXRoaXMuZWxlbWVudHNbZV09dC5lbGVtZW50c1tlXTtyZXR1cm4gdGhpc310b1N0cmluZygpe2xldCB0PSIiO2ZvcihsZXQgZT0wO2U8OTtlKyspdCs9dGhpcy5lbGVtZW50c1tlXSsiLCI7cmV0dXJuIHR9cmV2ZXJzZSh0PW5ldyBzKXtjb25zdCBlPVtdO2xldCBpLG87Zm9yKGk9MDtpPDE4O2krKyllLnB1c2goMCk7Zm9yKGk9MDtpPDM7aSsrKWZvcihvPTA7bzwzO28rKyllW2krNipvXT10aGlzLmVsZW1lbnRzW2krMypvXTtlWzNdPTEsZVs5XT0wLGVbMTVdPTAsZVs0XT0wLGVbMTBdPTEsZVsxNl09MCxlWzVdPTAsZVsxMV09MCxlWzE3XT0xO2xldCBuPTM7Y29uc3Qgcj1uO2xldCBhO2xldCBsO2Rve2lmKGk9ci1uLDA9PT1lW2krNippXSlmb3Iobz1pKzE7bzxyO28rKylpZigwIT09ZVtpKzYqb10pe2E9Njtkb3tsPTYtYSxlW2wrNippXSs9ZVtsKzYqb119d2hpbGUoLS1hKTticmVha31pZigwIT09ZVtpKzYqaV0pZm9yKG89aSsxO288cjtvKyspe2NvbnN0IHQ9ZVtpKzYqb10vZVtpKzYqaV07YT02O2Rve2w9Ni1hLGVbbCs2Km9dPWw8PWk/MDplW2wrNipvXS1lW2wrNippXSp0fXdoaWxlKC0tYSl9fXdoaWxlKC0tbik7aT0yO2Rve289aS0xO2Rve2NvbnN0IHQ9ZVtpKzYqb10vZVtpKzYqaV07YT02O2Rve2w9Ni1hLGVbbCs2Km9dPWVbbCs2Km9dLWVbbCs2KmldKnR9d2hpbGUoLS1hKX13aGlsZShvLS0pfXdoaWxlKC0taSk7aT0yO2Rve2NvbnN0IHQ9MS9lW2krNippXTthPTY7ZG97bD02LWEsZVtsKzYqaV09ZVtsKzYqaV0qdH13aGlsZSgtLWEpfXdoaWxlKGktLSk7aT0yO2Rve289Mjtkb3tpZihsPWVbMytvKzYqaV0saXNOYU4obCl8fGw9PT0xLzApdGhyb3ciQ291bGQgbm90IHJldmVyc2UhIEE9WyIrdGhpcy50b1N0cmluZygpKyJdIjt0LmUoaSxvLGwpfXdoaWxlKG8tLSl9d2hpbGUoaS0tKTtyZXR1cm4gdH1zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpe2NvbnN0IGU9dC54LHM9dC55LGk9dC56LG89dC53LG49ZStlLHI9cytzLGE9aStpLGw9ZSpuLGg9ZSpyLGM9ZSphLHU9cypyLGQ9cyphLHA9aSphLHk9bypuLG09bypyLHY9byphLHc9dGhpcy5lbGVtZW50cztyZXR1cm4gd1swXT0xLSh1K3ApLHdbMV09aC12LHdbMl09YyttLHdbM109aCt2LHdbNF09MS0obCtwKSx3WzVdPWQteSx3WzZdPWMtbSx3WzddPWQreSx3WzhdPTEtKGwrdSksdGhpc310cmFuc3Bvc2UodD1uZXcgcyl7Y29uc3QgZT10LmVsZW1lbnRzLGk9dGhpcy5lbGVtZW50cztmb3IobGV0IHQ9MDszIT09dDt0KyspZm9yKGxldCBzPTA7MyE9PXM7cysrKWVbMyp0K3NdPWlbMypzK3RdO3JldHVybiB0fX1jbGFzcyBpe2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wKXt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9c31jcm9zcyh0LGU9bmV3IGkpe2NvbnN0IHM9dC54LG89dC55LG49dC56LHI9dGhpcy54LGE9dGhpcy55LGw9dGhpcy56O3JldHVybiBlLng9YSpuLWwqbyxlLnk9bCpzLXIqbixlLno9cipvLWEqcyxlfXNldCh0LGUscyl7cmV0dXJuIHRoaXMueD10LHRoaXMueT1lLHRoaXMuej1zLHRoaXN9c2V0WmVybygpe3RoaXMueD10aGlzLnk9dGhpcy56PTB9dmFkZCh0LGUpe2lmKCFlKXJldHVybiBuZXcgaSh0aGlzLngrdC54LHRoaXMueSt0LnksdGhpcy56K3Queik7ZS54PXQueCt0aGlzLngsZS55PXQueSt0aGlzLnksZS56PXQueit0aGlzLnp9dnN1Yih0LGUpe2lmKCFlKXJldHVybiBuZXcgaSh0aGlzLngtdC54LHRoaXMueS10LnksdGhpcy56LXQueik7ZS54PXRoaXMueC10LngsZS55PXRoaXMueS10LnksZS56PXRoaXMuei10Lnp9Y3Jvc3NtYXQoKXtyZXR1cm4gbmV3IHMoWzAsLXRoaXMueix0aGlzLnksdGhpcy56LDAsLXRoaXMueCwtdGhpcy55LHRoaXMueCwwXSl9bm9ybWFsaXplKCl7Y29uc3QgdD10aGlzLngsZT10aGlzLnkscz10aGlzLnosaT1NYXRoLnNxcnQodCp0K2UqZStzKnMpO2lmKGk+MCl7Y29uc3QgdD0xL2k7dGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXR9ZWxzZSB0aGlzLng9MCx0aGlzLnk9MCx0aGlzLno9MDtyZXR1cm4gaX11bml0KHQ9bmV3IGkpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LG89dGhpcy56O2xldCBuPU1hdGguc3FydChlKmUrcypzK28qbyk7cmV0dXJuIG4+MD8obj0xL24sdC54PWUqbix0Lnk9cypuLHQuej1vKm4pOih0Lng9MSx0Lnk9MCx0Lno9MCksdH1ub3JtKCl7Y29uc3QgdD10aGlzLngsZT10aGlzLnkscz10aGlzLno7cmV0dXJuIE1hdGguc3FydCh0KnQrZSplK3Mqcyl9bGVuZ3RoKCl7cmV0dXJuIHRoaXMubm9ybSgpfW5vcm0yKCl7cmV0dXJuIHRoaXMuZG90KHRoaXMpfWxlbmd0aFNxdWFyZWQoKXtyZXR1cm4gdGhpcy5kb3QodGhpcyl9ZGlzdGFuY2VUbyh0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxpPXRoaXMueixvPXQueCxuPXQueSxyPXQuejtyZXR1cm4gTWF0aC5zcXJ0KChvLWUpKihvLWUpKyhuLXMpKihuLXMpKyhyLWkpKihyLWkpKX1kaXN0YW5jZVNxdWFyZWQodCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksaT10aGlzLnosbz10Lngsbj10Lnkscj10Lno7cmV0dXJuKG8tZSkqKG8tZSkrKG4tcykqKG4tcykrKHItaSkqKHItaSl9bXVsdCh0LGU9bmV3IGkpe2NvbnN0IHM9dGhpcy54LG89dGhpcy55LG49dGhpcy56O3JldHVybiBlLng9dCpzLGUueT10Km8sZS56PXQqbixlfXNjYWxlKHQsZT1uZXcgaSl7cmV0dXJuIHRoaXMubXVsdCh0LGUpfXZtdWwodCxlPW5ldyBpKXtyZXR1cm4gZS54PXQueCp0aGlzLngsZS55PXQueSp0aGlzLnksZS56PXQueip0aGlzLnosZX1hZGRTY2FsZWRWZWN0b3IodCxlLHM9bmV3IGkpe3JldHVybiBzLng9dGhpcy54K3QqZS54LHMueT10aGlzLnkrdCplLnkscy56PXRoaXMueit0KmUueixzfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55K3RoaXMueip0Lnp9aXNaZXJvKCl7cmV0dXJuIDA9PT10aGlzLngmJjA9PT10aGlzLnkmJjA9PT10aGlzLnp9bmVnYXRlKHQ9bmV3IGkpe3JldHVybiB0Lng9LXRoaXMueCx0Lnk9LXRoaXMueSx0Lno9LXRoaXMueix0fXRhbmdlbnRzKHQsZSl7Y29uc3Qgcz10aGlzLm5vcm0oKTtpZihzPjApe2NvbnN0IGk9byxyPTEvcztpLnNldCh0aGlzLngqcix0aGlzLnkqcix0aGlzLnoqcik7Y29uc3QgYT1uO01hdGguYWJzKGkueCk8Ljk/KGEuc2V0KDEsMCwwKSxpLmNyb3NzKGEsdCkpOihhLnNldCgwLDEsMCksaS5jcm9zcyhhLHQpKSxpLmNyb3NzKHQsZSl9ZWxzZSB0LnNldCgxLDAsMCksZS5zZXQoMCwxLDApfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMueCsiLCIrdGhpcy55KyIsIit0aGlzLnp9dG9BcnJheSgpe3JldHVyblt0aGlzLngsdGhpcy55LHRoaXMuel19Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LnosdGhpc31sZXJwKHQsZSxzKXtjb25zdCBpPXRoaXMueCxvPXRoaXMueSxuPXRoaXMuejtzLng9aSsodC54LWkpKmUscy55PW8rKHQueS1vKSplLHMuej1uKyh0LnotbikqZX1hbG1vc3RFcXVhbHModCxlPTFlLTYpe3JldHVybiEoTWF0aC5hYnModGhpcy54LXQueCk+ZXx8TWF0aC5hYnModGhpcy55LXQueSk+ZXx8TWF0aC5hYnModGhpcy56LXQueik+ZSl9YWxtb3N0WmVybyh0PTFlLTYpe3JldHVybiEoTWF0aC5hYnModGhpcy54KT50fHxNYXRoLmFicyh0aGlzLnkpPnR8fE1hdGguYWJzKHRoaXMueik+dCl9aXNBbnRpcGFyYWxsZWxUbyh0LGUpe3JldHVybiB0aGlzLm5lZ2F0ZShyKSxyLmFsbW9zdEVxdWFscyh0LGUpfWNsb25lKCl7cmV0dXJuIG5ldyBpKHRoaXMueCx0aGlzLnksdGhpcy56KX19aS5aRVJPPW5ldyBpKDAsMCwwKSxpLlVOSVRfWD1uZXcgaSgxLDAsMCksaS5VTklUX1k9bmV3IGkoMCwxLDApLGkuVU5JVF9aPW5ldyBpKDAsMCwxKTtjb25zdCBvPW5ldyBpLG49bmV3IGkscj1uZXcgaTtjbGFzcyBhe2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMubG93ZXJCb3VuZD1uZXcgaSx0aGlzLnVwcGVyQm91bmQ9bmV3IGksdC5sb3dlckJvdW5kJiZ0aGlzLmxvd2VyQm91bmQuY29weSh0Lmxvd2VyQm91bmQpLHQudXBwZXJCb3VuZCYmdGhpcy51cHBlckJvdW5kLmNvcHkodC51cHBlckJvdW5kKX1zZXRGcm9tUG9pbnRzKHQsZSxzLGkpe2NvbnN0IG89dGhpcy5sb3dlckJvdW5kLG49dGhpcy51cHBlckJvdW5kLHI9cztvLmNvcHkodFswXSksciYmci52bXVsdChvLG8pLG4uY29weShvKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKyl7bGV0IHM9dFtlXTtyJiYoci52bXVsdChzLGwpLHM9bCkscy54Pm4ueCYmKG4ueD1zLngpLHMueDxvLngmJihvLng9cy54KSxzLnk+bi55JiYobi55PXMueSkscy55PG8ueSYmKG8ueT1zLnkpLHMuej5uLnomJihuLno9cy56KSxzLno8by56JiYoby56PXMueil9cmV0dXJuIGUmJihlLnZhZGQobyxvKSxlLnZhZGQobixuKSksaSYmKG8ueC09aSxvLnktPWksby56LT1pLG4ueCs9aSxuLnkrPWksbi56Kz1pKSx0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMubG93ZXJCb3VuZC5jb3B5KHQubG93ZXJCb3VuZCksdGhpcy51cHBlckJvdW5kLmNvcHkodC51cHBlckJvdW5kKSx0aGlzfWNsb25lKCl7cmV0dXJuKG5ldyBhKS5jb3B5KHRoaXMpfWV4dGVuZCh0KXt0aGlzLmxvd2VyQm91bmQueD1NYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueCx0Lmxvd2VyQm91bmQueCksdGhpcy51cHBlckJvdW5kLng9TWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsdC51cHBlckJvdW5kLngpLHRoaXMubG93ZXJCb3VuZC55PU1hdGgubWluKHRoaXMubG93ZXJCb3VuZC55LHQubG93ZXJCb3VuZC55KSx0aGlzLnVwcGVyQm91bmQueT1NYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueSx0LnVwcGVyQm91bmQueSksdGhpcy5sb3dlckJvdW5kLno9TWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosdC5sb3dlckJvdW5kLnopLHRoaXMudXBwZXJCb3VuZC56PU1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC56LHQudXBwZXJCb3VuZC56KX1vdmVybGFwcyh0KXtjb25zdCBlPXRoaXMubG93ZXJCb3VuZCxzPXRoaXMudXBwZXJCb3VuZCxpPXQubG93ZXJCb3VuZCxvPXQudXBwZXJCb3VuZCxuPWkueDw9cy54JiZzLng8PW8ueHx8ZS54PD1vLngmJm8ueDw9cy54LHI9aS55PD1zLnkmJnMueTw9by55fHxlLnk8PW8ueSYmby55PD1zLnksYT1pLno8PXMueiYmcy56PD1vLnp8fGUuejw9by56JiZvLno8PXMuejtyZXR1cm4gbiYmciYmYX12b2x1bWUoKXtjb25zdCB0PXRoaXMubG93ZXJCb3VuZCxlPXRoaXMudXBwZXJCb3VuZDtyZXR1cm4oZS54LXQueCkqKGUueS10LnkpKihlLnotdC56KX1jb250YWlucyh0KXtjb25zdCBlPXRoaXMubG93ZXJCb3VuZCxzPXRoaXMudXBwZXJCb3VuZCxpPXQubG93ZXJCb3VuZCxvPXQudXBwZXJCb3VuZDtyZXR1cm4gZS54PD1pLngmJnMueD49by54JiZlLnk8PWkueSYmcy55Pj1vLnkmJmUuejw9aS56JiZzLno+PW8uen1nZXRDb3JuZXJzKHQsZSxzLGksbyxuLHIsYSl7Y29uc3QgbD10aGlzLmxvd2VyQm91bmQsaD10aGlzLnVwcGVyQm91bmQ7dC5jb3B5KGwpLGUuc2V0KGgueCxsLnksbC56KSxzLnNldChoLngsaC55LGwueiksaS5zZXQobC54LGgueSxoLnopLG8uc2V0KGgueCxsLnksaC56KSxuLnNldChsLngsaC55LGwueiksci5zZXQobC54LGwueSxoLnopLGEuY29weShoKX10b0xvY2FsRnJhbWUodCxlKXtjb25zdCBzPWgsaT1zWzBdLG89c1sxXSxuPXNbMl0scj1zWzNdLGE9c1s0XSxsPXNbNV0sYz1zWzZdLHU9c1s3XTt0aGlzLmdldENvcm5lcnMoaSxvLG4scixhLGwsYyx1KTtmb3IobGV0IGU9MDs4IT09ZTtlKyspe2NvbnN0IGk9c1tlXTt0LnBvaW50VG9Mb2NhbChpLGkpfXJldHVybiBlLnNldEZyb21Qb2ludHMocyl9dG9Xb3JsZEZyYW1lKHQsZSl7Y29uc3Qgcz1oLGk9c1swXSxvPXNbMV0sbj1zWzJdLHI9c1szXSxhPXNbNF0sbD1zWzVdLGM9c1s2XSx1PXNbN107dGhpcy5nZXRDb3JuZXJzKGksbyxuLHIsYSxsLGMsdSk7Zm9yKGxldCBlPTA7OCE9PWU7ZSsrKXtjb25zdCBpPXNbZV07dC5wb2ludFRvV29ybGQoaSxpKX1yZXR1cm4gZS5zZXRGcm9tUG9pbnRzKHMpfW92ZXJsYXBzUmF5KHQpe2NvbnN0e2RpcmVjdGlvbjplLGZyb206c309dCxpPTEvZS54LG89MS9lLnksbj0xL2UueixyPSh0aGlzLmxvd2VyQm91bmQueC1zLngpKmksYT0odGhpcy51cHBlckJvdW5kLngtcy54KSppLGw9KHRoaXMubG93ZXJCb3VuZC55LXMueSkqbyxoPSh0aGlzLnVwcGVyQm91bmQueS1zLnkpKm8sYz0odGhpcy5sb3dlckJvdW5kLnotcy56KSpuLHU9KHRoaXMudXBwZXJCb3VuZC56LXMueikqbixkPU1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHIsYSksTWF0aC5taW4obCxoKSksTWF0aC5taW4oYyx1KSkscD1NYXRoLm1pbihNYXRoLm1pbihNYXRoLm1heChyLGEpLE1hdGgubWF4KGwsaCkpLE1hdGgubWF4KGMsdSkpO3JldHVybiEocDwwKSYmIShkPnApfX1jb25zdCBsPW5ldyBpLGg9W25ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpXTtjbGFzcyBje2NvbnN0cnVjdG9yKCl7dGhpcy5tYXRyaXg9W119Z2V0KHQsZSl7bGV0e2luZGV4OnN9PXQse2luZGV4Oml9PWU7aWYoaT5zKXtjb25zdCB0PWk7aT1zLHM9dH1yZXR1cm4gdGhpcy5tYXRyaXhbKHMqKHMrMSk+PjEpK2ktMV19c2V0KHQsZSxzKXtsZXR7aW5kZXg6aX09dCx7aW5kZXg6b309ZTtpZihvPmkpe2NvbnN0IHQ9bztvPWksaT10fXRoaXMubWF0cml4WyhpKihpKzEpPj4xKStvLTFdPXM/MTowfXJlc2V0KCl7Zm9yKGxldCB0PTAsZT10aGlzLm1hdHJpeC5sZW5ndGg7dCE9PWU7dCsrKXRoaXMubWF0cml4W3RdPTB9c2V0TnVtT2JqZWN0cyh0KXt0aGlzLm1hdHJpeC5sZW5ndGg9dCoodC0xKT4+MX19Y2xhc3MgdXtjb25zdHJ1Y3Rvcigpe31hZGRFdmVudExpc3RlbmVyKHQsZSl7dm9pZCAwPT09dGhpcy5fbGlzdGVuZXJzJiYodGhpcy5fbGlzdGVuZXJzPXt9KTtjb25zdCBzPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gdm9pZCAwPT09c1t0XSYmKHNbdF09W10pLHNbdF0uaW5jbHVkZXMoZSl8fHNbdF0ucHVzaChlKSx0aGlzfWhhc0V2ZW50TGlzdGVuZXIodCxlKXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuITE7Y29uc3Qgcz10aGlzLl9saXN0ZW5lcnM7cmV0dXJuISh2b2lkIDA9PT1zW3RdfHwhc1t0XS5pbmNsdWRlcyhlKSl9aGFzQW55RXZlbnRMaXN0ZW5lcih0KXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuITE7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX2xpc3RlbmVyc1t0XX1yZW1vdmVFdmVudExpc3RlbmVyKHQsZSl7aWYodm9pZCAwPT09dGhpcy5fbGlzdGVuZXJzKXJldHVybiB0aGlzO2NvbnN0IHM9dGhpcy5fbGlzdGVuZXJzO2lmKHZvaWQgMD09PXNbdF0pcmV0dXJuIHRoaXM7Y29uc3QgaT1zW3RdLmluZGV4T2YoZSk7cmV0dXJuLTEhPT1pJiZzW3RdLnNwbGljZShpLDEpLHRoaXN9ZGlzcGF0Y2hFdmVudCh0KXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuIHRoaXM7Y29uc3QgZT10aGlzLl9saXN0ZW5lcnNbdC50eXBlXTtpZih2b2lkIDAhPT1lKXt0LnRhcmdldD10aGlzO2ZvcihsZXQgcz0wLGk9ZS5sZW5ndGg7czxpO3MrKyllW3NdLmNhbGwodGhpcyx0KX1yZXR1cm4gdGhpc319Y2xhc3MgZHtjb25zdHJ1Y3Rvcih0PTAsZT0wLHM9MCxpPTEpe3RoaXMueD10LHRoaXMueT1lLHRoaXMuej1zLHRoaXMudz1pfXNldCh0LGUscyxpKXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PWUsdGhpcy56PXMsdGhpcy53PWksdGhpc310b1N0cmluZygpe3JldHVybiB0aGlzLngrIiwiK3RoaXMueSsiLCIrdGhpcy56KyIsIit0aGlzLnd9dG9BcnJheSgpe3JldHVyblt0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLnddfXNldEZyb21BeGlzQW5nbGUodCxlKXtjb25zdCBzPU1hdGguc2luKC41KmUpO3JldHVybiB0aGlzLng9dC54KnMsdGhpcy55PXQueSpzLHRoaXMuej10Lnoqcyx0aGlzLnc9TWF0aC5jb3MoLjUqZSksdGhpc310b0F4aXNBbmdsZSh0PW5ldyBpKXt0aGlzLm5vcm1hbGl6ZSgpO2NvbnN0IGU9MipNYXRoLmFjb3ModGhpcy53KSxzPU1hdGguc3FydCgxLXRoaXMudyp0aGlzLncpO3JldHVybiBzPC4wMDE/KHQueD10aGlzLngsdC55PXRoaXMueSx0Lno9dGhpcy56KToodC54PXRoaXMueC9zLHQueT10aGlzLnkvcyx0Lno9dGhpcy56L3MpLFt0LGVdfXNldEZyb21WZWN0b3JzKHQsZSl7aWYodC5pc0FudGlwYXJhbGxlbFRvKGUpKXtjb25zdCBlPXAscz15O3QudGFuZ2VudHMoZSxzKSx0aGlzLnNldEZyb21BeGlzQW5nbGUoZSxNYXRoLlBJKX1lbHNle2NvbnN0IHM9dC5jcm9zcyhlKTt0aGlzLng9cy54LHRoaXMueT1zLnksdGhpcy56PXMueix0aGlzLnc9TWF0aC5zcXJ0KHQubm9ybSgpKioyKmUubm9ybSgpKioyKSt0LmRvdChlKSx0aGlzLm5vcm1hbGl6ZSgpfXJldHVybiB0aGlzfW11bHQodCxlPW5ldyBkKXtjb25zdCBzPXRoaXMueCxpPXRoaXMueSxvPXRoaXMueixuPXRoaXMudyxyPXQueCxhPXQueSxsPXQueixoPXQudztyZXR1cm4gZS54PXMqaCtuKnIraSpsLW8qYSxlLnk9aSpoK24qYStvKnItcypsLGUuej1vKmgrbipsK3MqYS1pKnIsZS53PW4qaC1zKnItaSphLW8qbCxlfWludmVyc2UodD1uZXcgZCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksaT10aGlzLnosbz10aGlzLnc7dGhpcy5jb25qdWdhdGUodCk7Y29uc3Qgbj0xLyhlKmUrcypzK2kqaStvKm8pO3JldHVybiB0LngqPW4sdC55Kj1uLHQueio9bix0LncqPW4sdH1jb25qdWdhdGUodD1uZXcgZCl7cmV0dXJuIHQueD0tdGhpcy54LHQueT0tdGhpcy55LHQuej0tdGhpcy56LHQudz10aGlzLncsdH1ub3JtYWxpemUoKXtsZXQgdD1NYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudyk7cmV0dXJuIDA9PT10Pyh0aGlzLng9MCx0aGlzLnk9MCx0aGlzLno9MCx0aGlzLnc9MCk6KHQ9MS90LHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXMudyo9dCksdGhpc31ub3JtYWxpemVGYXN0KCl7Y29uc3QgdD0oMy0odGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudykpLzI7cmV0dXJuIDA9PT10Pyh0aGlzLng9MCx0aGlzLnk9MCx0aGlzLno9MCx0aGlzLnc9MCk6KHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXMudyo9dCksdGhpc312bXVsdCh0LGU9bmV3IGkpe2NvbnN0IHM9dC54LG89dC55LG49dC56LHI9dGhpcy54LGE9dGhpcy55LGw9dGhpcy56LGg9dGhpcy53LGM9aCpzK2Eqbi1sKm8sdT1oKm8rbCpzLXIqbixkPWgqbityKm8tYSpzLHA9LXIqcy1hKm8tbCpuO3JldHVybiBlLng9YypoK3AqLXIrdSotbC1kKi1hLGUueT11KmgrcCotYStkKi1yLWMqLWwsZS56PWQqaCtwKi1sK2MqLWEtdSotcixlfWNvcHkodCl7cmV0dXJuIHRoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56LHRoaXMudz10LncsdGhpc310b0V1bGVyKHQsZT0iWVpYIil7bGV0IHMsaSxvO2NvbnN0IG49dGhpcy54LHI9dGhpcy55LGE9dGhpcy56LGw9dGhpcy53O3N3aXRjaChlKXtjYXNlIllaWCI6Y29uc3QgdD1uKnIrYSpsO2lmKHQ+LjQ5OSYmKHM9MipNYXRoLmF0YW4yKG4sbCksaT1NYXRoLlBJLzIsbz0wKSx0PC0uNDk5JiYocz0tMipNYXRoLmF0YW4yKG4sbCksaT0tTWF0aC5QSS8yLG89MCksdm9pZCAwPT09cyl7Y29uc3QgZT1uKm4saD1yKnIsYz1hKmE7cz1NYXRoLmF0YW4yKDIqcipsLTIqbiphLDEtMipoLTIqYyksaT1NYXRoLmFzaW4oMip0KSxvPU1hdGguYXRhbjIoMipuKmwtMipyKmEsMS0yKmUtMipjKX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiRXVsZXIgb3JkZXIgIitlKyIgbm90IHN1cHBvcnRlZCB5ZXQuIil9dC55PXMsdC56PWksdC54PW99c2V0RnJvbUV1bGVyKHQsZSxzLGk9IlhZWiIpe2NvbnN0IG89TWF0aC5jb3ModC8yKSxuPU1hdGguY29zKGUvMikscj1NYXRoLmNvcyhzLzIpLGE9TWF0aC5zaW4odC8yKSxsPU1hdGguc2luKGUvMiksaD1NYXRoLnNpbihzLzIpO3JldHVybiJYWVoiPT09aT8odGhpcy54PWEqbipyK28qbCpoLHRoaXMueT1vKmwqci1hKm4qaCx0aGlzLno9bypuKmgrYSpsKnIsdGhpcy53PW8qbipyLWEqbCpoKToiWVhaIj09PWk/KHRoaXMueD1hKm4qcitvKmwqaCx0aGlzLnk9bypsKnItYSpuKmgsdGhpcy56PW8qbipoLWEqbCpyLHRoaXMudz1vKm4qcithKmwqaCk6IlpYWSI9PT1pPyh0aGlzLng9YSpuKnItbypsKmgsdGhpcy55PW8qbCpyK2EqbipoLHRoaXMuej1vKm4qaCthKmwqcix0aGlzLnc9bypuKnItYSpsKmgpOiJaWVgiPT09aT8odGhpcy54PWEqbipyLW8qbCpoLHRoaXMueT1vKmwqcithKm4qaCx0aGlzLno9bypuKmgtYSpsKnIsdGhpcy53PW8qbipyK2EqbCpoKToiWVpYIj09PWk/KHRoaXMueD1hKm4qcitvKmwqaCx0aGlzLnk9bypsKnIrYSpuKmgsdGhpcy56PW8qbipoLWEqbCpyLHRoaXMudz1vKm4qci1hKmwqaCk6IlhaWSI9PT1pJiYodGhpcy54PWEqbipyLW8qbCpoLHRoaXMueT1vKmwqci1hKm4qaCx0aGlzLno9bypuKmgrYSpsKnIsdGhpcy53PW8qbipyK2EqbCpoKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyBkKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9c2xlcnAodCxlLHM9bmV3IGQpe2NvbnN0IGk9dGhpcy54LG89dGhpcy55LG49dGhpcy56LHI9dGhpcy53O2xldCBhLGwsaCxjLHUscD10LngseT10LnksbT10Lnosdj10Lnc7cmV0dXJuIGw9aSpwK28qeStuKm0rcip2LGw8MCYmKGw9LWwscD0tcCx5PS15LG09LW0sdj0tdiksMS1sPjFlLTY/KGE9TWF0aC5hY29zKGwpLGg9TWF0aC5zaW4oYSksYz1NYXRoLnNpbigoMS1lKSphKS9oLHU9TWF0aC5zaW4oZSphKS9oKTooYz0xLWUsdT1lKSxzLng9YyppK3UqcCxzLnk9YypvK3UqeSxzLno9YypuK3UqbSxzLnc9YypyK3UqdixzfWludGVncmF0ZSh0LGUscyxpPW5ldyBkKXtjb25zdCBvPXQueCpzLngsbj10Lnkqcy55LHI9dC56KnMueixhPXRoaXMueCxsPXRoaXMueSxoPXRoaXMueixjPXRoaXMudyx1PS41KmU7cmV0dXJuIGkueCs9dSoobypjK24qaC1yKmwpLGkueSs9dSoobipjK3IqYS1vKmgpLGkueis9dSoocipjK28qbC1uKmEpLGkudys9dSooLW8qYS1uKmwtcipoKSxpfX1jb25zdCBwPW5ldyBpLHk9bmV3IGk7Y2xhc3MgbXtjb25zdHJ1Y3Rvcih0PXt9KXt0aGlzLmlkPW0uaWRDb3VudGVyKyssdGhpcy50eXBlPXQudHlwZXx8MCx0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzPTAsdGhpcy5jb2xsaXNpb25SZXNwb25zZT0hdC5jb2xsaXNpb25SZXNwb25zZXx8dC5jb2xsaXNpb25SZXNwb25zZSx0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwPXZvaWQgMCE9PXQuY29sbGlzaW9uRmlsdGVyR3JvdXA/dC5jb2xsaXNpb25GaWx0ZXJHcm91cDoxLHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzaz12b2lkIDAhPT10LmNvbGxpc2lvbkZpbHRlck1hc2s/dC5jb2xsaXNpb25GaWx0ZXJNYXNrOi0xLHRoaXMubWF0ZXJpYWw9dC5tYXRlcmlhbD90Lm1hdGVyaWFsOm51bGwsdGhpcy5ib2R5PW51bGx9dXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKXt0aHJvdyJjb21wdXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgIit0aGlzLnR5cGV9dm9sdW1lKCl7dGhyb3cidm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICIrdGhpcy50eXBlfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGUpe3Rocm93ImNhbGN1bGF0ZUxvY2FsSW5lcnRpYSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAiK3RoaXMudHlwZX1jYWxjdWxhdGVXb3JsZEFBQkIodCxlLHMsaSl7dGhyb3ciY2FsY3VsYXRlV29ybGRBQUJCKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICIrdGhpcy50eXBlfX1tLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1tLG0uaWRDb3VudGVyPTAsbS50eXBlcz17U1BIRVJFOjEsUExBTkU6MixCT1g6NCxDT01QT1VORDo4LENPTlZFWFBPTFlIRURST046MTYsSEVJR0hURklFTEQ6MzIsUEFSVElDTEU6NjQsQ1lMSU5ERVI6MTI4LFRSSU1FU0g6MjU2fTtjbGFzcyB2e2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMucG9zaXRpb249bmV3IGksdGhpcy5xdWF0ZXJuaW9uPW5ldyBkLHQucG9zaXRpb24mJnRoaXMucG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0LnF1YXRlcm5pb24mJnRoaXMucXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbil9cG9pbnRUb0xvY2FsKHQsZSl7cmV0dXJuIHYucG9pbnRUb0xvY2FsRnJhbWUodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdCxlKX1wb2ludFRvV29ybGQodCxlKXtyZXR1cm4gdi5wb2ludFRvV29ybGRGcmFtZSh0aGlzLnBvc2l0aW9uLHRoaXMucXVhdGVybmlvbix0LGUpfXZlY3RvclRvV29ybGRGcmFtZSh0LGU9bmV3IGkpe3JldHVybiB0aGlzLnF1YXRlcm5pb24udm11bHQodCxlKSxlfXN0YXRpYyBwb2ludFRvTG9jYWxGcmFtZSh0LGUscyxvPW5ldyBpKXtyZXR1cm4gcy52c3ViKHQsbyksZS5jb25qdWdhdGUodyksdy52bXVsdChvLG8pLG99c3RhdGljIHBvaW50VG9Xb3JsZEZyYW1lKHQsZSxzLG89bmV3IGkpe3JldHVybiBlLnZtdWx0KHMsbyksby52YWRkKHQsbyksb31zdGF0aWMgdmVjdG9yVG9Xb3JsZEZyYW1lKHQsZSxzPW5ldyBpKXtyZXR1cm4gdC52bXVsdChlLHMpLHN9c3RhdGljIHZlY3RvclRvTG9jYWxGcmFtZSh0LGUscyxvPW5ldyBpKXtyZXR1cm4gZS53Kj0tMSxlLnZtdWx0KHMsbyksZS53Kj0tMSxvfX1jb25zdCB3PW5ldyBkO2NsYXNzIGYgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKHQ9e30pe2NvbnN0e3ZlcnRpY2VzOmU9W10sZmFjZXM6cz1bXSxub3JtYWxzOmk9W10sYXhlczpvLGJvdW5kaW5nU3BoZXJlUmFkaXVzOm59PXQ7c3VwZXIoe3R5cGU6bS50eXBlcy5DT05WRVhQT0xZSEVEUk9OfSksdGhpcy52ZXJ0aWNlcz1lLHRoaXMuZmFjZXM9cyx0aGlzLmZhY2VOb3JtYWxzPWksMD09PXRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoJiZ0aGlzLmNvbXB1dGVOb3JtYWxzKCksbj90aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzPW46dGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpLHRoaXMud29ybGRWZXJ0aWNlcz1bXSx0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZT0hMCx0aGlzLndvcmxkRmFjZU5vcm1hbHM9W10sdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGU9ITAsdGhpcy51bmlxdWVBeGVzPW8/by5zbGljZSgpOm51bGwsdGhpcy51bmlxdWVFZGdlcz1bXSx0aGlzLmNvbXB1dGVFZGdlcygpfWNvbXB1dGVFZGdlcygpe2NvbnN0IHQ9dGhpcy5mYWNlcyxlPXRoaXMudmVydGljZXMscz10aGlzLnVuaXF1ZUVkZ2VzO3MubGVuZ3RoPTA7Y29uc3Qgbz1uZXcgaTtmb3IobGV0IGk9MDtpIT09dC5sZW5ndGg7aSsrKXtjb25zdCBuPXRbaV0scj1uLmxlbmd0aDtmb3IobGV0IHQ9MDt0IT09cjt0Kyspe2NvbnN0IGk9KHQrMSklcjtlW25bdF1dLnZzdWIoZVtuW2ldXSxvKSxvLm5vcm1hbGl6ZSgpO2xldCBhPSExO2ZvcihsZXQgdD0wO3QhPT1zLmxlbmd0aDt0KyspaWYoc1t0XS5hbG1vc3RFcXVhbHMobyl8fHNbdF0uYWxtb3N0RXF1YWxzKG8pKXthPSEwO2JyZWFrfWF8fHMucHVzaChvLmNsb25lKCkpfX19Y29tcHV0ZU5vcm1hbHMoKXt0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aD10aGlzLmZhY2VzLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHRoaXMuZmFjZXMubGVuZ3RoO3QrKyl7Zm9yKGxldCBlPTA7ZTx0aGlzLmZhY2VzW3RdLmxlbmd0aDtlKyspaWYoIXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1t0XVtlXV0pdGhyb3cgbmV3IEVycm9yKCJWZXJ0ZXggIit0aGlzLmZhY2VzW3RdW2VdKyIgbm90IGZvdW5kISIpO2NvbnN0IGU9dGhpcy5mYWNlTm9ybWFsc1t0XXx8bmV3IGk7dGhpcy5nZXRGYWNlTm9ybWFsKHQsZSksZS5uZWdhdGUoZSksdGhpcy5mYWNlTm9ybWFsc1t0XT1lO2NvbnN0IHM9dGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW3RdWzBdXTtpZihlLmRvdChzKTwwKXtjb25zb2xlLmVycm9yKCIuZmFjZU5vcm1hbHNbIit0KyJdID0gVmVjMygiK2UudG9TdHJpbmcoKSsiKSBsb29rcyBsaWtlIGl0IHBvaW50cyBpbnRvIHRoZSBzaGFwZT8gVGhlIHZlcnRpY2VzIGZvbGxvdy4gTWFrZSBzdXJlIHRoZXkgYXJlIG9yZGVyZWQgQ0NXIGFyb3VuZCB0aGUgbm9ybWFsLCB1c2luZyB0aGUgcmlnaHQgaGFuZCBydWxlLiIpO2ZvcihsZXQgZT0wO2U8dGhpcy5mYWNlc1t0XS5sZW5ndGg7ZSsrKWNvbnNvbGUud2FybigiLnZlcnRpY2VzWyIrdGhpcy5mYWNlc1t0XVtlXSsiXSA9IFZlYzMoIit0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbdF1bZV1dLnRvU3RyaW5nKCkrIikiKX19fWdldEZhY2VOb3JtYWwodCxlKXtjb25zdCBzPXRoaXMuZmFjZXNbdF0saT10aGlzLnZlcnRpY2VzW3NbMF1dLG89dGhpcy52ZXJ0aWNlc1tzWzFdXSxuPXRoaXMudmVydGljZXNbc1syXV07Zi5jb21wdXRlTm9ybWFsKGksbyxuLGUpfWNsaXBBZ2FpbnN0SHVsbCh0LGUscyxvLG4scixhLGwsaCl7Y29uc3QgYz1uZXcgaTtsZXQgdT0tMSxkPS1OdW1iZXIuTUFYX1ZBTFVFO2ZvcihsZXQgdD0wO3Q8cy5mYWNlcy5sZW5ndGg7dCsrKXtjLmNvcHkocy5mYWNlTm9ybWFsc1t0XSksbi52bXVsdChjLGMpO2NvbnN0IGU9Yy5kb3Qocik7ZT5kJiYoZD1lLHU9dCl9Y29uc3QgcD1bXTtmb3IobGV0IHQ9MDt0PHMuZmFjZXNbdV0ubGVuZ3RoO3QrKyl7Y29uc3QgZT1zLnZlcnRpY2VzW3MuZmFjZXNbdV1bdF1dLHI9bmV3IGk7ci5jb3B5KGUpLG4udm11bHQocixyKSxvLnZhZGQocixyKSxwLnB1c2gocil9dT49MCYmdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHIsdCxlLHAsYSxsLGgpfWZpbmRTZXBhcmF0aW5nQXhpcyh0LGUscyxvLG4scixhLGwpe2NvbnN0IGg9bmV3IGksYz1uZXcgaSx1PW5ldyBpLGQ9bmV3IGkscD1uZXcgaSx5PW5ldyBpO2xldCBtPU51bWJlci5NQVhfVkFMVUU7Y29uc3Qgdj10aGlzO2lmKHYudW5pcXVlQXhlcylmb3IobGV0IGk9MDtpIT09di51bmlxdWVBeGVzLmxlbmd0aDtpKyspe3Mudm11bHQodi51bmlxdWVBeGVzW2ldLGgpO2NvbnN0IGE9di50ZXN0U2VwQXhpcyhoLHQsZSxzLG8sbik7aWYoITE9PT1hKXJldHVybiExO2E8bSYmKG09YSxyLmNvcHkoaCkpfWVsc2V7Y29uc3QgaT1hP2EubGVuZ3RoOnYuZmFjZXMubGVuZ3RoO2ZvcihsZXQgbD0wO2w8aTtsKyspe2NvbnN0IGk9YT9hW2xdOmw7aC5jb3B5KHYuZmFjZU5vcm1hbHNbaV0pLHMudm11bHQoaCxoKTtjb25zdCBjPXYudGVzdFNlcEF4aXMoaCx0LGUscyxvLG4pO2lmKCExPT09YylyZXR1cm4hMTtjPG0mJihtPWMsci5jb3B5KGgpKX19aWYodC51bmlxdWVBeGVzKWZvcihsZXQgaT0wO2khPT10LnVuaXF1ZUF4ZXMubGVuZ3RoO2krKyl7bi52bXVsdCh0LnVuaXF1ZUF4ZXNbaV0sYyk7Y29uc3QgYT12LnRlc3RTZXBBeGlzKGMsdCxlLHMsbyxuKTtpZighMT09PWEpcmV0dXJuITE7YTxtJiYobT1hLHIuY29weShjKSl9ZWxzZXtjb25zdCBpPWw/bC5sZW5ndGg6dC5mYWNlcy5sZW5ndGg7Zm9yKGxldCBhPTA7YTxpO2ErKyl7Y29uc3QgaT1sP2xbYV06YTtjLmNvcHkodC5mYWNlTm9ybWFsc1tpXSksbi52bXVsdChjLGMpO2NvbnN0IGg9di50ZXN0U2VwQXhpcyhjLHQsZSxzLG8sbik7aWYoITE9PT1oKXJldHVybiExO2g8bSYmKG09aCxyLmNvcHkoYykpfX1mb3IobGV0IGk9MDtpIT09di51bmlxdWVFZGdlcy5sZW5ndGg7aSsrKXtzLnZtdWx0KHYudW5pcXVlRWRnZXNbaV0sZCk7Zm9yKGxldCBpPTA7aSE9PXQudW5pcXVlRWRnZXMubGVuZ3RoO2krKylpZihuLnZtdWx0KHQudW5pcXVlRWRnZXNbaV0scCksZC5jcm9zcyhwLHkpLCF5LmFsbW9zdFplcm8oKSl7eS5ub3JtYWxpemUoKTtjb25zdCBpPXYudGVzdFNlcEF4aXMoeSx0LGUscyxvLG4pO2lmKCExPT09aSlyZXR1cm4hMTtpPG0mJihtPWksci5jb3B5KHkpKX19cmV0dXJuIG8udnN1YihlLHUpLHUuZG90KHIpPjAmJnIubmVnYXRlKHIpLCEwfXRlc3RTZXBBeGlzKHQsZSxzLGksbyxuKXtmLnByb2plY3QodGhpcyx0LHMsaSx4KSxmLnByb2plY3QoZSx0LG8sbixnKTtjb25zdCByPXhbMF0sYT14WzFdLGw9Z1swXSxoPWdbMV07aWYocjxofHxsPGEpcmV0dXJuITE7Y29uc3QgYz1yLWgsdT1sLWE7cmV0dXJuIGM8dT9jOnV9Y2FsY3VsYXRlTG9jYWxJbmVydGlhKHQsZSl7Y29uc3Qgcz1uZXcgaSxvPW5ldyBpO3RoaXMuY29tcHV0ZUxvY2FsQUFCQihvLHMpO2NvbnN0IG49cy54LW8ueCxyPXMueS1vLnksYT1zLnotby56O2UueD0xLzEyKnQqKDIqcioyKnIrMiphKjIqYSksZS55PTEvMTIqdCooMipuKjIqbisyKmEqMiphKSxlLno9MS8xMip0KigyKnIqMipyKzIqbioyKm4pfWdldFBsYW5lQ29uc3RhbnRPZkZhY2UodCl7Y29uc3QgZT10aGlzLmZhY2VzW3RdLHM9dGhpcy5mYWNlTm9ybWFsc1t0XSxpPXRoaXMudmVydGljZXNbZVswXV07cmV0dXJuLXMuZG90KGkpfWNsaXBGYWNlQWdhaW5zdEh1bGwodCxlLHMsbyxuLHIsYSl7Y29uc3QgbD1uZXcgaSxoPW5ldyBpLGM9bmV3IGksdT1uZXcgaSxkPW5ldyBpLHA9bmV3IGkseT1uZXcgaSxtPW5ldyBpLHY9dGhpcyx3PW8sZj1bXTtsZXQgeD0tMSxnPU51bWJlci5NQVhfVkFMVUU7Zm9yKGxldCBlPTA7ZTx2LmZhY2VzLmxlbmd0aDtlKyspe2wuY29weSh2LmZhY2VOb3JtYWxzW2VdKSxzLnZtdWx0KGwsbCk7Y29uc3QgaT1sLmRvdCh0KTtpPGcmJihnPWkseD1lKX1pZih4PDApcmV0dXJuO2NvbnN0IGI9di5mYWNlc1t4XTtiLmNvbm5lY3RlZEZhY2VzPVtdO2ZvcihsZXQgdD0wO3Q8di5mYWNlcy5sZW5ndGg7dCsrKWZvcihsZXQgZT0wO2U8di5mYWNlc1t0XS5sZW5ndGg7ZSsrKS0xIT09Yi5pbmRleE9mKHYuZmFjZXNbdF1bZV0pJiZ0IT09eCYmLTE9PT1iLmNvbm5lY3RlZEZhY2VzLmluZGV4T2YodCkmJmIuY29ubmVjdGVkRmFjZXMucHVzaCh0KTtjb25zdCBBPWIubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8QTt0Kyspe2NvbnN0IGk9di52ZXJ0aWNlc1tiW3RdXSxvPXYudmVydGljZXNbYlsodCsxKSVBXV07aS52c3ViKG8saCksYy5jb3B5KGgpLHMudm11bHQoYyxjKSxlLnZhZGQoYyxjKSx1LmNvcHkodGhpcy5mYWNlTm9ybWFsc1t4XSkscy52bXVsdCh1LHUpLGUudmFkZCh1LHUpLGMuY3Jvc3ModSxkKSxkLm5lZ2F0ZShkKSxwLmNvcHkoaSkscy52bXVsdChwLHApLGUudmFkZChwLHApO2xldCBuLHI9LXAuZG90KGQpLGE9Yi5jb25uZWN0ZWRGYWNlc1t0XTtpZihudWxsIT1hKXt5LmNvcHkodGhpcy5mYWNlTm9ybWFsc1thXSk7Y29uc3QgdD10aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UoYSk7bS5jb3B5KHkpLHMudm11bHQobSxtKSxlLnZhZGQobSxtKSxuPXQtbS5kb3QoZSl9ZWxzZSBtLmNvcHkoZCksbj1yO2Zvcih0aGlzLmNsaXBGYWNlQWdhaW5zdFBsYW5lKHcsZixtLG4pO3cubGVuZ3RoOyl3LnNoaWZ0KCk7Zm9yKDtmLmxlbmd0aDspdy5wdXNoKGYuc2hpZnQoKSl9eS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbeF0pO2NvbnN0IEI9dGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKHgpO20uY29weSh5KSxzLnZtdWx0KG0sbSk7Y29uc3QgRT1CLW0uZG90KGUpO2ZvcihsZXQgdD0wO3Q8dy5sZW5ndGg7dCsrKXtsZXQgZT1tLmRvdCh3W3RdKStFO2lmKGU8PW4mJihjb25zb2xlLmxvZygiY2xhbXBlZDogZGVwdGg9IitlKyIgdG8gbWluRGlzdD0iK24pLGU9biksZTw9cil7Y29uc3Qgcz13W3RdO2lmKGU8PTFlLTYpe2NvbnN0IHQ9e3BvaW50OnMsbm9ybWFsOm0sZGVwdGg6ZX07YS5wdXNoKHQpfX19fWNsaXBGYWNlQWdhaW5zdFBsYW5lKHQsZSxzLG8pe2xldCBuLHI7Y29uc3QgYT10Lmxlbmd0aDtpZihhPDIpcmV0dXJuIGU7bGV0IGw9dFt0Lmxlbmd0aC0xXSxoPXRbMF07bj1zLmRvdChsKStvO2ZvcihsZXQgYz0wO2M8YTtjKyspe2lmKGg9dFtjXSxyPXMuZG90KGgpK28sbjwwKWlmKHI8MCl7Y29uc3QgdD1uZXcgaTt0LmNvcHkoaCksZS5wdXNoKHQpfWVsc2V7Y29uc3QgdD1uZXcgaTtsLmxlcnAoaCxuLyhuLXIpLHQpLGUucHVzaCh0KX1lbHNlIGlmKHI8MCl7Y29uc3QgdD1uZXcgaTtsLmxlcnAoaCxuLyhuLXIpLHQpLGUucHVzaCh0KSxlLnB1c2goaCl9bD1oLG49cn1yZXR1cm4gZX1jb21wdXRlV29ybGRWZXJ0aWNlcyh0LGUpe2Zvcig7dGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aDx0aGlzLnZlcnRpY2VzLmxlbmd0aDspdGhpcy53b3JsZFZlcnRpY2VzLnB1c2gobmV3IGkpO2NvbnN0IHM9dGhpcy52ZXJ0aWNlcyxvPXRoaXMud29ybGRWZXJ0aWNlcztmb3IobGV0IGk9MDtpIT09dGhpcy52ZXJ0aWNlcy5sZW5ndGg7aSsrKWUudm11bHQoc1tpXSxvW2ldKSx0LnZhZGQob1tpXSxvW2ldKTt0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZT0hMX1jb21wdXRlTG9jYWxBQUJCKHQsZSl7Y29uc3Qgcz10aGlzLnZlcnRpY2VzO3Quc2V0KE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKSxlLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSk7Zm9yKGxldCBpPTA7aTx0aGlzLnZlcnRpY2VzLmxlbmd0aDtpKyspe2NvbnN0IG89c1tpXTtvLng8dC54P3QueD1vLng6by54PmUueCYmKGUueD1vLngpLG8ueTx0Lnk/dC55PW8ueTpvLnk+ZS55JiYoZS55PW8ueSksby56PHQuej90Lno9by56Om8uej5lLnomJihlLno9by56KX19Y29tcHV0ZVdvcmxkRmFjZU5vcm1hbHModCl7Y29uc3QgZT10aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDtmb3IoO3RoaXMud29ybGRGYWNlTm9ybWFscy5sZW5ndGg8ZTspdGhpcy53b3JsZEZhY2VOb3JtYWxzLnB1c2gobmV3IGkpO2NvbnN0IHM9dGhpcy5mYWNlTm9ybWFscyxvPXRoaXMud29ybGRGYWNlTm9ybWFscztmb3IobGV0IGk9MDtpIT09ZTtpKyspdC52bXVsdChzW2ldLG9baV0pO3RoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlPSExfXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7bGV0IHQ9MDtjb25zdCBlPXRoaXMudmVydGljZXM7Zm9yKGxldCBzPTA7cyE9PWUubGVuZ3RoO3MrKyl7Y29uc3QgaT1lW3NdLm5vcm0yKCk7aT50JiYodD1pKX10aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzPU1hdGguc3FydCh0KX1jYWxjdWxhdGVXb3JsZEFBQkIodCxlLHMsbyl7Y29uc3Qgbj10aGlzLnZlcnRpY2VzO2xldCByLGEsbCxoLGMsdSxkPW5ldyBpO2ZvcihsZXQgcz0wO3M8bi5sZW5ndGg7cysrKXtkLmNvcHkobltzXSksZS52bXVsdChkLGQpLHQudmFkZChkLGQpO2NvbnN0IGk9ZDsodm9pZCAwPT09cnx8aS54PHIpJiYocj1pLngpLCh2b2lkIDA9PT1ofHxpLng+aCkmJihoPWkueCksKHZvaWQgMD09PWF8fGkueTxhKSYmKGE9aS55KSwodm9pZCAwPT09Y3x8aS55PmMpJiYoYz1pLnkpLCh2b2lkIDA9PT1sfHxpLno8bCkmJihsPWkueiksKHZvaWQgMD09PXV8fGkuej51KSYmKHU9aS56KX1zLnNldChyLGEsbCksby5zZXQoaCxjLHUpfXZvbHVtZSgpe3JldHVybiA0Kk1hdGguUEkqdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cy8zfWdldEF2ZXJhZ2VQb2ludExvY2FsKHQ9bmV3IGkpe2NvbnN0IGU9dGhpcy52ZXJ0aWNlcztmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0LnZhZGQoZVtzXSx0KTtyZXR1cm4gdC5tdWx0KDEvZS5sZW5ndGgsdCksdH10cmFuc2Zvcm1BbGxQb2ludHModCxlKXtjb25zdCBzPXRoaXMudmVydGljZXMubGVuZ3RoLGk9dGhpcy52ZXJ0aWNlcztpZihlKXtmb3IobGV0IHQ9MDt0PHM7dCsrKXtjb25zdCBzPWlbdF07ZS52bXVsdChzLHMpfWZvcihsZXQgdD0wO3Q8dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7dCsrKXtjb25zdCBzPXRoaXMuZmFjZU5vcm1hbHNbdF07ZS52bXVsdChzLHMpfX1pZih0KWZvcihsZXQgZT0wO2U8cztlKyspe2NvbnN0IHM9aVtlXTtzLnZhZGQodCxzKX19cG9pbnRJc0luc2lkZSh0KXtjb25zdCBlPXRoaXMudmVydGljZXMscz10aGlzLmZhY2VzLG89dGhpcy5mYWNlTm9ybWFscyxuPW5ldyBpO3RoaXMuZ2V0QXZlcmFnZVBvaW50TG9jYWwobik7Zm9yKGxldCByPTA7cjx0aGlzLmZhY2VzLmxlbmd0aDtyKyspe2xldCBhPW9bcl07Y29uc3QgbD1lW3Nbcl1bMF1dLGg9bmV3IGk7dC52c3ViKGwsaCk7Y29uc3QgYz1hLmRvdChoKSx1PW5ldyBpO24udnN1YihsLHUpO2NvbnN0IGQ9YS5kb3QodSk7aWYoYzwwJiZkPjB8fGM+MCYmZDwwKXJldHVybiExfXJldHVybi0xfX1mLmNvbXB1dGVOb3JtYWw9KHQsZSxzLG8pPT57Y29uc3Qgbj1uZXcgaSxyPW5ldyBpO2UudnN1Yih0LHIpLHMudnN1YihlLG4pLG4uY3Jvc3MocixvKSxvLmlzWmVybygpfHxvLm5vcm1hbGl6ZSgpfTtjb25zdCB4PVtdLGc9W107Zi5wcm9qZWN0PSh0LGUscyxvLG4pPT57Y29uc3Qgcj10LnZlcnRpY2VzLmxlbmd0aCxhPW5ldyBpO2xldCBsPTAsaD0wO2NvbnN0IGM9bmV3IGksdT10LnZlcnRpY2VzO2Muc2V0WmVybygpLHYudmVjdG9yVG9Mb2NhbEZyYW1lKHMsbyxlLGEpLHYucG9pbnRUb0xvY2FsRnJhbWUocyxvLGMsYyk7Y29uc3QgZD1jLmRvdChhKTtoPWw9dVswXS5kb3QoYSk7Zm9yKGxldCB0PTE7dDxyO3QrKyl7Y29uc3QgZT11W3RdLmRvdChhKTtlPmwmJihsPWUpLGU8aCYmKGg9ZSl9aWYoaC09ZCxsLT1kLGg+bCl7Y29uc3QgdD1oO2g9bCxsPXR9blswXT1sLG5bMV09aH07Y2xhc3MgYiBleHRlbmRzIG17Y29uc3RydWN0b3IodCl7c3VwZXIoe3R5cGU6bS50eXBlcy5CT1h9KSx0aGlzLmhhbGZFeHRlbnRzPXQsdGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb249e30sdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl9dXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uKCl7Y29uc3QgdD10aGlzLmhhbGZFeHRlbnRzLngsZT10aGlzLmhhbGZFeHRlbnRzLnkscz10aGlzLmhhbGZFeHRlbnRzLnosbz1pLG49W25ldyBvKC10LC1lLC1zKSxuZXcgbyh0LC1lLC1zKSxuZXcgbyh0LGUsLXMpLG5ldyBvKC10LGUsLXMpLG5ldyBvKC10LC1lLHMpLG5ldyBvKHQsLWUscyksbmV3IG8odCxlLHMpLG5ldyBvKC10LGUscyldLHI9W25ldyBvKDAsMCwxKSxuZXcgbygwLDEsMCksbmV3IG8oMSwwLDApXSxhPW5ldyBmKHt2ZXJ0aWNlczpuLGZhY2VzOltbMywyLDEsMF0sWzQsNSw2LDddLFs1LDQsMCwxXSxbMiwzLDcsNl0sWzAsNCw3LDNdLFsxLDIsNiw1XV0sYXhlczpyfSk7dGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb249YSxhLm1hdGVyaWFsPXRoaXMubWF0ZXJpYWx9Y2FsY3VsYXRlTG9jYWxJbmVydGlhKHQsZT1uZXcgaSl7cmV0dXJuIGIuY2FsY3VsYXRlSW5lcnRpYSh0aGlzLmhhbGZFeHRlbnRzLHQsZSksZX1nZXRTaWRlTm9ybWFscyh0LGUpe2NvbnN0IHM9dCxpPXRoaXMuaGFsZkV4dGVudHM7aWYoc1swXS5zZXQoaS54LDAsMCksc1sxXS5zZXQoMCxpLnksMCksc1syXS5zZXQoMCwwLGkueiksc1szXS5zZXQoLWkueCwwLDApLHNbNF0uc2V0KDAsLWkueSwwKSxzWzVdLnNldCgwLDAsLWkueiksdm9pZCAwIT09ZSlmb3IobGV0IHQ9MDt0IT09cy5sZW5ndGg7dCsrKWUudm11bHQoc1t0XSxzW3RdKTtyZXR1cm4gc312b2x1bWUoKXtyZXR1cm4gOCp0aGlzLmhhbGZFeHRlbnRzLngqdGhpcy5oYWxmRXh0ZW50cy55KnRoaXMuaGFsZkV4dGVudHMuen11cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpe3RoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9dGhpcy5oYWxmRXh0ZW50cy5ub3JtKCl9Zm9yRWFjaFdvcmxkQ29ybmVyKHQsZSxzKXtjb25zdCBpPXRoaXMuaGFsZkV4dGVudHMsbz1bW2kueCxpLnksaS56XSxbLWkueCxpLnksaS56XSxbLWkueCwtaS55LGkuel0sWy1pLngsLWkueSwtaS56XSxbaS54LC1pLnksLWkuel0sW2kueCxpLnksLWkuel0sWy1pLngsaS55LC1pLnpdLFtpLngsLWkueSxpLnpdXTtmb3IobGV0IGk9MDtpPG8ubGVuZ3RoO2krKylBLnNldChvW2ldWzBdLG9baV1bMV0sb1tpXVsyXSksZS52bXVsdChBLEEpLHQudmFkZChBLEEpLHMoQS54LEEueSxBLnopfWNhbGN1bGF0ZVdvcmxkQUFCQih0LGUscyxpKXtjb25zdCBvPXRoaXMuaGFsZkV4dGVudHM7QlswXS5zZXQoby54LG8ueSxvLnopLEJbMV0uc2V0KC1vLngsby55LG8ueiksQlsyXS5zZXQoLW8ueCwtby55LG8ueiksQlszXS5zZXQoLW8ueCwtby55LC1vLnopLEJbNF0uc2V0KG8ueCwtby55LC1vLnopLEJbNV0uc2V0KG8ueCxvLnksLW8ueiksQls2XS5zZXQoLW8ueCxvLnksLW8ueiksQls3XS5zZXQoby54LC1vLnksby56KTtjb25zdCBuPUJbMF07ZS52bXVsdChuLG4pLHQudmFkZChuLG4pLGkuY29weShuKSxzLmNvcHkobik7Zm9yKGxldCBvPTE7bzw4O28rKyl7Y29uc3Qgbj1CW29dO2Uudm11bHQobixuKSx0LnZhZGQobixuKTtjb25zdCByPW4ueCxhPW4ueSxsPW4uejtyPmkueCYmKGkueD1yKSxhPmkueSYmKGkueT1hKSxsPmkueiYmKGkuej1sKSxyPHMueCYmKHMueD1yKSxhPHMueSYmKHMueT1hKSxsPHMueiYmKHMuej1sKX19fWIuY2FsY3VsYXRlSW5lcnRpYT0odCxlLHMpPT57Y29uc3QgaT10O3MueD0xLzEyKmUqKDIqaS55KjIqaS55KzIqaS56KjIqaS56KSxzLnk9MS8xMiplKigyKmkueCoyKmkueCsyKmkueioyKmkueikscy56PTEvMTIqZSooMippLnkqMippLnkrMippLngqMippLngpfTtjb25zdCBBPW5ldyBpLEI9W25ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpXSxFPTAsej0xLEY9MjtjbGFzcyBTIGV4dGVuZHMgdXtjb25zdHJ1Y3Rvcih0PXt9KXtzdXBlcigpLHRoaXMuaWQ9Uy5pZENvdW50ZXIrKyx0aGlzLmluZGV4PS0xLHRoaXMud29ybGQ9bnVsbCx0aGlzLnByZVN0ZXA9bnVsbCx0aGlzLnBvc3RTdGVwPW51bGwsdGhpcy52bGFtYmRhPW5ldyBpLHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXA9Im51bWJlciI9PXR5cGVvZiB0LmNvbGxpc2lvbkZpbHRlckdyb3VwP3QuY29sbGlzaW9uRmlsdGVyR3JvdXA6MSx0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2s9Im51bWJlciI9PXR5cGVvZiB0LmNvbGxpc2lvbkZpbHRlck1hc2s/dC5jb2xsaXNpb25GaWx0ZXJNYXNrOi0xLHRoaXMuY29sbGlzaW9uUmVzcG9uc2U9ITAsdGhpcy5wb3NpdGlvbj1uZXcgaSx0aGlzLnByZXZpb3VzUG9zaXRpb249bmV3IGksdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbj1uZXcgaSx0aGlzLmluaXRQb3NpdGlvbj1uZXcgaSx0LnBvc2l0aW9uJiYodGhpcy5wb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pLHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pLHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0aGlzLmluaXRQb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pKSx0aGlzLnZlbG9jaXR5PW5ldyBpLHQudmVsb2NpdHkmJnRoaXMudmVsb2NpdHkuY29weSh0LnZlbG9jaXR5KSx0aGlzLmluaXRWZWxvY2l0eT1uZXcgaSx0aGlzLmZvcmNlPW5ldyBpO2NvbnN0IGU9Im51bWJlciI9PXR5cGVvZiB0Lm1hc3M/dC5tYXNzOjA7dGhpcy5tYXNzPWUsdGhpcy5pbnZNYXNzPWU+MD8xL2U6MCx0aGlzLm1hdGVyaWFsPXQubWF0ZXJpYWx8fG51bGwsdGhpcy5saW5lYXJEYW1waW5nPSJudW1iZXIiPT10eXBlb2YgdC5saW5lYXJEYW1waW5nP3QubGluZWFyRGFtcGluZzouMDEsdGhpcy50eXBlPWU8PTA/Uy5TVEFUSUM6Uy5EWU5BTUlDLHR5cGVvZiB0LnR5cGU9PXR5cGVvZiBTLlNUQVRJQyYmKHRoaXMudHlwZT10LnR5cGUpLHRoaXMuYWxsb3dTbGVlcD12b2lkIDA9PT10LmFsbG93U2xlZXB8fHQuYWxsb3dTbGVlcCx0aGlzLnNsZWVwU3RhdGU9MCx0aGlzLnNsZWVwU3BlZWRMaW1pdD12b2lkIDAhPT10LnNsZWVwU3BlZWRMaW1pdD90LnNsZWVwU3BlZWRMaW1pdDouMSx0aGlzLnNsZWVwVGltZUxpbWl0PXZvaWQgMCE9PXQuc2xlZXBUaW1lTGltaXQ/dC5zbGVlcFRpbWVMaW1pdDoxLHRoaXMudGltZUxhc3RTbGVlcHk9MCx0aGlzLndha2VVcEFmdGVyTmFycm93cGhhc2U9ITEsdGhpcy50b3JxdWU9bmV3IGksdGhpcy5xdWF0ZXJuaW9uPW5ldyBkLHRoaXMuaW5pdFF1YXRlcm5pb249bmV3IGQsdGhpcy5wcmV2aW91c1F1YXRlcm5pb249bmV3IGQsdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uPW5ldyBkLHQucXVhdGVybmlvbiYmKHRoaXMucXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbiksdGhpcy5pbml0UXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbiksdGhpcy5wcmV2aW91c1F1YXRlcm5pb24uY29weSh0LnF1YXRlcm5pb24pLHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbikpLHRoaXMuYW5ndWxhclZlbG9jaXR5PW5ldyBpLHQuYW5ndWxhclZlbG9jaXR5JiZ0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KHQuYW5ndWxhclZlbG9jaXR5KSx0aGlzLmluaXRBbmd1bGFyVmVsb2NpdHk9bmV3IGksdGhpcy5zaGFwZXM9W10sdGhpcy5zaGFwZU9mZnNldHM9W10sdGhpcy5zaGFwZU9yaWVudGF0aW9ucz1bXSx0aGlzLmluZXJ0aWE9bmV3IGksdGhpcy5pbnZJbmVydGlhPW5ldyBpLHRoaXMuaW52SW5lcnRpYVdvcmxkPW5ldyBzLHRoaXMuaW52TWFzc1NvbHZlPTAsdGhpcy5pbnZJbmVydGlhU29sdmU9bmV3IGksdGhpcy5pbnZJbmVydGlhV29ybGRTb2x2ZT1uZXcgcyx0aGlzLmZpeGVkUm90YXRpb249dm9pZCAwIT09dC5maXhlZFJvdGF0aW9uJiZ0LmZpeGVkUm90YXRpb24sdGhpcy5hbmd1bGFyRGFtcGluZz12b2lkIDAhPT10LmFuZ3VsYXJEYW1waW5nP3QuYW5ndWxhckRhbXBpbmc6LjAxLHRoaXMubGluZWFyRmFjdG9yPW5ldyBpKDEsMSwxKSx0LmxpbmVhckZhY3RvciYmdGhpcy5saW5lYXJGYWN0b3IuY29weSh0LmxpbmVhckZhY3RvciksdGhpcy5hbmd1bGFyRmFjdG9yPW5ldyBpKDEsMSwxKSx0LmFuZ3VsYXJGYWN0b3ImJnRoaXMuYW5ndWxhckZhY3Rvci5jb3B5KHQuYW5ndWxhckZhY3RvciksdGhpcy5hYWJiPW5ldyBhLHRoaXMuYWFiYk5lZWRzVXBkYXRlPSEwLHRoaXMuYm91bmRpbmdSYWRpdXM9MCx0aGlzLndsYW1iZGE9bmV3IGksdC5zaGFwZSYmdGhpcy5hZGRTaGFwZSh0LnNoYXBlKSx0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCl9d2FrZVVwKCl7Y29uc3QgdD10aGlzLnNsZWVwU3RhdGU7dGhpcy5zbGVlcFN0YXRlPTAsdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlPSExLHQ9PT1TLlNMRUVQSU5HJiZ0aGlzLmRpc3BhdGNoRXZlbnQoUy53YWtldXBFdmVudCl9c2xlZXAoKXt0aGlzLnNsZWVwU3RhdGU9Uy5TTEVFUElORyx0aGlzLnZlbG9jaXR5LnNldCgwLDAsMCksdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKSx0aGlzLndha2VVcEFmdGVyTmFycm93cGhhc2U9ITF9c2xlZXBUaWNrKHQpe2lmKHRoaXMuYWxsb3dTbGVlcCl7Y29uc3QgZT10aGlzLnNsZWVwU3RhdGUscz10aGlzLnZlbG9jaXR5Lm5vcm0yKCkrdGhpcy5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKSxpPXRoaXMuc2xlZXBTcGVlZExpbWl0KioyO2U9PT1TLkFXQUtFJiZzPGk/KHRoaXMuc2xlZXBTdGF0ZT1TLlNMRUVQWSx0aGlzLnRpbWVMYXN0U2xlZXB5PXQsdGhpcy5kaXNwYXRjaEV2ZW50KFMuc2xlZXB5RXZlbnQpKTplPT09Uy5TTEVFUFkmJnM+aT90aGlzLndha2VVcCgpOmU9PT1TLlNMRUVQWSYmdC10aGlzLnRpbWVMYXN0U2xlZXB5PnRoaXMuc2xlZXBUaW1lTGltaXQmJih0aGlzLnNsZWVwKCksdGhpcy5kaXNwYXRjaEV2ZW50KFMuc2xlZXBFdmVudCkpfX11cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCl7dGhpcy5zbGVlcFN0YXRlPT09Uy5TTEVFUElOR3x8dGhpcy50eXBlPT09Uy5LSU5FTUFUSUM/KHRoaXMuaW52TWFzc1NvbHZlPTAsdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpLHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpKToodGhpcy5pbnZNYXNzU29sdmU9dGhpcy5pbnZNYXNzLHRoaXMuaW52SW5lcnRpYVNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhKSx0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpKX1wb2ludFRvTG9jYWxGcmFtZSh0LGU9bmV3IGkpe3JldHVybiB0LnZzdWIodGhpcy5wb3NpdGlvbixlKSx0aGlzLnF1YXRlcm5pb24uY29uanVnYXRlKCkudm11bHQoZSxlKSxlfXZlY3RvclRvTG9jYWxGcmFtZSh0LGU9bmV3IGkpe3JldHVybiB0aGlzLnF1YXRlcm5pb24uY29uanVnYXRlKCkudm11bHQodCxlKSxlfXBvaW50VG9Xb3JsZEZyYW1lKHQsZT1uZXcgaSl7cmV0dXJuIHRoaXMucXVhdGVybmlvbi52bXVsdCh0LGUpLGUudmFkZCh0aGlzLnBvc2l0aW9uLGUpLGV9dmVjdG9yVG9Xb3JsZEZyYW1lKHQsZT1uZXcgaSl7cmV0dXJuIHRoaXMucXVhdGVybmlvbi52bXVsdCh0LGUpLGV9YWRkU2hhcGUodCxlLHMpe2NvbnN0IG89bmV3IGksbj1uZXcgZDtyZXR1cm4gZSYmby5jb3B5KGUpLHMmJm4uY29weShzKSx0aGlzLnNoYXBlcy5wdXNoKHQpLHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gobyksdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKG4pLHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKSx0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCksdGhpcy5hYWJiTmVlZHNVcGRhdGU9ITAsdC5ib2R5PXRoaXMsdGhpc311cGRhdGVCb3VuZGluZ1JhZGl1cygpe2NvbnN0IHQ9dGhpcy5zaGFwZXMsZT10aGlzLnNoYXBlT2Zmc2V0cyxzPXQubGVuZ3RoO2xldCBpPTA7Zm9yKGxldCBvPTA7byE9PXM7bysrKXtjb25zdCBzPXRbb107cy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO2NvbnN0IG49ZVtvXS5ub3JtKCkscj1zLmJvdW5kaW5nU3BoZXJlUmFkaXVzO24rcj5pJiYoaT1uK3IpfXRoaXMuYm91bmRpbmdSYWRpdXM9aX1jb21wdXRlQUFCQigpe2NvbnN0IHQ9dGhpcy5zaGFwZXMsZT10aGlzLnNoYXBlT2Zmc2V0cyxzPXRoaXMuc2hhcGVPcmllbnRhdGlvbnMsaT10Lmxlbmd0aCxvPU0sbj1DLHI9dGhpcy5xdWF0ZXJuaW9uLGE9dGhpcy5hYWJiLGw9cTtmb3IobGV0IGg9MDtoIT09aTtoKyspe2NvbnN0IGk9dFtoXTtyLnZtdWx0KGVbaF0sbyksby52YWRkKHRoaXMucG9zaXRpb24sbyksci5tdWx0KHNbaF0sbiksaS5jYWxjdWxhdGVXb3JsZEFBQkIobyxuLGwubG93ZXJCb3VuZCxsLnVwcGVyQm91bmQpLDA9PT1oP2EuY29weShsKTphLmV4dGVuZChsKX10aGlzLmFhYmJOZWVkc1VwZGF0ZT0hMX11cGRhdGVJbmVydGlhV29ybGQodCl7Y29uc3QgZT10aGlzLmludkluZXJ0aWE7aWYoZS54IT09ZS55fHxlLnkhPT1lLnp8fHQpe2NvbnN0IHQ9VCxzPVA7dC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbiksdC50cmFuc3Bvc2UocyksdC5zY2FsZShlLHQpLHQubW11bHQocyx0aGlzLmludkluZXJ0aWFXb3JsZCl9ZWxzZTt9YXBwbHlGb3JjZSh0LGUpe2lmKHRoaXMudHlwZSE9PVMuRFlOQU1JQylyZXR1cm47Y29uc3Qgcz1OO2UuY3Jvc3ModCxzKSx0aGlzLmZvcmNlLnZhZGQodCx0aGlzLmZvcmNlKSx0aGlzLnRvcnF1ZS52YWRkKHMsdGhpcy50b3JxdWUpfWFwcGx5TG9jYWxGb3JjZSh0LGUpe2lmKHRoaXMudHlwZSE9PVMuRFlOQU1JQylyZXR1cm47Y29uc3Qgcz1SLGk9STt0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh0LHMpLHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGUsaSksdGhpcy5hcHBseUZvcmNlKHMsaSl9YXBwbHlJbXB1bHNlKHQsZSl7aWYodGhpcy50eXBlIT09Uy5EWU5BTUlDKXJldHVybjtjb25zdCBzPWUsaT1MO2kuY29weSh0KSxpLm11bHQodGhpcy5pbnZNYXNzLGkpLHRoaXMudmVsb2NpdHkudmFkZChpLHRoaXMudmVsb2NpdHkpO2NvbnN0IG89ajtzLmNyb3NzKHQsbyksdGhpcy5pbnZJbmVydGlhV29ybGQudm11bHQobyxvKSx0aGlzLmFuZ3VsYXJWZWxvY2l0eS52YWRkKG8sdGhpcy5hbmd1bGFyVmVsb2NpdHkpfWFwcGx5TG9jYWxJbXB1bHNlKHQsZSl7aWYodGhpcy50eXBlIT09Uy5EWU5BTUlDKXJldHVybjtjb25zdCBzPVYsaT1rO3RoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHQscyksdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUoZSxpKSx0aGlzLmFwcGx5SW1wdWxzZShzLGkpfXVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCl7Y29uc3QgdD1XO3RoaXMuaW52TWFzcz10aGlzLm1hc3M+MD8xL3RoaXMubWFzczowO2NvbnN0IGU9dGhpcy5pbmVydGlhLHM9dGhpcy5maXhlZFJvdGF0aW9uO3RoaXMuY29tcHV0ZUFBQkIoKSx0LnNldCgodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KS8yLCh0aGlzLmFhYmIudXBwZXJCb3VuZC55LXRoaXMuYWFiYi5sb3dlckJvdW5kLnkpLzIsKHRoaXMuYWFiYi51cHBlckJvdW5kLnotdGhpcy5hYWJiLmxvd2VyQm91bmQueikvMiksYi5jYWxjdWxhdGVJbmVydGlhKHQsdGhpcy5tYXNzLGUpLHRoaXMuaW52SW5lcnRpYS5zZXQoZS54PjAmJiFzPzEvZS54OjAsZS55PjAmJiFzPzEvZS55OjAsZS56PjAmJiFzPzEvZS56OjApLHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCEwKX1nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh0LGUpe2NvbnN0IHM9bmV3IGk7cmV0dXJuIHQudnN1Yih0aGlzLnBvc2l0aW9uLHMpLHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHMsZSksdGhpcy52ZWxvY2l0eS52YWRkKGUsZSksZX1pbnRlZ3JhdGUodCxlLHMpe2lmKHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24pLHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKSx0aGlzLnR5cGUhPT1TLkRZTkFNSUMmJnRoaXMudHlwZSE9PVMuS0lORU1BVElDfHx0aGlzLnNsZWVwU3RhdGU9PT1TLlNMRUVQSU5HKXJldHVybjtjb25zdCBpPXRoaXMudmVsb2NpdHksbz10aGlzLmFuZ3VsYXJWZWxvY2l0eSxuPXRoaXMucG9zaXRpb24scj10aGlzLmZvcmNlLGE9dGhpcy50b3JxdWUsbD10aGlzLnF1YXRlcm5pb24saD10aGlzLmludk1hc3MsYz10aGlzLmludkluZXJ0aWFXb3JsZCx1PXRoaXMubGluZWFyRmFjdG9yLGQ9aCp0O2kueCs9ci54KmQqdS54LGkueSs9ci55KmQqdS55LGkueis9ci56KmQqdS56O2NvbnN0IHA9Yy5lbGVtZW50cyx5PXRoaXMuYW5ndWxhckZhY3RvcixtPWEueCp5Lngsdj1hLnkqeS55LHc9YS56KnkuejtvLngrPXQqKHBbMF0qbStwWzFdKnYrcFsyXSp3KSxvLnkrPXQqKHBbM10qbStwWzRdKnYrcFs1XSp3KSxvLnorPXQqKHBbNl0qbStwWzddKnYrcFs4XSp3KSxuLngrPWkueCp0LG4ueSs9aS55KnQsbi56Kz1pLnoqdCxsLmludGVncmF0ZSh0aGlzLmFuZ3VsYXJWZWxvY2l0eSx0LHRoaXMuYW5ndWxhckZhY3RvcixsKSxlJiYocz9sLm5vcm1hbGl6ZUZhc3QoKTpsLm5vcm1hbGl6ZSgpKSx0aGlzLmFhYmJOZWVkc1VwZGF0ZT0hMCx0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCgpfX1TLkNPTExJREVfRVZFTlRfTkFNRT0iY29sbGlkZSIsUy5EWU5BTUlDPTEsUy5TVEFUSUM9MixTLktJTkVNQVRJQz00LFMuQVdBS0U9RSxTLlNMRUVQWT16LFMuU0xFRVBJTkc9RixTLmlkQ291bnRlcj0wLFMud2FrZXVwRXZlbnQ9e3R5cGU6Indha2V1cCJ9LFMuc2xlZXB5RXZlbnQ9e3R5cGU6InNsZWVweSJ9LFMuc2xlZXBFdmVudD17dHlwZToic2xlZXAifTtjb25zdCBNPW5ldyBpLEM9bmV3IGQscT1uZXcgYSxUPW5ldyBzLFA9bmV3IHMsTj1uZXcgaSxSPW5ldyBpLEk9bmV3IGksTD1uZXcgaSxqPW5ldyBpLFY9bmV3IGksaz1uZXcgaSxXPW5ldyBpO2NsYXNzIE97Y29uc3RydWN0b3IoKXt0aGlzLndvcmxkPW51bGwsdGhpcy51c2VCb3VuZGluZ0JveGVzPSExLHRoaXMuZGlydHk9ITB9Y29sbGlzaW9uUGFpcnModCxlLHMpe3Rocm93IG5ldyBFcnJvcigiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhIil9bmVlZEJyb2FkcGhhc2VDb2xsaXNpb24odCxlKXtyZXR1cm4gMCE9KHQuY29sbGlzaW9uRmlsdGVyR3JvdXAmZS5jb2xsaXNpb25GaWx0ZXJNYXNrKSYmMCE9KGUuY29sbGlzaW9uRmlsdGVyR3JvdXAmdC5jb2xsaXNpb25GaWx0ZXJNYXNrKSYmKDA9PSh0LnR5cGUmUy5TVEFUSUMpJiZ0LnNsZWVwU3RhdGUhPT1TLlNMRUVQSU5HfHwwPT0oZS50eXBlJlMuU1RBVElDKSYmZS5zbGVlcFN0YXRlIT09Uy5TTEVFUElORyl9aW50ZXJzZWN0aW9uVGVzdCh0LGUscyxpKXt0aGlzLnVzZUJvdW5kaW5nQm94ZXM/dGhpcy5kb0JvdW5kaW5nQm94QnJvYWRwaGFzZSh0LGUscyxpKTp0aGlzLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKHQsZSxzLGkpfWRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKHQsZSxzLGkpe2NvbnN0IG89XztlLnBvc2l0aW9uLnZzdWIodC5wb3NpdGlvbixvKTtjb25zdCBuPSh0LmJvdW5kaW5nUmFkaXVzK2UuYm91bmRpbmdSYWRpdXMpKioyO28ubm9ybTIoKTxuJiYocy5wdXNoKHQpLGkucHVzaChlKSl9ZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UodCxlLHMsaSl7dC5hYWJiTmVlZHNVcGRhdGUmJnQuY29tcHV0ZUFBQkIoKSxlLmFhYmJOZWVkc1VwZGF0ZSYmZS5jb21wdXRlQUFCQigpLHQuYWFiYi5vdmVybGFwcyhlLmFhYmIpJiYocy5wdXNoKHQpLGkucHVzaChlKSl9bWFrZVBhaXJzVW5pcXVlKHQsZSl7Y29uc3Qgcz1ILGk9VSxvPUcsbj10Lmxlbmd0aDtmb3IobGV0IHM9MDtzIT09bjtzKyspaVtzXT10W3NdLG9bc109ZVtzXTt0Lmxlbmd0aD0wLGUubGVuZ3RoPTA7Zm9yKGxldCB0PTA7dCE9PW47dCsrKXtjb25zdCBlPWlbdF0uaWQsbj1vW3RdLmlkLHI9ZTxuP2UrIiwiK246bisiLCIrZTtzW3JdPXQscy5rZXlzLnB1c2gocil9Zm9yKGxldCBuPTA7biE9PXMua2V5cy5sZW5ndGg7bisrKXtjb25zdCBuPXMua2V5cy5wb3AoKSxyPXNbbl07dC5wdXNoKGlbcl0pLGUucHVzaChvW3JdKSxkZWxldGUgc1tuXX19c2V0V29ybGQodCl7fWFhYmJRdWVyeSh0LGUscyl7cmV0dXJuIGNvbnNvbGUud2FybigiLmFhYmJRdWVyeSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBCcm9hZHBoYXNlIHN1YmNsYXNzLiIpLFtdfX1jb25zdCBfPW5ldyBpLEg9e2tleXM6W119LFU9W10sRz1bXTtPLmJvdW5kaW5nU3BoZXJlQ2hlY2s9KHQsZSk9Pntjb25zdCBzPW5ldyBpO3QucG9zaXRpb24udnN1YihlLnBvc2l0aW9uLHMpO2NvbnN0IG89dC5zaGFwZXNbMF0sbj1lLnNoYXBlc1swXTtyZXR1cm4gTWF0aC5wb3coby5ib3VuZGluZ1NwaGVyZVJhZGl1cytuLmJvdW5kaW5nU3BoZXJlUmFkaXVzLDIpPnMubm9ybTIoKX07Y2xhc3MgRCBleHRlbmRzIE97Y29uc3RydWN0b3IoKXtzdXBlcigpfWNvbGxpc2lvblBhaXJzKHQsZSxzKXtjb25zdCBpPXQuYm9kaWVzLG89aS5sZW5ndGg7bGV0IG4scjtmb3IobGV0IHQ9MDt0IT09bzt0KyspZm9yKGxldCBvPTA7byE9PXQ7bysrKW49aVt0XSxyPWlbb10sdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihuLHIpJiZ0aGlzLmludGVyc2VjdGlvblRlc3QobixyLGUscyl9YWFiYlF1ZXJ5KHQsZSxzPVtdKXtmb3IobGV0IGk9MDtpPHQuYm9kaWVzLmxlbmd0aDtpKyspe2NvbnN0IG89dC5ib2RpZXNbaV07by5hYWJiTmVlZHNVcGRhdGUmJm8uY29tcHV0ZUFBQkIoKSxvLmFhYmIub3ZlcmxhcHMoZSkmJnMucHVzaChvKX1yZXR1cm4gc319Y2xhc3MgWHtjb25zdHJ1Y3Rvcigpe3RoaXMucmF5RnJvbVdvcmxkPW5ldyBpLHRoaXMucmF5VG9Xb3JsZD1uZXcgaSx0aGlzLmhpdE5vcm1hbFdvcmxkPW5ldyBpLHRoaXMuaGl0UG9pbnRXb3JsZD1uZXcgaSx0aGlzLmhhc0hpdD0hMSx0aGlzLnNoYXBlPW51bGwsdGhpcy5ib2R5PW51bGwsdGhpcy5oaXRGYWNlSW5kZXg9LTEsdGhpcy5kaXN0YW5jZT0tMSx0aGlzLnNob3VsZFN0b3A9ITF9cmVzZXQoKXt0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCksdGhpcy5yYXlUb1dvcmxkLnNldFplcm8oKSx0aGlzLmhpdE5vcm1hbFdvcmxkLnNldFplcm8oKSx0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpLHRoaXMuaGFzSGl0PSExLHRoaXMuc2hhcGU9bnVsbCx0aGlzLmJvZHk9bnVsbCx0aGlzLmhpdEZhY2VJbmRleD0tMSx0aGlzLmRpc3RhbmNlPS0xLHRoaXMuc2hvdWxkU3RvcD0hMX1hYm9ydCgpe3RoaXMuc2hvdWxkU3RvcD0hMH1zZXQodCxlLHMsaSxvLG4scil7dGhpcy5yYXlGcm9tV29ybGQuY29weSh0KSx0aGlzLnJheVRvV29ybGQuY29weShlKSx0aGlzLmhpdE5vcm1hbFdvcmxkLmNvcHkocyksdGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaSksdGhpcy5zaGFwZT1vLHRoaXMuYm9keT1uLHRoaXMuZGlzdGFuY2U9cn19Y2xhc3MgWXtjb25zdHJ1Y3Rvcih0PW5ldyBpLGU9bmV3IGkpe3RoaXMuZnJvbT10LmNsb25lKCksdGhpcy50bz1lLmNsb25lKCksdGhpcy5kaXJlY3Rpb249bmV3IGksdGhpcy5wcmVjaXNpb249MWUtNCx0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9ITAsdGhpcy5za2lwQmFja2ZhY2VzPSExLHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMSx0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xLHRoaXMubW9kZT1ZLkFOWSx0aGlzLnJlc3VsdD1uZXcgWCx0aGlzLmhhc0hpdD0hMSx0aGlzLmNhbGxiYWNrPXQ9Pnt9fWludGVyc2VjdFdvcmxkKHQsZSl7cmV0dXJuIHRoaXMubW9kZT1lLm1vZGV8fFkuQU5ZLHRoaXMucmVzdWx0PWUucmVzdWx0fHxuZXcgWCx0aGlzLnNraXBCYWNrZmFjZXM9ISFlLnNraXBCYWNrZmFjZXMsdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrPXZvaWQgMCE9PWUuY29sbGlzaW9uRmlsdGVyTWFzaz9lLmNvbGxpc2lvbkZpbHRlck1hc2s6LTEsdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cD12b2lkIDAhPT1lLmNvbGxpc2lvbkZpbHRlckdyb3VwP2UuY29sbGlzaW9uRmlsdGVyR3JvdXA6LTEsdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXZvaWQgMD09PWUuY2hlY2tDb2xsaXNpb25SZXNwb25zZXx8ZS5jaGVja0NvbGxpc2lvblJlc3BvbnNlLGUuZnJvbSYmdGhpcy5mcm9tLmNvcHkoZS5mcm9tKSxlLnRvJiZ0aGlzLnRvLmNvcHkoZS50byksdGhpcy5jYWxsYmFjaz1lLmNhbGxiYWNrfHwoKCk9Pnt9KSx0aGlzLmhhc0hpdD0hMSx0aGlzLnJlc3VsdC5yZXNldCgpLHRoaXMudXBkYXRlRGlyZWN0aW9uKCksdGhpcy5nZXRBQUJCKFopLEsubGVuZ3RoPTAsdC5icm9hZHBoYXNlLmFhYmJRdWVyeSh0LFosSyksdGhpcy5pbnRlcnNlY3RCb2RpZXMoSyksdGhpcy5oYXNIaXR9aW50ZXJzZWN0Qm9keSh0LGUpe2UmJih0aGlzLnJlc3VsdD1lLHRoaXMudXBkYXRlRGlyZWN0aW9uKCkpO2NvbnN0IHM9dGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlO2lmKHMmJiF0LmNvbGxpc2lvblJlc3BvbnNlKXJldHVybjtpZigwPT0odGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCZ0LmNvbGxpc2lvbkZpbHRlck1hc2spfHwwPT0odC5jb2xsaXNpb25GaWx0ZXJHcm91cCZ0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2spKXJldHVybjtjb25zdCBpPXR0LG89ZXQ7Zm9yKGxldCBlPTAsbj10LnNoYXBlcy5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LnNoYXBlc1tlXTtpZigoIXN8fG4uY29sbGlzaW9uUmVzcG9uc2UpJiYodC5xdWF0ZXJuaW9uLm11bHQodC5zaGFwZU9yaWVudGF0aW9uc1tlXSxvKSx0LnF1YXRlcm5pb24udm11bHQodC5zaGFwZU9mZnNldHNbZV0saSksaS52YWRkKHQucG9zaXRpb24saSksdGhpcy5pbnRlcnNlY3RTaGFwZShuLG8saSx0KSx0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSlicmVha319aW50ZXJzZWN0Qm9kaWVzKHQsZSl7ZSYmKHRoaXMucmVzdWx0PWUsdGhpcy51cGRhdGVEaXJlY3Rpb24oKSk7Zm9yKGxldCBlPTAscz10Lmxlbmd0aDshdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCYmZTxzO2UrKyl0aGlzLmludGVyc2VjdEJvZHkodFtlXSl9dXBkYXRlRGlyZWN0aW9uKCl7dGhpcy50by52c3ViKHRoaXMuZnJvbSx0aGlzLmRpcmVjdGlvbiksdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCl9aW50ZXJzZWN0U2hhcGUodCxlLHMsaSl7aWYoZnVuY3Rpb24odCxlLHMpe3MudnN1Yih0LEF0KTtjb25zdCBpPUF0LmRvdChlKTtyZXR1cm4gZS5tdWx0KGksQnQpLEJ0LnZhZGQodCxCdCkscy5kaXN0YW5jZVRvKEJ0KX0odGhpcy5mcm9tLHRoaXMuZGlyZWN0aW9uLHMpPnQuYm91bmRpbmdTcGhlcmVSYWRpdXMpcmV0dXJuO2NvbnN0IG89dGhpc1t0LnR5cGVdO28mJm8uY2FsbCh0aGlzLHQsZSxzLGksdCl9X2ludGVyc2VjdEJveCh0LGUscyxpLG8pe3JldHVybiB0aGlzLl9pbnRlcnNlY3RDb252ZXgodC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sZSxzLGksbyl9X2ludGVyc2VjdFBsYW5lKHQsZSxzLG8sbil7Y29uc3Qgcj10aGlzLmZyb20sYT10aGlzLnRvLGw9dGhpcy5kaXJlY3Rpb24saD1uZXcgaSgwLDAsMSk7ZS52bXVsdChoLGgpO2NvbnN0IGM9bmV3IGk7ci52c3ViKHMsYyk7Y29uc3QgdT1jLmRvdChoKTtpZihhLnZzdWIocyxjKSx1KmMuZG90KGgpPjApcmV0dXJuO2lmKHIuZGlzdGFuY2VUbyhhKTx1KXJldHVybjtjb25zdCBkPWguZG90KGwpO2lmKE1hdGguYWJzKGQpPHRoaXMucHJlY2lzaW9uKXJldHVybjtjb25zdCBwPW5ldyBpLHk9bmV3IGksbT1uZXcgaTtyLnZzdWIocyxwKTtjb25zdCB2PS1oLmRvdChwKS9kO2wuc2NhbGUodix5KSxyLnZhZGQoeSxtKSx0aGlzLnJlcG9ydEludGVyc2VjdGlvbihoLG0sbixvLC0xKX1nZXRBQUJCKHQpe2NvbnN0e2xvd2VyQm91bmQ6ZSx1cHBlckJvdW5kOnN9PXQsaT10aGlzLnRvLG89dGhpcy5mcm9tO2UueD1NYXRoLm1pbihpLngsby54KSxlLnk9TWF0aC5taW4oaS55LG8ueSksZS56PU1hdGgubWluKGkueixvLnopLHMueD1NYXRoLm1heChpLngsby54KSxzLnk9TWF0aC5tYXgoaS55LG8ueSkscy56PU1hdGgubWF4KGkueixvLnopfV9pbnRlcnNlY3RIZWlnaHRmaWVsZCh0LGUscyxpLG8pe3QuZGF0YSx0LmVsZW1lbnRTaXplO2NvbnN0IG49bHQ7bi5mcm9tLmNvcHkodGhpcy5mcm9tKSxuLnRvLmNvcHkodGhpcy50byksdi5wb2ludFRvTG9jYWxGcmFtZShzLGUsbi5mcm9tLG4uZnJvbSksdi5wb2ludFRvTG9jYWxGcmFtZShzLGUsbi50byxuLnRvKSxuLnVwZGF0ZURpcmVjdGlvbigpO2NvbnN0IHI9aHQ7bGV0IGwsaCxjLHU7bD1oPTAsYz11PXQuZGF0YS5sZW5ndGgtMTtjb25zdCBkPW5ldyBhO24uZ2V0QUFCQihkKSx0LmdldEluZGV4T2ZQb3NpdGlvbihkLmxvd2VyQm91bmQueCxkLmxvd2VyQm91bmQueSxyLCEwKSxsPU1hdGgubWF4KGwsclswXSksaD1NYXRoLm1heChoLHJbMV0pLHQuZ2V0SW5kZXhPZlBvc2l0aW9uKGQudXBwZXJCb3VuZC54LGQudXBwZXJCb3VuZC55LHIsITApLGM9TWF0aC5taW4oYyxyWzBdKzEpLHU9TWF0aC5taW4odSxyWzFdKzEpO2ZvcihsZXQgcj1sO3I8YztyKyspZm9yKGxldCBhPWg7YTx1O2ErKyl7aWYodGhpcy5yZXN1bHQuc2hvdWxkU3RvcClyZXR1cm47aWYodC5nZXRBYWJiQXRJbmRleChyLGEsZCksZC5vdmVybGFwc1JheShuKSl7aWYodC5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihyLGEsITEpLHYucG9pbnRUb1dvcmxkRnJhbWUocyxlLHQucGlsbGFyT2Zmc2V0LGF0KSx0aGlzLl9pbnRlcnNlY3RDb252ZXgodC5waWxsYXJDb252ZXgsZSxhdCxpLG8scnQpLHRoaXMucmVzdWx0LnNob3VsZFN0b3ApcmV0dXJuO3QuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIocixhLCEwKSx2LnBvaW50VG9Xb3JsZEZyYW1lKHMsZSx0LnBpbGxhck9mZnNldCxhdCksdGhpcy5faW50ZXJzZWN0Q29udmV4KHQucGlsbGFyQ29udmV4LGUsYXQsaSxvLHJ0KX19fV9pbnRlcnNlY3RTcGhlcmUodCxlLHMsaSxvKXtjb25zdCBuPXRoaXMuZnJvbSxyPXRoaXMudG8sYT10LnJhZGl1cyxsPShyLngtbi54KSoqMisoci55LW4ueSkqKjIrKHIuei1uLnopKioyLGg9MiooKHIueC1uLngpKihuLngtcy54KSsoci55LW4ueSkqKG4ueS1zLnkpKyhyLnotbi56KSoobi56LXMueikpLGM9aCoqMi00KmwqKChuLngtcy54KSoqMisobi55LXMueSkqKjIrKG4uei1zLnopKioyLWEqKjIpLHU9Y3QsZD11dDtpZighKGM8MCkpaWYoMD09PWMpbi5sZXJwKHIsYyx1KSx1LnZzdWIocyxkKSxkLm5vcm1hbGl6ZSgpLHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKGQsdSxvLGksLTEpO2Vsc2V7Y29uc3QgdD0oLWgtTWF0aC5zcXJ0KGMpKS8oMipsKSxlPSgtaCtNYXRoLnNxcnQoYykpLygyKmwpO2lmKHQ+PTAmJnQ8PTEmJihuLmxlcnAocix0LHUpLHUudnN1YihzLGQpLGQubm9ybWFsaXplKCksdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24oZCx1LG8saSwtMSkpLHRoaXMucmVzdWx0LnNob3VsZFN0b3ApcmV0dXJuO2U+PTAmJmU8PTEmJihuLmxlcnAocixlLHUpLHUudnN1YihzLGQpLGQubm9ybWFsaXplKCksdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24oZCx1LG8saSwtMSkpfX1faW50ZXJzZWN0Q29udmV4KHQsZSxzLGksbyxuKXtjb25zdCByPWR0LGE9cHQsbD1uJiZuLmZhY2VMaXN0fHxudWxsLGg9dC5mYWNlcyxjPXQudmVydGljZXMsdT10LmZhY2VOb3JtYWxzLGQ9dGhpcy5kaXJlY3Rpb24scD10aGlzLmZyb20seT10aGlzLnRvLG09cC5kaXN0YW5jZVRvKHkpLHY9bD9sLmxlbmd0aDpoLmxlbmd0aCx3PXRoaXMucmVzdWx0O2ZvcihsZXQgdD0wOyF3LnNob3VsZFN0b3AmJnQ8djt0Kyspe2NvbnN0IG49bD9sW3RdOnQseT1oW25dLHY9dVtuXSxmPWUseD1zO2EuY29weShjW3lbMF1dKSxmLnZtdWx0KGEsYSksYS52YWRkKHgsYSksYS52c3ViKHAsYSksZi52bXVsdCh2LHIpO2NvbnN0IGc9ZC5kb3Qocik7aWYoTWF0aC5hYnMoZyk8dGhpcy5wcmVjaXNpb24pY29udGludWU7Y29uc3QgYj1yLmRvdChhKS9nO2lmKCEoYjwwKSl7ZC5tdWx0KGIsc3QpLHN0LnZhZGQocCxzdCksaXQuY29weShjW3lbMF1dKSxmLnZtdWx0KGl0LGl0KSx4LnZhZGQoaXQsaXQpO2ZvcihsZXQgdD0xOyF3LnNob3VsZFN0b3AmJnQ8eS5sZW5ndGgtMTt0Kyspe290LmNvcHkoY1t5W3RdXSksbnQuY29weShjW3lbdCsxXV0pLGYudm11bHQob3Qsb3QpLGYudm11bHQobnQsbnQpLHgudmFkZChvdCxvdCkseC52YWRkKG50LG50KTtjb25zdCBlPXN0LmRpc3RhbmNlVG8ocCk7ISQoc3QsaXQsb3QsbnQpJiYhJChzdCxvdCxpdCxudCl8fGU+bXx8dGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24ocixzdCxvLGksbil9fX19X2ludGVyc2VjdFRyaW1lc2godCxlLHMsaSxvLG4pe2NvbnN0IHI9eXQsYT1ndCxsPWJ0LGg9cHQsYz1tdCx1PXZ0LGQ9d3QscD14dCx5PWZ0LG09KG4mJm4uZmFjZUxpc3QsdC5pbmRpY2VzKSx3PSh0LnZlcnRpY2VzLHRoaXMuZnJvbSksZj10aGlzLnRvLHg9dGhpcy5kaXJlY3Rpb247bC5wb3NpdGlvbi5jb3B5KHMpLGwucXVhdGVybmlvbi5jb3B5KGUpLHYudmVjdG9yVG9Mb2NhbEZyYW1lKHMsZSx4LGMpLHYucG9pbnRUb0xvY2FsRnJhbWUocyxlLHcsdSksdi5wb2ludFRvTG9jYWxGcmFtZShzLGUsZixkKSxkLngqPXQuc2NhbGUueCxkLnkqPXQuc2NhbGUueSxkLnoqPXQuc2NhbGUueix1LngqPXQuc2NhbGUueCx1LnkqPXQuc2NhbGUueSx1LnoqPXQuc2NhbGUueixkLnZzdWIodSxjKSxjLm5vcm1hbGl6ZSgpO2NvbnN0IGc9dS5kaXN0YW5jZVNxdWFyZWQoZCk7dC50cmVlLnJheVF1ZXJ5KHRoaXMsbCxhKTtmb3IobGV0IG49MCxsPWEubGVuZ3RoOyF0aGlzLnJlc3VsdC5zaG91bGRTdG9wJiZuIT09bDtuKyspe2NvbnN0IGw9YVtuXTt0LmdldE5vcm1hbChsLHIpLHQuZ2V0VmVydGV4KG1bMypsXSxpdCksaXQudnN1Yih1LGgpO2NvbnN0IGQ9Yy5kb3Qociksdz1yLmRvdChoKS9kO2lmKHc8MCljb250aW51ZTtjLnNjYWxlKHcsc3QpLHN0LnZhZGQodSxzdCksdC5nZXRWZXJ0ZXgobVszKmwrMV0sb3QpLHQuZ2V0VmVydGV4KG1bMypsKzJdLG50KTtjb25zdCBmPXN0LmRpc3RhbmNlU3F1YXJlZCh1KTshJChzdCxvdCxpdCxudCkmJiEkKHN0LGl0LG90LG50KXx8Zj5nfHwodi52ZWN0b3JUb1dvcmxkRnJhbWUoZSxyLHkpLHYucG9pbnRUb1dvcmxkRnJhbWUocyxlLHN0LHApLHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHkscCxvLGksbCkpfWEubGVuZ3RoPTB9cmVwb3J0SW50ZXJzZWN0aW9uKHQsZSxzLGksbyl7Y29uc3Qgbj10aGlzLmZyb20scj10aGlzLnRvLGE9bi5kaXN0YW5jZVRvKGUpLGw9dGhpcy5yZXN1bHQ7aWYoISh0aGlzLnNraXBCYWNrZmFjZXMmJnQuZG90KHRoaXMuZGlyZWN0aW9uKT4wKSlzd2l0Y2gobC5oaXRGYWNlSW5kZXg9dm9pZCAwIT09bz9vOi0xLHRoaXMubW9kZSl7Y2FzZSBZLkFMTDp0aGlzLmhhc0hpdD0hMCxsLnNldChuLHIsdCxlLHMsaSxhKSxsLmhhc0hpdD0hMCx0aGlzLmNhbGxiYWNrKGwpO2JyZWFrO2Nhc2UgWS5DTE9TRVNUOihhPGwuZGlzdGFuY2V8fCFsLmhhc0hpdCkmJih0aGlzLmhhc0hpdD0hMCxsLmhhc0hpdD0hMCxsLnNldChuLHIsdCxlLHMsaSxhKSk7YnJlYWs7Y2FzZSBZLkFOWTp0aGlzLmhhc0hpdD0hMCxsLmhhc0hpdD0hMCxsLnNldChuLHIsdCxlLHMsaSxhKSxsLnNob3VsZFN0b3A9ITB9fX1ZLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1ZLFkuQ0xPU0VTVD0xLFkuQU5ZPTIsWS5BTEw9NDtjb25zdCBaPW5ldyBhLEs9W10sUT1uZXcgaSxKPW5ldyBpO2Z1bmN0aW9uICQodCxlLHMsaSl7aS52c3ViKGUsQXQpLHMudnN1YihlLFEpLHQudnN1YihlLEopO2NvbnN0IG89QXQuZG90KEF0KSxuPUF0LmRvdChRKSxyPUF0LmRvdChKKSxhPVEuZG90KFEpLGw9US5kb3QoSik7bGV0IGgsYztyZXR1cm4oaD1hKnItbipsKT49MCYmKGM9bypsLW4qcik+PTAmJmgrYzxvKmEtbipufVkucG9pbnRJblRyaWFuZ2xlPSQ7Y29uc3QgdHQ9bmV3IGksZXQ9bmV3IGQsc3Q9bmV3IGksaXQ9bmV3IGksb3Q9bmV3IGksbnQ9bmV3IGk7WS5wcm90b3R5cGVbbS50eXBlcy5CT1hdPVkucHJvdG90eXBlLl9pbnRlcnNlY3RCb3gsWS5wcm90b3R5cGVbbS50eXBlcy5QTEFORV09WS5wcm90b3R5cGUuX2ludGVyc2VjdFBsYW5lO2NvbnN0IHJ0PXtmYWNlTGlzdDpbMF19LGF0PW5ldyBpLGx0PW5ldyBZLGh0PVtdO1kucHJvdG90eXBlW20udHlwZXMuSEVJR0hURklFTERdPVkucHJvdG90eXBlLl9pbnRlcnNlY3RIZWlnaHRmaWVsZDtjb25zdCBjdD1uZXcgaSx1dD1uZXcgaTtZLnByb3RvdHlwZVttLnR5cGVzLlNQSEVSRV09WS5wcm90b3R5cGUuX2ludGVyc2VjdFNwaGVyZTtjb25zdCBkdD1uZXcgaSxwdD1uZXcgaTtZLnByb3RvdHlwZVttLnR5cGVzLkNPTlZFWFBPTFlIRURST05dPVkucHJvdG90eXBlLl9pbnRlcnNlY3RDb252ZXg7Y29uc3QgeXQ9bmV3IGksbXQ9bmV3IGksdnQ9bmV3IGksd3Q9bmV3IGksZnQ9bmV3IGkseHQ9bmV3IGksZ3Q9KG5ldyBhLFtdKSxidD1uZXcgdjtZLnByb3RvdHlwZVttLnR5cGVzLlRSSU1FU0hdPVkucHJvdG90eXBlLl9pbnRlcnNlY3RUcmltZXNoO2NvbnN0IEF0PW5ldyBpLEJ0PW5ldyBpO2NsYXNzIEV0IGV4dGVuZHMgT3tjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuYXhpc0xpc3Q9W10sdGhpcy53b3JsZD1udWxsLHRoaXMuYXhpc0luZGV4PTA7Y29uc3QgZT10aGlzLmF4aXNMaXN0O3RoaXMuX2FkZEJvZHlIYW5kbGVyPXQ9PntlLnB1c2godC5ib2R5KX0sdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXI9dD0+e2NvbnN0IHM9ZS5pbmRleE9mKHQuYm9keSk7LTEhPT1zJiZlLnNwbGljZShzLDEpfSx0JiZ0aGlzLnNldFdvcmxkKHQpfXNldFdvcmxkKHQpe3RoaXMuYXhpc0xpc3QubGVuZ3RoPTA7Zm9yKGxldCBlPTA7ZTx0LmJvZGllcy5sZW5ndGg7ZSsrKXRoaXMuYXhpc0xpc3QucHVzaCh0LmJvZGllc1tlXSk7dC5yZW1vdmVFdmVudExpc3RlbmVyKCJhZGRCb2R5Iix0aGlzLl9hZGRCb2R5SGFuZGxlciksdC5yZW1vdmVFdmVudExpc3RlbmVyKCJyZW1vdmVCb2R5Iix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciksdC5hZGRFdmVudExpc3RlbmVyKCJhZGRCb2R5Iix0aGlzLl9hZGRCb2R5SGFuZGxlciksdC5hZGRFdmVudExpc3RlbmVyKCJyZW1vdmVCb2R5Iix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciksdGhpcy53b3JsZD10LHRoaXMuZGlydHk9ITB9Y29sbGlzaW9uUGFpcnModCxlLHMpe2NvbnN0IGk9dGhpcy5heGlzTGlzdCxvPWkubGVuZ3RoLG49dGhpcy5heGlzSW5kZXg7bGV0IHIsYTtmb3IodGhpcy5kaXJ0eSYmKHRoaXMuc29ydExpc3QoKSx0aGlzLmRpcnR5PSExKSxyPTA7ciE9PW87cisrKXtjb25zdCB0PWlbcl07Zm9yKGE9cisxO2E8bzthKyspe2NvbnN0IG89aVthXTtpZih0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKHQsbykpe2lmKCFFdC5jaGVja0JvdW5kcyh0LG8sbikpYnJlYWs7dGhpcy5pbnRlcnNlY3Rpb25UZXN0KHQsbyxlLHMpfX19fXNvcnRMaXN0KCl7Y29uc3QgdD10aGlzLmF4aXNMaXN0LGU9dGhpcy5heGlzSW5kZXgscz10Lmxlbmd0aDtmb3IobGV0IGU9MDtlIT09cztlKyspe2NvbnN0IHM9dFtlXTtzLmFhYmJOZWVkc1VwZGF0ZSYmcy5jb21wdXRlQUFCQigpfTA9PT1lP0V0Lmluc2VydGlvblNvcnRYKHQpOjE9PT1lP0V0Lmluc2VydGlvblNvcnRZKHQpOjI9PT1lJiZFdC5pbnNlcnRpb25Tb3J0Wih0KX1hdXRvRGV0ZWN0QXhpcygpe2xldCB0PTAsZT0wLHM9MCxpPTAsbz0wLG49MDtjb25zdCByPXRoaXMuYXhpc0xpc3QsYT1yLmxlbmd0aCxsPTEvYTtmb3IobGV0IGw9MDtsIT09YTtsKyspe2NvbnN0IGE9cltsXSxoPWEucG9zaXRpb24ueDt0Kz1oLGUrPWgqaDtjb25zdCBjPWEucG9zaXRpb24ueTtzKz1jLGkrPWMqYztjb25zdCB1PWEucG9zaXRpb24uejtvKz11LG4rPXUqdX1jb25zdCBoPWUtdCp0KmwsYz1pLXMqcypsLHU9bi1vKm8qbDt0aGlzLmF4aXNJbmRleD1oPmM/aD51PzA6MjpjPnU/MToyfWFhYmJRdWVyeSh0LGUscz1bXSl7dGhpcy5kaXJ0eSYmKHRoaXMuc29ydExpc3QoKSx0aGlzLmRpcnR5PSExKTtjb25zdCBpPXRoaXMuYXhpc0luZGV4O2xldCBvPSJ4IjsxPT09aSYmKG89InkiKSwyPT09aSYmKG89InoiKTtjb25zdCBuPXRoaXMuYXhpc0xpc3Q7ZS5sb3dlckJvdW5kW29dLGUudXBwZXJCb3VuZFtvXTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgaT1uW3RdO2kuYWFiYk5lZWRzVXBkYXRlJiZpLmNvbXB1dGVBQUJCKCksaS5hYWJiLm92ZXJsYXBzKGUpJiZzLnB1c2goaSl9cmV0dXJuIHN9fWZ1bmN0aW9uIHp0KCl7fUV0Lmluc2VydGlvblNvcnRYPXQ9Pntmb3IobGV0IGU9MSxzPXQubGVuZ3RoO2U8cztlKyspe2NvbnN0IHM9dFtlXTtsZXQgaTtmb3IoaT1lLTE7aT49MCYmISh0W2ldLmFhYmIubG93ZXJCb3VuZC54PD1zLmFhYmIubG93ZXJCb3VuZC54KTtpLS0pdFtpKzFdPXRbaV07dFtpKzFdPXN9cmV0dXJuIHR9LEV0Lmluc2VydGlvblNvcnRZPXQ9Pntmb3IobGV0IGU9MSxzPXQubGVuZ3RoO2U8cztlKyspe2NvbnN0IHM9dFtlXTtsZXQgaTtmb3IoaT1lLTE7aT49MCYmISh0W2ldLmFhYmIubG93ZXJCb3VuZC55PD1zLmFhYmIubG93ZXJCb3VuZC55KTtpLS0pdFtpKzFdPXRbaV07dFtpKzFdPXN9cmV0dXJuIHR9LEV0Lmluc2VydGlvblNvcnRaPXQ9Pntmb3IobGV0IGU9MSxzPXQubGVuZ3RoO2U8cztlKyspe2NvbnN0IHM9dFtlXTtsZXQgaTtmb3IoaT1lLTE7aT49MCYmISh0W2ldLmFhYmIubG93ZXJCb3VuZC56PD1zLmFhYmIubG93ZXJCb3VuZC56KTtpLS0pdFtpKzFdPXRbaV07dFtpKzFdPXN9cmV0dXJuIHR9LEV0LmNoZWNrQm91bmRzPSh0LGUscyk9PntsZXQgaSxvOzA9PT1zPyhpPXQucG9zaXRpb24ueCxvPWUucG9zaXRpb24ueCk6MT09PXM/KGk9dC5wb3NpdGlvbi55LG89ZS5wb3NpdGlvbi55KToyPT09cyYmKGk9dC5wb3NpdGlvbi56LG89ZS5wb3NpdGlvbi56KTtjb25zdCBuPXQuYm91bmRpbmdSYWRpdXM7cmV0dXJuIG8tZS5ib3VuZGluZ1JhZGl1czxpK259LHp0LmRlZmF1bHRzPSh0PXt9LGUpPT57Zm9yKGxldCBzIGluIGUpcyBpbiB0fHwodFtzXT1lW3NdKTtyZXR1cm4gdH07Y2xhc3MgRnR7Y29uc3RydWN0b3IodCxlLHM9e30pe3M9enQuZGVmYXVsdHMocyx7Y29sbGlkZUNvbm5lY3RlZDohMCx3YWtlVXBCb2RpZXM6ITB9KSx0aGlzLmVxdWF0aW9ucz1bXSx0aGlzLmJvZHlBPXQsdGhpcy5ib2R5Qj1lLHRoaXMuaWQ9RnQuaWRDb3VudGVyKyssdGhpcy5jb2xsaWRlQ29ubmVjdGVkPXMuY29sbGlkZUNvbm5lY3RlZCxzLndha2VVcEJvZGllcyYmKHQmJnQud2FrZVVwKCksZSYmZS53YWtlVXAoKSl9dXBkYXRlKCl7dGhyb3cgbmV3IEVycm9yKCJtZXRob2QgdXBkYXRlKCkgbm90IGltcGxtZW1lbnRlZCBpbiB0aGlzIENvbnN0cmFpbnQgc3ViY2xhc3MhIil9ZW5hYmxlKCl7Y29uc3QgdD10aGlzLmVxdWF0aW9ucztmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdLmVuYWJsZWQ9ITB9ZGlzYWJsZSgpe2NvbnN0IHQ9dGhpcy5lcXVhdGlvbnM7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXS5lbmFibGVkPSExfX1GdC5pZENvdW50ZXI9MDtjbGFzcyBTdHtjb25zdHJ1Y3Rvcigpe3RoaXMuc3BhdGlhbD1uZXcgaSx0aGlzLnJvdGF0aW9uYWw9bmV3IGl9bXVsdGlwbHlFbGVtZW50KHQpe3JldHVybiB0LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkrdC5yb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpfW11bHRpcGx5VmVjdG9ycyh0LGUpe3JldHVybiB0LmRvdCh0aGlzLnNwYXRpYWwpK2UuZG90KHRoaXMucm90YXRpb25hbCl9fWNsYXNzIE10e2NvbnN0cnVjdG9yKHQsZSxzPS0xZTYsaT0xZTYpe3RoaXMuaWQ9TXQuaWQrKyx0aGlzLm1pbkZvcmNlPXMsdGhpcy5tYXhGb3JjZT1pLHRoaXMuYmk9dCx0aGlzLmJqPWUsdGhpcy5hPTAsdGhpcy5iPTAsdGhpcy5lcHM9MCx0aGlzLmphY29iaWFuRWxlbWVudEE9bmV3IFN0LHRoaXMuamFjb2JpYW5FbGVtZW50Qj1uZXcgU3QsdGhpcy5lbmFibGVkPSEwLHRoaXMubXVsdGlwbGllcj0wLHRoaXMuc2V0U3Bvb2tQYXJhbXMoMWU3LDQsMS82MCl9c2V0U3Bvb2tQYXJhbXModCxlLHMpe2NvbnN0IGk9ZSxvPXQsbj1zO3RoaXMuYT00LyhuKigxKzQqaSkpLHRoaXMuYj00KmkvKDErNCppKSx0aGlzLmVwcz00LyhuKm4qbyooMSs0KmkpKX1jb21wdXRlQih0LGUscyl7Y29uc3QgaT10aGlzLmNvbXB1dGVHVygpO3JldHVybi10aGlzLmNvbXB1dGVHcSgpKnQtaSplLXRoaXMuY29tcHV0ZUdpTWYoKSpzfWNvbXB1dGVHcSgpe2NvbnN0IHQ9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLHM9dGhpcy5iaSxpPXRoaXMuYmosbz1zLnBvc2l0aW9uLG49aS5wb3NpdGlvbjtyZXR1cm4gdC5zcGF0aWFsLmRvdChvKStlLnNwYXRpYWwuZG90KG4pfWNvbXB1dGVHVygpe2NvbnN0IHQ9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLHM9dGhpcy5iaSxpPXRoaXMuYmosbz1zLnZlbG9jaXR5LG49aS52ZWxvY2l0eSxyPXMuYW5ndWxhclZlbG9jaXR5LGE9aS5hbmd1bGFyVmVsb2NpdHk7cmV0dXJuIHQubXVsdGlwbHlWZWN0b3JzKG8scikrZS5tdWx0aXBseVZlY3RvcnMobixhKX1jb21wdXRlR1dsYW1iZGEoKXtjb25zdCB0PXRoaXMuamFjb2JpYW5FbGVtZW50QSxlPXRoaXMuamFjb2JpYW5FbGVtZW50QixzPXRoaXMuYmksaT10aGlzLmJqLG89cy52bGFtYmRhLG49aS52bGFtYmRhLHI9cy53bGFtYmRhLGE9aS53bGFtYmRhO3JldHVybiB0Lm11bHRpcGx5VmVjdG9ycyhvLHIpK2UubXVsdGlwbHlWZWN0b3JzKG4sYSl9Y29tcHV0ZUdpTWYoKXtjb25zdCB0PXRoaXMuamFjb2JpYW5FbGVtZW50QSxlPXRoaXMuamFjb2JpYW5FbGVtZW50QixzPXRoaXMuYmksaT10aGlzLmJqLG89cy5mb3JjZSxuPXMudG9ycXVlLHI9aS5mb3JjZSxhPWkudG9ycXVlLGw9cy5pbnZNYXNzU29sdmUsaD1pLmludk1hc3NTb2x2ZTtyZXR1cm4gby5zY2FsZShsLEN0KSxyLnNjYWxlKGgscXQpLHMuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQobixUdCksaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChhLFB0KSx0Lm11bHRpcGx5VmVjdG9ycyhDdCxUdCkrZS5tdWx0aXBseVZlY3RvcnMocXQsUHQpfWNvbXB1dGVHaU1HdCgpe2NvbnN0IHQ9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLHM9dGhpcy5iaSxpPXRoaXMuYmosbz1zLmludk1hc3NTb2x2ZSxuPWkuaW52TWFzc1NvbHZlLHI9cy5pbnZJbmVydGlhV29ybGRTb2x2ZSxhPWkuaW52SW5lcnRpYVdvcmxkU29sdmU7bGV0IGw9bytuO3JldHVybiByLnZtdWx0KHQucm90YXRpb25hbCxOdCksbCs9TnQuZG90KHQucm90YXRpb25hbCksYS52bXVsdChlLnJvdGF0aW9uYWwsTnQpLGwrPU50LmRvdChlLnJvdGF0aW9uYWwpLGx9YWRkVG9XbGFtYmRhKHQpe2NvbnN0IGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLHM9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLGk9dGhpcy5iaSxvPXRoaXMuYmosbj1SdDtpLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGkuaW52TWFzc1NvbHZlKnQsZS5zcGF0aWFsLGkudmxhbWJkYSksby52bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihvLmludk1hc3NTb2x2ZSp0LHMuc3BhdGlhbCxvLnZsYW1iZGEpLGkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoZS5yb3RhdGlvbmFsLG4pLGkud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IodCxuLGkud2xhbWJkYSksby5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChzLnJvdGF0aW9uYWwsbiksby53bGFtYmRhLmFkZFNjYWxlZFZlY3Rvcih0LG4sby53bGFtYmRhKX1jb21wdXRlQygpe3JldHVybiB0aGlzLmNvbXB1dGVHaU1HdCgpK3RoaXMuZXBzfX1NdC5pZD0wO2NvbnN0IEN0PW5ldyBpLHF0PW5ldyBpLFR0PW5ldyBpLFB0PW5ldyBpLE50PW5ldyBpLFJ0PW5ldyBpO2NsYXNzIEl0IGV4dGVuZHMgTXR7Y29uc3RydWN0b3IodCxlLHM9MWU2KXtzdXBlcih0LGUsMCxzKSx0aGlzLnJlc3RpdHV0aW9uPTAsdGhpcy5yaT1uZXcgaSx0aGlzLnJqPW5ldyBpLHRoaXMubmk9bmV3IGl9Y29tcHV0ZUIodCl7Y29uc3QgZT10aGlzLmEscz10aGlzLmIsaT10aGlzLmJpLG89dGhpcy5iaixuPXRoaXMucmkscj10aGlzLnJqLGE9THQsbD1qdCxoPWkudmVsb2NpdHksYz1pLmFuZ3VsYXJWZWxvY2l0eSx1PShpLmZvcmNlLGkudG9ycXVlLG8udmVsb2NpdHkpLGQ9by5hbmd1bGFyVmVsb2NpdHkscD0oby5mb3JjZSxvLnRvcnF1ZSxWdCkseT10aGlzLmphY29iaWFuRWxlbWVudEEsbT10aGlzLmphY29iaWFuRWxlbWVudEIsdj10aGlzLm5pO24uY3Jvc3ModixhKSxyLmNyb3NzKHYsbCksdi5uZWdhdGUoeS5zcGF0aWFsKSxhLm5lZ2F0ZSh5LnJvdGF0aW9uYWwpLG0uc3BhdGlhbC5jb3B5KHYpLG0ucm90YXRpb25hbC5jb3B5KGwpLHAuY29weShvLnBvc2l0aW9uKSxwLnZhZGQocixwKSxwLnZzdWIoaS5wb3NpdGlvbixwKSxwLnZzdWIobixwKTtjb25zdCB3PXYuZG90KHApLGY9dGhpcy5yZXN0aXR1dGlvbisxO3JldHVybi13KmUtKGYqdS5kb3QodiktZipoLmRvdCh2KStkLmRvdChsKS1jLmRvdChhKSkqcy10KnRoaXMuY29tcHV0ZUdpTWYoKX1nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsKCl7Y29uc3QgdD1rdCxlPVd0LHM9T3QsaT1fdCxvPUh0O3JldHVybiB0aGlzLmJpLnBvc2l0aW9uLnZhZGQodGhpcy5yaSxzKSx0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaixpKSx0aGlzLmJpLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHMsdCksdGhpcy5iai5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChpLGUpLHQudnN1YihlLG8pLHRoaXMubmkuZG90KG8pfX1jb25zdCBMdD1uZXcgaSxqdD1uZXcgaSxWdD1uZXcgaSxrdD1uZXcgaSxXdD1uZXcgaSxPdD1uZXcgaSxfdD1uZXcgaSxIdD1uZXcgaTtjbGFzcyBVdCBleHRlbmRzIEZ0e2NvbnN0cnVjdG9yKHQsZT1uZXcgaSxzLG89bmV3IGksbj0xZTYpe3N1cGVyKHQscyksdGhpcy5waXZvdEE9ZS5jbG9uZSgpLHRoaXMucGl2b3RCPW8uY2xvbmUoKTtjb25zdCByPXRoaXMuZXF1YXRpb25YPW5ldyBJdCh0LHMpLGE9dGhpcy5lcXVhdGlvblk9bmV3IEl0KHQscyksbD10aGlzLmVxdWF0aW9uWj1uZXcgSXQodCxzKTt0aGlzLmVxdWF0aW9ucy5wdXNoKHIsYSxsKSxyLm1pbkZvcmNlPWEubWluRm9yY2U9bC5taW5Gb3JjZT0tbixyLm1heEZvcmNlPWEubWF4Rm9yY2U9bC5tYXhGb3JjZT1uLHIubmkuc2V0KDEsMCwwKSxhLm5pLnNldCgwLDEsMCksbC5uaS5zZXQoMCwwLDEpfXVwZGF0ZSgpe2NvbnN0IHQ9dGhpcy5ib2R5QSxlPXRoaXMuYm9keUIscz10aGlzLmVxdWF0aW9uWCxpPXRoaXMuZXF1YXRpb25ZLG89dGhpcy5lcXVhdGlvblo7dC5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLHMucmkpLGUucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QixzLnJqKSxpLnJpLmNvcHkocy5yaSksaS5yai5jb3B5KHMucmopLG8ucmkuY29weShzLnJpKSxvLnJqLmNvcHkocy5yail9fWNsYXNzIEd0IGV4dGVuZHMgTXR7Y29uc3RydWN0b3IodCxlLHM9e30pe2NvbnN0IG89dm9pZCAwIT09cy5tYXhGb3JjZT9zLm1heEZvcmNlOjFlNjtzdXBlcih0LGUsLW8sbyksdGhpcy5heGlzQT1zLmF4aXNBP3MuYXhpc0EuY2xvbmUoKTpuZXcgaSgxLDAsMCksdGhpcy5heGlzQj1zLmF4aXNCP3MuYXhpc0IuY2xvbmUoKTpuZXcgaSgwLDEsMCksdGhpcy5hbmdsZT12b2lkIDAhPT1zLmFuZ2xlP3MuYW5nbGU6MH1jb21wdXRlQih0KXtjb25zdCBlPXRoaXMuYSxzPXRoaXMuYixpPXRoaXMuYXhpc0Esbz10aGlzLmF4aXNCLG49RHQscj1YdCxhPXRoaXMuamFjb2JpYW5FbGVtZW50QSxsPXRoaXMuamFjb2JpYW5FbGVtZW50QjtyZXR1cm4gaS5jcm9zcyhvLG4pLG8uY3Jvc3MoaSxyKSxhLnJvdGF0aW9uYWwuY29weShyKSxsLnJvdGF0aW9uYWwuY29weShuKSwtKE1hdGguY29zKHRoaXMuYW5nbGUpLWkuZG90KG8pKSplLXRoaXMuY29tcHV0ZUdXKCkqcy10KnRoaXMuY29tcHV0ZUdpTWYoKX19Y29uc3QgRHQ9bmV3IGksWHQ9bmV3IGk7Y2xhc3MgWXQgZXh0ZW5kcyBNdHtjb25zdHJ1Y3Rvcih0LGUscz17fSl7Y29uc3Qgbz12b2lkIDAhPT1zLm1heEZvcmNlP3MubWF4Rm9yY2U6MWU2O3N1cGVyKHQsZSwtbyxvKSx0aGlzLmF4aXNBPXMuYXhpc0E/cy5heGlzQS5jbG9uZSgpOm5ldyBpKDEsMCwwKSx0aGlzLmF4aXNCPXMuYXhpc0I/cy5heGlzQi5jbG9uZSgpOm5ldyBpKDAsMSwwKSx0aGlzLm1heEFuZ2xlPU1hdGguUEkvMn1jb21wdXRlQih0KXtjb25zdCBlPXRoaXMuYSxzPXRoaXMuYixpPXRoaXMuYXhpc0Esbz10aGlzLmF4aXNCLG49WnQscj1LdCxhPXRoaXMuamFjb2JpYW5FbGVtZW50QSxsPXRoaXMuamFjb2JpYW5FbGVtZW50QjtyZXR1cm4gaS5jcm9zcyhvLG4pLG8uY3Jvc3MoaSxyKSxhLnJvdGF0aW9uYWwuY29weShyKSxsLnJvdGF0aW9uYWwuY29weShuKSwtKE1hdGguY29zKHRoaXMubWF4QW5nbGUpLWkuZG90KG8pKSplLXRoaXMuY29tcHV0ZUdXKCkqcy10KnRoaXMuY29tcHV0ZUdpTWYoKX19Y29uc3QgWnQ9bmV3IGksS3Q9bmV3IGk7Y2xhc3MgUXQgZXh0ZW5kcyBVdHtjb25zdHJ1Y3Rvcih0LGUscz17fSl7Y29uc3Qgbz12b2lkIDAhPT1zLm1heEZvcmNlP3MubWF4Rm9yY2U6MWU2O3N1cGVyKHQscy5waXZvdEE/cy5waXZvdEEuY2xvbmUoKTpuZXcgaSxlLHMucGl2b3RCP3MucGl2b3RCLmNsb25lKCk6bmV3IGksbyksdGhpcy5heGlzQT1zLmF4aXNBP3MuYXhpc0EuY2xvbmUoKTpuZXcgaSx0aGlzLmF4aXNCPXMuYXhpc0I/cy5heGlzQi5jbG9uZSgpOm5ldyBpLHRoaXMuY29sbGlkZUNvbm5lY3RlZD0hIXMuY29sbGlkZUNvbm5lY3RlZCx0aGlzLmFuZ2xlPXZvaWQgMCE9PXMuYW5nbGU/cy5hbmdsZTowO2NvbnN0IG49dGhpcy5jb25lRXF1YXRpb249bmV3IEd0KHQsZSxzKSxyPXRoaXMudHdpc3RFcXVhdGlvbj1uZXcgWXQodCxlLHMpO3RoaXMudHdpc3RBbmdsZT12b2lkIDAhPT1zLnR3aXN0QW5nbGU/cy50d2lzdEFuZ2xlOjAsbi5tYXhGb3JjZT0wLG4ubWluRm9yY2U9LW8sci5tYXhGb3JjZT0wLHIubWluRm9yY2U9LW8sdGhpcy5lcXVhdGlvbnMucHVzaChuLHIpfXVwZGF0ZSgpe2NvbnN0IHQ9dGhpcy5ib2R5QSxlPXRoaXMuYm9keUIscz10aGlzLmNvbmVFcXVhdGlvbixpPXRoaXMudHdpc3RFcXVhdGlvbjtzdXBlci51cGRhdGUoKSx0LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNBLHMuYXhpc0EpLGUudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0Iscy5heGlzQiksdGhpcy5heGlzQS50YW5nZW50cyhpLmF4aXNBLGkuYXhpc0EpLHQudmVjdG9yVG9Xb3JsZEZyYW1lKGkuYXhpc0EsaS5heGlzQSksdGhpcy5heGlzQi50YW5nZW50cyhpLmF4aXNCLGkuYXhpc0IpLGUudmVjdG9yVG9Xb3JsZEZyYW1lKGkuYXhpc0IsaS5heGlzQikscy5hbmdsZT10aGlzLmFuZ2xlLGkubWF4QW5nbGU9dGhpcy50d2lzdEFuZ2xlfX1jbGFzcyBKdCBleHRlbmRzIEZ0e2NvbnN0cnVjdG9yKHQsZSxzLGk9MWU2KXtzdXBlcih0LGUpLHZvaWQgMD09PXMmJihzPXQucG9zaXRpb24uZGlzdGFuY2VUbyhlLnBvc2l0aW9uKSksdGhpcy5kaXN0YW5jZT1zO2NvbnN0IG89dGhpcy5kaXN0YW5jZUVxdWF0aW9uPW5ldyBJdCh0LGUpO3RoaXMuZXF1YXRpb25zLnB1c2gobyksby5taW5Gb3JjZT0taSxvLm1heEZvcmNlPWl9dXBkYXRlKCl7Y29uc3QgdD10aGlzLmJvZHlBLGU9dGhpcy5ib2R5QixzPXRoaXMuZGlzdGFuY2VFcXVhdGlvbixpPS41KnRoaXMuZGlzdGFuY2Usbz1zLm5pO2UucG9zaXRpb24udnN1Yih0LnBvc2l0aW9uLG8pLG8ubm9ybWFsaXplKCksby5tdWx0KGkscy5yaSksby5tdWx0KC1pLHMucmopfX1jbGFzcyAkdCBleHRlbmRzIFV0e2NvbnN0cnVjdG9yKHQsZSxzPXt9KXtjb25zdCBvPXZvaWQgMCE9PXMubWF4Rm9yY2U/cy5tYXhGb3JjZToxZTYsbj1uZXcgaSxyPW5ldyBpLGE9bmV3IGk7dC5wb3NpdGlvbi52YWRkKGUucG9zaXRpb24sYSksYS5zY2FsZSguNSxhKSxlLnBvaW50VG9Mb2NhbEZyYW1lKGEsciksdC5wb2ludFRvTG9jYWxGcmFtZShhLG4pLHN1cGVyKHQsbixlLHIsbyksdGhpcy54QT10LnZlY3RvclRvTG9jYWxGcmFtZShpLlVOSVRfWCksdGhpcy54Qj1lLnZlY3RvclRvTG9jYWxGcmFtZShpLlVOSVRfWCksdGhpcy55QT10LnZlY3RvclRvTG9jYWxGcmFtZShpLlVOSVRfWSksdGhpcy55Qj1lLnZlY3RvclRvTG9jYWxGcmFtZShpLlVOSVRfWSksdGhpcy56QT10LnZlY3RvclRvTG9jYWxGcmFtZShpLlVOSVRfWiksdGhpcy56Qj1lLnZlY3RvclRvTG9jYWxGcmFtZShpLlVOSVRfWik7Y29uc3QgbD10aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjE9bmV3IFl0KHQsZSxzKSxoPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMj1uZXcgWXQodCxlLHMpLGM9dGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zPW5ldyBZdCh0LGUscyk7dGhpcy5lcXVhdGlvbnMucHVzaChsLGgsYyl9dXBkYXRlKCl7Y29uc3QgdD10aGlzLmJvZHlBLGU9dGhpcy5ib2R5QixzPSh0aGlzLm1vdG9yRXF1YXRpb24sdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xKSxpPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMixvPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMztzdXBlci51cGRhdGUoKSx0LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhBLHMuYXhpc0EpLGUudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMueUIscy5heGlzQiksdC52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QSxpLmF4aXNBKSxlLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnpCLGkuYXhpc0IpLHQudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuekEsby5heGlzQSksZS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QixvLmF4aXNCKX19Y2xhc3MgdGUgZXh0ZW5kcyBNdHtjb25zdHJ1Y3Rvcih0LGUscz0xZTYpe3N1cGVyKHQsZSwtcyxzKSx0aGlzLmF4aXNBPW5ldyBpLHRoaXMuYXhpc0I9bmV3IGksdGhpcy50YXJnZXRWZWxvY2l0eT0wfWNvbXB1dGVCKHQpe3RoaXMuYTtjb25zdCBlPXRoaXMuYixzPSh0aGlzLmJpLHRoaXMuYmosdGhpcy5heGlzQSksaT10aGlzLmF4aXNCLG89dGhpcy5qYWNvYmlhbkVsZW1lbnRBLG49dGhpcy5qYWNvYmlhbkVsZW1lbnRCO3JldHVybiBvLnJvdGF0aW9uYWwuY29weShzKSxpLm5lZ2F0ZShuLnJvdGF0aW9uYWwpLC0odGhpcy5jb21wdXRlR1coKS10aGlzLnRhcmdldFZlbG9jaXR5KSplLXQqdGhpcy5jb21wdXRlR2lNZigpfX1jbGFzcyBlZSBleHRlbmRzIFV0e2NvbnN0cnVjdG9yKHQsZSxzPXt9KXtjb25zdCBvPXZvaWQgMCE9PXMubWF4Rm9yY2U/cy5tYXhGb3JjZToxZTY7c3VwZXIodCxzLnBpdm90QT9zLnBpdm90QS5jbG9uZSgpOm5ldyBpLGUscy5waXZvdEI/cy5waXZvdEIuY2xvbmUoKTpuZXcgaSxvKSwodGhpcy5heGlzQT1zLmF4aXNBP3MuYXhpc0EuY2xvbmUoKTpuZXcgaSgxLDAsMCkpLm5vcm1hbGl6ZSgpLCh0aGlzLmF4aXNCPXMuYXhpc0I/cy5heGlzQi5jbG9uZSgpOm5ldyBpKDEsMCwwKSkubm9ybWFsaXplKCksdGhpcy5jb2xsaWRlQ29ubmVjdGVkPSEhcy5jb2xsaWRlQ29ubmVjdGVkO2NvbnN0IG49dGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xPW5ldyBZdCh0LGUscykscj10aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjI9bmV3IFl0KHQsZSxzKSxhPXRoaXMubW90b3JFcXVhdGlvbj1uZXcgdGUodCxlLG8pO2EuZW5hYmxlZD0hMSx0aGlzLmVxdWF0aW9ucy5wdXNoKG4scixhKX1lbmFibGVNb3Rvcigpe3RoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkPSEwfWRpc2FibGVNb3Rvcigpe3RoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkPSExfXNldE1vdG9yU3BlZWQodCl7dGhpcy5tb3RvckVxdWF0aW9uLnRhcmdldFZlbG9jaXR5PXR9c2V0TW90b3JNYXhGb3JjZSh0KXt0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2U9dCx0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2U9LXR9dXBkYXRlKCl7Y29uc3QgdD10aGlzLmJvZHlBLGU9dGhpcy5ib2R5QixzPXRoaXMubW90b3JFcXVhdGlvbixpPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxvPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMixuPXNlLHI9aWUsYT10aGlzLmF4aXNBLGw9dGhpcy5heGlzQjtzdXBlci51cGRhdGUoKSx0LnF1YXRlcm5pb24udm11bHQoYSxuKSxlLnF1YXRlcm5pb24udm11bHQobCxyKSxuLnRhbmdlbnRzKGkuYXhpc0Esby5heGlzQSksaS5heGlzQi5jb3B5KHIpLG8uYXhpc0IuY29weShyKSx0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCYmKHQucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNBLHMuYXhpc0EpLGUucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNCLHMuYXhpc0IpKX19Y29uc3Qgc2U9bmV3IGksaWU9bmV3IGk7Y2xhc3Mgb2UgZXh0ZW5kcyBNdHtjb25zdHJ1Y3Rvcih0LGUscyl7c3VwZXIodCxlLC1zLHMpLHRoaXMucmk9bmV3IGksdGhpcy5yaj1uZXcgaSx0aGlzLnQ9bmV3IGl9Y29tcHV0ZUIodCl7dGhpcy5hO2NvbnN0IGU9dGhpcy5iLHM9KHRoaXMuYmksdGhpcy5iaix0aGlzLnJpKSxpPXRoaXMucmosbz1uZSxuPXJlLHI9dGhpcy50O3MuY3Jvc3MocixvKSxpLmNyb3NzKHIsbik7Y29uc3QgYT10aGlzLmphY29iaWFuRWxlbWVudEEsbD10aGlzLmphY29iaWFuRWxlbWVudEI7cmV0dXJuIHIubmVnYXRlKGEuc3BhdGlhbCksby5uZWdhdGUoYS5yb3RhdGlvbmFsKSxsLnNwYXRpYWwuY29weShyKSxsLnJvdGF0aW9uYWwuY29weShuKSwtdGhpcy5jb21wdXRlR1coKSplLXQqdGhpcy5jb21wdXRlR2lNZigpfX1jb25zdCBuZT1uZXcgaSxyZT1uZXcgaTtjbGFzcyBhZXtjb25zdHJ1Y3Rvcih0LGUscyl7cz16dC5kZWZhdWx0cyhzLHtmcmljdGlvbjouMyxyZXN0aXR1dGlvbjouMyxjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6MWU3LGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246MyxmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOjFlNyxmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjozfSksdGhpcy5pZD1hZS5pZENvdW50ZXIrKyx0aGlzLm1hdGVyaWFscz1bdCxlXSx0aGlzLmZyaWN0aW9uPXMuZnJpY3Rpb24sdGhpcy5yZXN0aXR1dGlvbj1zLnJlc3RpdHV0aW9uLHRoaXMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPXMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLHRoaXMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbj1zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sdGhpcy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzPXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyx0aGlzLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uPXMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb259fWFlLmlkQ291bnRlcj0wO2NsYXNzIGxle2NvbnN0cnVjdG9yKHQ9e30pe2xldCBlPSIiOyJzdHJpbmciPT10eXBlb2YgdCYmKGU9dCx0PXt9KSx0aGlzLm5hbWU9ZSx0aGlzLmlkPWxlLmlkQ291bnRlcisrLHRoaXMuZnJpY3Rpb249dm9pZCAwIT09dC5mcmljdGlvbj90LmZyaWN0aW9uOi0xLHRoaXMucmVzdGl0dXRpb249dm9pZCAwIT09dC5yZXN0aXR1dGlvbj90LnJlc3RpdHV0aW9uOi0xfX1sZS5pZENvdW50ZXI9MDtjbGFzcyBoZXtjb25zdHJ1Y3Rvcih0LGUscz17fSl7dGhpcy5yZXN0TGVuZ3RoPSJudW1iZXIiPT10eXBlb2Ygcy5yZXN0TGVuZ3RoP3MucmVzdExlbmd0aDoxLHRoaXMuc3RpZmZuZXNzPXMuc3RpZmZuZXNzfHwxMDAsdGhpcy5kYW1waW5nPXMuZGFtcGluZ3x8MSx0aGlzLmJvZHlBPXQsdGhpcy5ib2R5Qj1lLHRoaXMubG9jYWxBbmNob3JBPW5ldyBpLHRoaXMubG9jYWxBbmNob3JCPW5ldyBpLHMubG9jYWxBbmNob3JBJiZ0aGlzLmxvY2FsQW5jaG9yQS5jb3B5KHMubG9jYWxBbmNob3JBKSxzLmxvY2FsQW5jaG9yQiYmdGhpcy5sb2NhbEFuY2hvckIuY29weShzLmxvY2FsQW5jaG9yQikscy53b3JsZEFuY2hvckEmJnRoaXMuc2V0V29ybGRBbmNob3JBKHMud29ybGRBbmNob3JBKSxzLndvcmxkQW5jaG9yQiYmdGhpcy5zZXRXb3JsZEFuY2hvckIocy53b3JsZEFuY2hvckIpfXNldFdvcmxkQW5jaG9yQSh0KXt0aGlzLmJvZHlBLnBvaW50VG9Mb2NhbEZyYW1lKHQsdGhpcy5sb2NhbEFuY2hvckEpfXNldFdvcmxkQW5jaG9yQih0KXt0aGlzLmJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKHQsdGhpcy5sb2NhbEFuY2hvckIpfWdldFdvcmxkQW5jaG9yQSh0KXt0aGlzLmJvZHlBLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLHQpfWdldFdvcmxkQW5jaG9yQih0KXt0aGlzLmJvZHlCLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JCLHQpfWFwcGx5Rm9yY2UoKXtjb25zdCB0PXRoaXMuc3RpZmZuZXNzLGU9dGhpcy5kYW1waW5nLHM9dGhpcy5yZXN0TGVuZ3RoLGk9dGhpcy5ib2R5QSxvPXRoaXMuYm9keUIsbj1jZSxyPXVlLGE9ZGUsbD1wZSxoPWdlLGM9eWUsdT1tZSxkPXZlLHA9d2UseT1mZSxtPXhlO3RoaXMuZ2V0V29ybGRBbmNob3JBKGMpLHRoaXMuZ2V0V29ybGRBbmNob3JCKHUpLGMudnN1YihpLnBvc2l0aW9uLGQpLHUudnN1YihvLnBvc2l0aW9uLHApLHUudnN1YihjLG4pO2NvbnN0IHY9bi5ub3JtKCk7ci5jb3B5KG4pLHIubm9ybWFsaXplKCksby52ZWxvY2l0eS52c3ViKGkudmVsb2NpdHksYSksby5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocCxoKSxhLnZhZGQoaCxhKSxpLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhkLGgpLGEudnN1YihoLGEpLHIubXVsdCgtdCoodi1zKS1lKmEuZG90KHIpLGwpLGkuZm9yY2UudnN1YihsLGkuZm9yY2UpLG8uZm9yY2UudmFkZChsLG8uZm9yY2UpLGQuY3Jvc3MobCx5KSxwLmNyb3NzKGwsbSksaS50b3JxdWUudnN1Yih5LGkudG9ycXVlKSxvLnRvcnF1ZS52YWRkKG0sby50b3JxdWUpfX1jb25zdCBjZT1uZXcgaSx1ZT1uZXcgaSxkZT1uZXcgaSxwZT1uZXcgaSx5ZT1uZXcgaSxtZT1uZXcgaSx2ZT1uZXcgaSx3ZT1uZXcgaSxmZT1uZXcgaSx4ZT1uZXcgaSxnZT1uZXcgaTtuZXcgWTtjbGFzcyBiZSBleHRlbmRzIG17Y29uc3RydWN0b3IodCl7aWYoc3VwZXIoe3R5cGU6bS50eXBlcy5TUEhFUkV9KSx0aGlzLnJhZGl1cz12b2lkIDAhPT10P3Q6MSx0aGlzLnJhZGl1czwwKXRocm93IG5ldyBFcnJvcigiVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLiIpO3RoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKX1jYWxjdWxhdGVMb2NhbEluZXJ0aWEodCxlPW5ldyBpKXtjb25zdCBzPTIqdCp0aGlzLnJhZGl1cyp0aGlzLnJhZGl1cy81O3JldHVybiBlLng9cyxlLnk9cyxlLno9cyxlfXZvbHVtZSgpe3JldHVybiA0Kk1hdGguUEkqTWF0aC5wb3codGhpcy5yYWRpdXMsMykvM311cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpe3RoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9dGhpcy5yYWRpdXN9Y2FsY3VsYXRlV29ybGRBQUJCKHQsZSxzLGkpe2NvbnN0IG89dGhpcy5yYWRpdXMsbj1bIngiLCJ5IiwieiJdO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKXtjb25zdCByPW5bZV07c1tyXT10W3JdLW8saVtyXT10W3JdK299fX1jbGFzcyBBZSBleHRlbmRzIGZ7Y29uc3RydWN0b3IodCxlLHMsbyl7Y29uc3Qgbj1vLHI9W10sYT1bXSxsPVtdLGg9W10sYz1bXSx1PU1hdGguY29zLGQ9TWF0aC5zaW47ci5wdXNoKG5ldyBpKGUqdSgwKSxlKmQoMCksLjUqLXMpKSxoLnB1c2goMCksci5wdXNoKG5ldyBpKHQqdSgwKSx0KmQoMCksLjUqcykpLGMucHVzaCgxKTtmb3IobGV0IG89MDtvPG47bysrKXtjb25zdCBwPTIqTWF0aC5QSS9uKihvKzEpLHk9MipNYXRoLlBJL24qKG8rLjUpO288bi0xPyhyLnB1c2gobmV3IGkoZSp1KHApLGUqZChwKSwuNSotcykpLGgucHVzaCgyKm8rMiksci5wdXNoKG5ldyBpKHQqdShwKSx0KmQocCksLjUqcykpLGMucHVzaCgyKm8rMyksbC5wdXNoKFsyKm8rMiwyKm8rMywyKm8rMSwyKm9dKSk6bC5wdXNoKFswLDEsMipvKzEsMipvXSksKG4lMj09MXx8bzxuLzIpJiZhLnB1c2gobmV3IGkodSh5KSxkKHkpLDApKX1sLnB1c2goYyksYS5wdXNoKG5ldyBpKDAsMCwxKSk7Y29uc3QgcD1bXTtmb3IobGV0IHQ9MDt0PGgubGVuZ3RoO3QrKylwLnB1c2goaFtoLmxlbmd0aC10LTFdKTtsLnB1c2gocCksc3VwZXIoe3ZlcnRpY2VzOnIsZmFjZXM6bCxheGVzOmF9KX19Y2xhc3MgQmUgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoe3R5cGU6bS50eXBlcy5QQVJUSUNMRX0pfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGU9bmV3IGkpe3JldHVybiBlLnNldCgwLDAsMCksZX12b2x1bWUoKXtyZXR1cm4gMH11cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpe3RoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9MH1jYWxjdWxhdGVXb3JsZEFBQkIodCxlLHMsaSl7cy5jb3B5KHQpLGkuY29weSh0KX19Y2xhc3MgRWUgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoe3R5cGU6bS50eXBlcy5QTEFORX0pLHRoaXMud29ybGROb3JtYWw9bmV3IGksdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlPSEwLHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9TnVtYmVyLk1BWF9WQUxVRX1jb21wdXRlV29ybGROb3JtYWwodCl7Y29uc3QgZT10aGlzLndvcmxkTm9ybWFsO2Uuc2V0KDAsMCwxKSx0LnZtdWx0KGUsZSksdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlPSExfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGU9bmV3IGkpe3JldHVybiBlfXZvbHVtZSgpe3JldHVybiBOdW1iZXIuTUFYX1ZBTFVFfWNhbGN1bGF0ZVdvcmxkQUFCQih0LGUscyxpKXt6ZS5zZXQoMCwwLDEpLGUudm11bHQoemUsemUpO2NvbnN0IG89TnVtYmVyLk1BWF9WQUxVRTtzLnNldCgtbywtbywtbyksaS5zZXQobyxvLG8pLDE9PT16ZS54P2kueD10Lng6LTE9PT16ZS54JiYocy54PXQueCksMT09PXplLnk/aS55PXQueTotMT09PXplLnkmJihzLnk9dC55KSwxPT09emUuej9pLno9dC56Oi0xPT09emUueiYmKHMuej10LnopfXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz1OdW1iZXIuTUFYX1ZBTFVFfX1jb25zdCB6ZT1uZXcgaTtjbGFzcyBGZSBleHRlbmRzIG17Y29uc3RydWN0b3IodCxlPXt9KXtlPXp0LmRlZmF1bHRzKGUse21heFZhbHVlOm51bGwsbWluVmFsdWU6bnVsbCxlbGVtZW50U2l6ZToxfSksc3VwZXIoe3R5cGU6bS50eXBlcy5IRUlHSFRGSUVMRH0pLHRoaXMuZGF0YT10LHRoaXMubWF4VmFsdWU9ZS5tYXhWYWx1ZSx0aGlzLm1pblZhbHVlPWUubWluVmFsdWUsdGhpcy5lbGVtZW50U2l6ZT1lLmVsZW1lbnRTaXplLG51bGw9PT1lLm1pblZhbHVlJiZ0aGlzLnVwZGF0ZU1pblZhbHVlKCksbnVsbD09PWUubWF4VmFsdWUmJnRoaXMudXBkYXRlTWF4VmFsdWUoKSx0aGlzLmNhY2hlRW5hYmxlZD0hMCx0aGlzLnBpbGxhckNvbnZleD1uZXcgZix0aGlzLnBpbGxhck9mZnNldD1uZXcgaSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCksdGhpcy5fY2FjaGVkUGlsbGFycz17fX11cGRhdGUoKXt0aGlzLl9jYWNoZWRQaWxsYXJzPXt9fXVwZGF0ZU1pblZhbHVlKCl7Y29uc3QgdD10aGlzLmRhdGE7bGV0IGU9dFswXVswXTtmb3IobGV0IHM9MDtzIT09dC5sZW5ndGg7cysrKWZvcihsZXQgaT0wO2khPT10W3NdLmxlbmd0aDtpKyspe2NvbnN0IG89dFtzXVtpXTtvPGUmJihlPW8pfXRoaXMubWluVmFsdWU9ZX11cGRhdGVNYXhWYWx1ZSgpe2NvbnN0IHQ9dGhpcy5kYXRhO2xldCBlPXRbMF1bMF07Zm9yKGxldCBzPTA7cyE9PXQubGVuZ3RoO3MrKylmb3IobGV0IGk9MDtpIT09dFtzXS5sZW5ndGg7aSsrKXtjb25zdCBvPXRbc11baV07bz5lJiYoZT1vKX10aGlzLm1heFZhbHVlPWV9c2V0SGVpZ2h0VmFsdWVBdEluZGV4KHQsZSxzKXt0aGlzLmRhdGFbdF1bZV09cyx0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodCxlLCExKSx0PjAmJih0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodC0xLGUsITApLHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LTEsZSwhMSkpLGU+MCYmKHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUtMSwhMCksdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHQsZS0xLCExKSksZT4wJiZ0PjAmJnRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LTEsZS0xLCEwKX1nZXRSZWN0TWluTWF4KHQsZSxzLGksbz1bXSl7Y29uc3Qgbj10aGlzLmRhdGE7bGV0IHI9dGhpcy5taW5WYWx1ZTtmb3IobGV0IG89dDtvPD1zO28rKylmb3IobGV0IHQ9ZTt0PD1pO3QrKyl7Y29uc3QgZT1uW29dW3RdO2U+ciYmKHI9ZSl9b1swXT10aGlzLm1pblZhbHVlLG9bMV09cn1nZXRJbmRleE9mUG9zaXRpb24odCxlLHMsaSl7Y29uc3Qgbz10aGlzLmVsZW1lbnRTaXplLG49dGhpcy5kYXRhO2xldCByPU1hdGguZmxvb3IodC9vKSxhPU1hdGguZmxvb3IoZS9vKTtyZXR1cm4gc1swXT1yLHNbMV09YSxpJiYocjwwJiYocj0wKSxhPDAmJihhPTApLHI+PW4ubGVuZ3RoLTEmJihyPW4ubGVuZ3RoLTEpLGE+PW5bMF0ubGVuZ3RoLTEmJihhPW5bMF0ubGVuZ3RoLTEpKSwhKHI8MHx8YTwwfHxyPj1uLmxlbmd0aC0xfHxhPj1uWzBdLmxlbmd0aC0xKX1nZXRUcmlhbmdsZUF0KHQsZSxzLGksbyxuKXtjb25zdCByPVNlO3RoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHQsZSxyLHMpO2xldCBhPXJbMF0sbD1yWzFdO2NvbnN0IGg9dGhpcy5kYXRhO3MmJihhPU1hdGgubWluKGgubGVuZ3RoLTIsTWF0aC5tYXgoMCxhKSksbD1NYXRoLm1pbihoWzBdLmxlbmd0aC0yLE1hdGgubWF4KDAsbCkpKTtjb25zdCBjPXRoaXMuZWxlbWVudFNpemUsdT0odC9jLWEpKioyKyhlL2MtbCkqKjI+KHQvYy0oYSsxKSkqKjIrKGUvYy0obCsxKSkqKjI7cmV0dXJuIHRoaXMuZ2V0VHJpYW5nbGUoYSxsLHUsaSxvLG4pLHV9Z2V0Tm9ybWFsQXQodCxlLHMsaSl7Y29uc3Qgbz1QZSxuPU5lLHI9UmUsYT1JZSxsPUxlO3RoaXMuZ2V0VHJpYW5nbGVBdCh0LGUscyxvLG4sciksbi52c3ViKG8sYSksci52c3ViKG8sbCksYS5jcm9zcyhsLGkpLGkubm9ybWFsaXplKCl9Z2V0QWFiYkF0SW5kZXgodCxlLHtsb3dlckJvdW5kOnMsdXBwZXJCb3VuZDppfSl7Y29uc3Qgbz10aGlzLmRhdGEsbj10aGlzLmVsZW1lbnRTaXplO3Muc2V0KHQqbixlKm4sb1t0XVtlXSksaS5zZXQoKHQrMSkqbiwoZSsxKSpuLG9bdCsxXVtlKzFdKX1nZXRIZWlnaHRBdCh0LGUscyl7Y29uc3QgaT10aGlzLmRhdGEsbz1DZSxuPXFlLHI9VGUsYT1TZTt0aGlzLmdldEluZGV4T2ZQb3NpdGlvbih0LGUsYSxzKTtsZXQgbD1hWzBdLGg9YVsxXTtzJiYobD1NYXRoLm1pbihpLmxlbmd0aC0yLE1hdGgubWF4KDAsbCkpLGg9TWF0aC5taW4oaVswXS5sZW5ndGgtMixNYXRoLm1heCgwLGgpKSk7Y29uc3QgYz10aGlzLmdldFRyaWFuZ2xlQXQodCxlLHMsbyxuLHIpOyFmdW5jdGlvbih0LGUscyxpLG8sbixyLGEsbCl7bC54PSgobi1hKSoodC1yKSsoci1vKSooZS1hKSkvKChuLWEpKihzLXIpKyhyLW8pKihpLWEpKSxsLnk9KChhLWkpKih0LXIpKyhzLXIpKihlLWEpKS8oKG4tYSkqKHMtcikrKHItbykqKGktYSkpLGwuej0xLWwueC1sLnl9KHQsZSxvLngsby55LG4ueCxuLnksci54LHIueSxNZSk7Y29uc3QgdT1NZTtyZXR1cm4gYz9pW2wrMV1baCsxXSp1LngraVtsXVtoKzFdKnUueStpW2wrMV1baF0qdS56OmlbbF1baF0qdS54K2lbbCsxXVtoXSp1LnkraVtsXVtoKzFdKnUuen1nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHQsZSxzKXtyZXR1cm4gdCsiXyIrZSsiXyIrKHM/MTowKX1nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUscyl7cmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHQsZSxzKV19c2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodCxlLHMsaSxvKXt0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh0LGUscyldPXtjb252ZXg6aSxvZmZzZXQ6b319Y2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUscyl7ZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHQsZSxzKV19Z2V0VHJpYW5nbGUodCxlLHMsaSxvLG4pe2NvbnN0IHI9dGhpcy5kYXRhLGE9dGhpcy5lbGVtZW50U2l6ZTtzPyhpLnNldCgodCsxKSphLChlKzEpKmEsclt0KzFdW2UrMV0pLG8uc2V0KHQqYSwoZSsxKSphLHJbdF1bZSsxXSksbi5zZXQoKHQrMSkqYSxlKmEsclt0KzFdW2VdKSk6KGkuc2V0KHQqYSxlKmEsclt0XVtlXSksby5zZXQoKHQrMSkqYSxlKmEsclt0KzFdW2VdKSxuLnNldCh0KmEsKGUrMSkqYSxyW3RdW2UrMV0pKX1nZXRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUscyl7bGV0IG89dGhpcy5waWxsYXJDb252ZXgsbj10aGlzLnBpbGxhck9mZnNldDtpZih0aGlzLmNhY2hlRW5hYmxlZCl7Y29uc3Qgcj10aGlzLmdldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHQsZSxzKTtpZihyKXJldHVybiB0aGlzLnBpbGxhckNvbnZleD1yLmNvbnZleCx2b2lkKHRoaXMucGlsbGFyT2Zmc2V0PXIub2Zmc2V0KTtvPW5ldyBmLG49bmV3IGksdGhpcy5waWxsYXJDb252ZXg9byx0aGlzLnBpbGxhck9mZnNldD1ufWNvbnN0IHI9dGhpcy5kYXRhLGE9dGhpcy5lbGVtZW50U2l6ZSxsPW8uZmFjZXM7by52ZXJ0aWNlcy5sZW5ndGg9Njtmb3IobGV0IHQ9MDt0PDY7dCsrKW8udmVydGljZXNbdF18fChvLnZlcnRpY2VzW3RdPW5ldyBpKTtsLmxlbmd0aD01O2ZvcihsZXQgdD0wO3Q8NTt0KyspbFt0XXx8KGxbdF09W10pO2NvbnN0IGg9by52ZXJ0aWNlcyxjPShNYXRoLm1pbihyW3RdW2VdLHJbdCsxXVtlXSxyW3RdW2UrMV0sclt0KzFdW2UrMV0pLXRoaXMubWluVmFsdWUpLzIrdGhpcy5taW5WYWx1ZTtzPyhuLnNldCgodCsuNzUpKmEsKGUrLjc1KSphLGMpLGhbMF0uc2V0KC4yNSphLC4yNSphLHJbdCsxXVtlKzFdLWMpLGhbMV0uc2V0KC0uNzUqYSwuMjUqYSxyW3RdW2UrMV0tYyksaFsyXS5zZXQoLjI1KmEsLS43NSphLHJbdCsxXVtlXS1jKSxoWzNdLnNldCguMjUqYSwuMjUqYSwtYy0xKSxoWzRdLnNldCgtLjc1KmEsLjI1KmEsLWMtMSksaFs1XS5zZXQoLjI1KmEsLS43NSphLC1jLTEpLGxbMF1bMF09MCxsWzBdWzFdPTEsbFswXVsyXT0yLGxbMV1bMF09NSxsWzFdWzFdPTQsbFsxXVsyXT0zLGxbMl1bMF09MixsWzJdWzFdPTUsbFsyXVsyXT0zLGxbMl1bM109MCxsWzNdWzBdPTMsbFszXVsxXT00LGxbM11bMl09MSxsWzNdWzNdPTAsbFs0XVswXT0xLGxbNF1bMV09NCxsWzRdWzJdPTUsbFs0XVszXT0yKToobi5zZXQoKHQrLjI1KSphLChlKy4yNSkqYSxjKSxoWzBdLnNldCgtLjI1KmEsLS4yNSphLHJbdF1bZV0tYyksaFsxXS5zZXQoLjc1KmEsLS4yNSphLHJbdCsxXVtlXS1jKSxoWzJdLnNldCgtLjI1KmEsLjc1KmEsclt0XVtlKzFdLWMpLGhbM10uc2V0KC0uMjUqYSwtLjI1KmEsLWMtMSksaFs0XS5zZXQoLjc1KmEsLS4yNSphLC1jLTEpLGhbNV0uc2V0KC0uMjUqYSwuNzUqYSwtYy0xKSxsWzBdWzBdPTAsbFswXVsxXT0xLGxbMF1bMl09MixsWzFdWzBdPTUsbFsxXVsxXT00LGxbMV1bMl09MyxsWzJdWzBdPTAsbFsyXVsxXT0yLGxbMl1bMl09NSxsWzJdWzNdPTMsbFszXVswXT0xLGxbM11bMV09MCxsWzNdWzJdPTMsbFszXVszXT00LGxbNF1bMF09NCxsWzRdWzFdPTUsbFs0XVsyXT0yLGxbNF1bM109MSksby5jb21wdXRlTm9ybWFscygpLG8uY29tcHV0ZUVkZ2VzKCksby51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpLHRoaXMuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodCxlLHMsbyxuKX1jYWxjdWxhdGVMb2NhbEluZXJ0aWEodCxlPW5ldyBpKXtyZXR1cm4gZS5zZXQoMCwwLDApLGV9dm9sdW1lKCl7cmV0dXJuIE51bWJlci5NQVhfVkFMVUV9Y2FsY3VsYXRlV29ybGRBQUJCKHQsZSxzLGkpe3Muc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLC1OdW1iZXIuTUFYX1ZBTFVFLC1OdW1iZXIuTUFYX1ZBTFVFKSxpLnNldChOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSl9dXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKXtjb25zdCB0PXRoaXMuZGF0YSxlPXRoaXMuZWxlbWVudFNpemU7dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz1uZXcgaSh0Lmxlbmd0aCplLHRbMF0ubGVuZ3RoKmUsTWF0aC5tYXgoTWF0aC5hYnModGhpcy5tYXhWYWx1ZSksTWF0aC5hYnModGhpcy5taW5WYWx1ZSkpKS5ub3JtKCl9c2V0SGVpZ2h0c0Zyb21JbWFnZSh0LGUpe2NvbnN0e3g6cyx6OmkseTpvfT1lLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7bi53aWR0aD10LndpZHRoLG4uaGVpZ2h0PXQuaGVpZ2h0O2NvbnN0IHI9bi5nZXRDb250ZXh0KCIyZCIpO3IuZHJhd0ltYWdlKHQsMCwwKTtjb25zdCBhPXIuZ2V0SW1hZ2VEYXRhKDAsMCx0LndpZHRoLHQuaGVpZ2h0KSxsPXRoaXMuZGF0YTtsLmxlbmd0aD0wLHRoaXMuZWxlbWVudFNpemU9TWF0aC5hYnMocykvYS53aWR0aDtmb3IobGV0IHQ9MDt0PGEuaGVpZ2h0O3QrKyl7Y29uc3QgZT1bXTtmb3IobGV0IG89MDtvPGEud2lkdGg7bysrKXtjb25zdCBuPShhLmRhdGFbNCoodCphLmhlaWdodCtvKV0rYS5kYXRhWzQqKHQqYS5oZWlnaHQrbykrMV0rYS5kYXRhWzQqKHQqYS5oZWlnaHQrbykrMl0pLzQvMjU1Kmk7czwwP2UucHVzaChuKTplLnVuc2hpZnQobil9bzwwP2wudW5zaGlmdChlKTpsLnB1c2goZSl9dGhpcy51cGRhdGVNYXhWYWx1ZSgpLHRoaXMudXBkYXRlTWluVmFsdWUoKSx0aGlzLnVwZGF0ZSgpfX1jb25zdCBTZT1bXSxNZT1uZXcgaSxDZT1uZXcgaSxxZT1uZXcgaSxUZT1uZXcgaSxQZT1uZXcgaSxOZT1uZXcgaSxSZT1uZXcgaSxJZT1uZXcgaSxMZT1uZXcgaTtjbGFzcyBqZXtjb25zdHJ1Y3Rvcih0PXt9KXt0aGlzLnJvb3Q9dC5yb290fHxudWxsLHRoaXMuYWFiYj10LmFhYmI/dC5hYWJiLmNsb25lKCk6bmV3IGEsdGhpcy5kYXRhPVtdLHRoaXMuY2hpbGRyZW49W119cmVzZXQoKXt0aGlzLmNoaWxkcmVuLmxlbmd0aD10aGlzLmRhdGEubGVuZ3RoPTB9aW5zZXJ0KHQsZSxzPTApe2NvbnN0IGk9dGhpcy5kYXRhO2lmKCF0aGlzLmFhYmIuY29udGFpbnModCkpcmV0dXJuITE7Y29uc3Qgbz10aGlzLmNoaWxkcmVuO2lmKHM8KHRoaXMubWF4RGVwdGh8fHRoaXMucm9vdC5tYXhEZXB0aCkpe2xldCBpPSExO28ubGVuZ3RofHwodGhpcy5zdWJkaXZpZGUoKSxpPSEwKTtmb3IobGV0IGk9MDs4IT09aTtpKyspaWYob1tpXS5pbnNlcnQodCxlLHMrMSkpcmV0dXJuITA7aSYmKG8ubGVuZ3RoPTApfXJldHVybiBpLnB1c2goZSksITB9c3ViZGl2aWRlKCl7Y29uc3QgdD10aGlzLmFhYmIsZT10Lmxvd2VyQm91bmQscz10LnVwcGVyQm91bmQsbz10aGlzLmNoaWxkcmVuO28ucHVzaChuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMCwwLDApfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMSwwLDApfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMSwxLDApfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMSwxLDEpfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMCwxLDEpfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMCwwLDEpfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMSwwLDEpfSl9KSxuZXcgamUoe2FhYmI6bmV3IGEoe2xvd2VyQm91bmQ6bmV3IGkoMCwxLDApfSl9KSkscy52c3ViKGUsa2UpLGtlLnNjYWxlKC41LGtlKTtjb25zdCBuPXRoaXMucm9vdHx8dGhpcztmb3IobGV0IHQ9MDs4IT09dDt0Kyspe2NvbnN0IHM9b1t0XTtzLnJvb3Q9bjtjb25zdCBpPXMuYWFiYi5sb3dlckJvdW5kO2kueCo9a2UueCxpLnkqPWtlLnksaS56Kj1rZS56LGkudmFkZChlLGkpLGkudmFkZChrZSxzLmFhYmIudXBwZXJCb3VuZCl9fWFhYmJRdWVyeSh0LGUpe3RoaXMuZGF0YSx0aGlzLmNoaWxkcmVuO2NvbnN0IHM9W3RoaXNdO2Zvcig7cy5sZW5ndGg7KXtjb25zdCBpPXMucG9wKCk7aS5hYWJiLm92ZXJsYXBzKHQpJiZBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlLGkuZGF0YSksQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocyxpLmNoaWxkcmVuKX1yZXR1cm4gZX1yYXlRdWVyeSh0LGUscyl7cmV0dXJuIHQuZ2V0QUFCQihXZSksV2UudG9Mb2NhbEZyYW1lKGUsV2UpLHRoaXMuYWFiYlF1ZXJ5KFdlLHMpLHN9cmVtb3ZlRW1wdHlOb2Rlcygpe2ZvcihsZXQgdD10aGlzLmNoaWxkcmVuLmxlbmd0aC0xO3Q+PTA7dC0tKXRoaXMuY2hpbGRyZW5bdF0ucmVtb3ZlRW1wdHlOb2RlcygpLHRoaXMuY2hpbGRyZW5bdF0uY2hpbGRyZW4ubGVuZ3RofHx0aGlzLmNoaWxkcmVuW3RdLmRhdGEubGVuZ3RofHx0aGlzLmNoaWxkcmVuLnNwbGljZSh0LDEpfX1jbGFzcyBWZSBleHRlbmRzIGple2NvbnN0cnVjdG9yKHQsZT17fSl7c3VwZXIoe3Jvb3Q6bnVsbCxhYWJiOnR9KSx0aGlzLm1heERlcHRoPXZvaWQgMCE9PWUubWF4RGVwdGg/ZS5tYXhEZXB0aDo4fX1jb25zdCBrZT1uZXcgaSxXZT1uZXcgYTtjbGFzcyBPZSBleHRlbmRzIG17Y29uc3RydWN0b3IodCxlKXtzdXBlcih7dHlwZTptLnR5cGVzLlRSSU1FU0h9KSx0aGlzLnZlcnRpY2VzPW5ldyBGbG9hdDMyQXJyYXkodCksdGhpcy5pbmRpY2VzPW5ldyBJbnQxNkFycmF5KGUpLHRoaXMubm9ybWFscz1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSx0aGlzLmFhYmI9bmV3IGEsdGhpcy5lZGdlcz1udWxsLHRoaXMuc2NhbGU9bmV3IGkoMSwxLDEpLHRoaXMudHJlZT1uZXcgVmUsdGhpcy51cGRhdGVFZGdlcygpLHRoaXMudXBkYXRlTm9ybWFscygpLHRoaXMudXBkYXRlQUFCQigpLHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSx0aGlzLnVwZGF0ZVRyZWUoKX11cGRhdGVUcmVlKCl7Y29uc3QgdD10aGlzLnRyZWU7dC5yZXNldCgpLHQuYWFiYi5jb3B5KHRoaXMuYWFiYik7Y29uc3QgZT10aGlzLnNjYWxlO3QuYWFiYi5sb3dlckJvdW5kLngqPTEvZS54LHQuYWFiYi5sb3dlckJvdW5kLnkqPTEvZS55LHQuYWFiYi5sb3dlckJvdW5kLnoqPTEvZS56LHQuYWFiYi51cHBlckJvdW5kLngqPTEvZS54LHQuYWFiYi51cHBlckJvdW5kLnkqPTEvZS55LHQuYWFiYi51cHBlckJvdW5kLnoqPTEvZS56O2NvbnN0IHM9bmV3IGEsbz1uZXcgaSxuPW5ldyBpLHI9bmV3IGksbD1bbyxuLHJdO2ZvcihsZXQgZT0wO2U8dGhpcy5pbmRpY2VzLmxlbmd0aC8zO2UrKyl7Y29uc3QgaT0zKmU7dGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2ldLG8pLHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpKzFdLG4pLHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpKzJdLHIpLHMuc2V0RnJvbVBvaW50cyhsKSx0Lmluc2VydChzLGUpfXQucmVtb3ZlRW1wdHlOb2RlcygpfWdldFRyaWFuZ2xlc0luQUFCQih0LGUpe0hlLmNvcHkodCk7Y29uc3Qgcz10aGlzLnNjYWxlLGk9cy54LG89cy55LG49cy56LHI9SGUubG93ZXJCb3VuZCxhPUhlLnVwcGVyQm91bmQ7cmV0dXJuIHIueC89aSxyLnkvPW8sci56Lz1uLGEueC89aSxhLnkvPW8sYS56Lz1uLHRoaXMudHJlZS5hYWJiUXVlcnkoSGUsZSl9c2V0U2NhbGUodCl7Y29uc3QgZT10aGlzLnNjYWxlLng9PT10aGlzLnNjYWxlLnkmJnRoaXMuc2NhbGUueT09PXRoaXMuc2NhbGUueixzPXQueD09PXQueSYmdC55PT09dC56O2UmJnN8fHRoaXMudXBkYXRlTm9ybWFscygpLHRoaXMuc2NhbGUuY29weSh0KSx0aGlzLnVwZGF0ZUFBQkIoKSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl9dXBkYXRlTm9ybWFscygpe2NvbnN0IHQ9X2UsZT10aGlzLm5vcm1hbHM7Zm9yKGxldCBzPTA7czx0aGlzLmluZGljZXMubGVuZ3RoLzM7cysrKXtjb25zdCBpPTMqcyxvPXRoaXMuaW5kaWNlc1tpXSxuPXRoaXMuaW5kaWNlc1tpKzFdLHI9dGhpcy5pbmRpY2VzW2krMl07dGhpcy5nZXRWZXJ0ZXgobyxZZSksdGhpcy5nZXRWZXJ0ZXgobixaZSksdGhpcy5nZXRWZXJ0ZXgocixLZSksT2UuY29tcHV0ZU5vcm1hbChaZSxZZSxLZSx0KSxlW2ldPXQueCxlW2krMV09dC55LGVbaSsyXT10Lnp9fXVwZGF0ZUVkZ2VzKCl7Y29uc3QgdD17fSxlPShlLHMpPT57dFtlPHM/ZSsiXyIrczpzKyJfIitlXT0hMH07Zm9yKGxldCB0PTA7dDx0aGlzLmluZGljZXMubGVuZ3RoLzM7dCsrKXtjb25zdCBzPTMqdCxpPXRoaXMuaW5kaWNlc1tzXSxvPXRoaXMuaW5kaWNlc1tzKzFdLG49dGhpcy5pbmRpY2VzW3MrMl07ZShpLG8pLGUobyxuKSxlKG4saSl9Y29uc3Qgcz1PYmplY3Qua2V5cyh0KTt0aGlzLmVkZ2VzPW5ldyBJbnQxNkFycmF5KDIqcy5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGg7dCsrKXtjb25zdCBlPXNbdF0uc3BsaXQoIl8iKTt0aGlzLmVkZ2VzWzIqdF09cGFyc2VJbnQoZVswXSwxMCksdGhpcy5lZGdlc1syKnQrMV09cGFyc2VJbnQoZVsxXSwxMCl9fWdldEVkZ2VWZXJ0ZXgodCxlLHMpe2NvbnN0IGk9dGhpcy5lZGdlc1syKnQrKGU/MTowKV07dGhpcy5nZXRWZXJ0ZXgoaSxzKX1nZXRFZGdlVmVjdG9yKHQsZSl7Y29uc3Qgcz1VZSxpPUdlO3RoaXMuZ2V0RWRnZVZlcnRleCh0LDAscyksdGhpcy5nZXRFZGdlVmVydGV4KHQsMSxpKSxpLnZzdWIocyxlKX1nZXRWZXJ0ZXgodCxlKXtjb25zdCBzPXRoaXMuc2NhbGU7cmV0dXJuIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHQsZSksZS54Kj1zLngsZS55Kj1zLnksZS56Kj1zLnosZX1fZ2V0VW5zY2FsZWRWZXJ0ZXgodCxlKXtjb25zdCBzPTMqdCxpPXRoaXMudmVydGljZXM7cmV0dXJuIGUuc2V0KGlbc10saVtzKzFdLGlbcysyXSl9Z2V0V29ybGRWZXJ0ZXgodCxlLHMsaSl7cmV0dXJuIHRoaXMuZ2V0VmVydGV4KHQsaSksdi5wb2ludFRvV29ybGRGcmFtZShlLHMsaSxpKSxpfWdldFRyaWFuZ2xlVmVydGljZXModCxlLHMsaSl7Y29uc3Qgbz0zKnQ7dGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW29dLGUpLHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tvKzFdLHMpLHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tvKzJdLGkpfWdldE5vcm1hbCh0LGUpe2NvbnN0IHM9Myp0O3JldHVybiBlLnNldCh0aGlzLm5vcm1hbHNbc10sdGhpcy5ub3JtYWxzW3MrMV0sdGhpcy5ub3JtYWxzW3MrMl0pfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGUpe3RoaXMuY29tcHV0ZUxvY2FsQUFCQihRZSk7Y29uc3Qgcz1RZS51cHBlckJvdW5kLngtUWUubG93ZXJCb3VuZC54LGk9UWUudXBwZXJCb3VuZC55LVFlLmxvd2VyQm91bmQueSxvPVFlLnVwcGVyQm91bmQuei1RZS5sb3dlckJvdW5kLno7cmV0dXJuIGUuc2V0KDEvMTIqdCooMippKjIqaSsyKm8qMipvKSwxLzEyKnQqKDIqcyoyKnMrMipvKjIqbyksMS8xMip0KigyKmkqMippKzIqcyoyKnMpKX1jb21wdXRlTG9jYWxBQUJCKHQpe2NvbnN0IGU9dC5sb3dlckJvdW5kLHM9dC51cHBlckJvdW5kLGk9dGhpcy52ZXJ0aWNlcy5sZW5ndGgsbz0odGhpcy52ZXJ0aWNlcyxKZSk7dGhpcy5nZXRWZXJ0ZXgoMCxvKSxlLmNvcHkobykscy5jb3B5KG8pO2ZvcihsZXQgdD0wO3QhPT1pO3QrKyl0aGlzLmdldFZlcnRleCh0LG8pLG8ueDxlLng/ZS54PW8ueDpvLng+cy54JiYocy54PW8ueCksby55PGUueT9lLnk9by55Om8ueT5zLnkmJihzLnk9by55KSxvLno8ZS56P2Uuej1vLno6by56PnMueiYmKHMuej1vLnopfXVwZGF0ZUFBQkIoKXt0aGlzLmNvbXB1dGVMb2NhbEFBQkIodGhpcy5hYWJiKX11cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpe2xldCB0PTA7Y29uc3QgZT10aGlzLnZlcnRpY2VzLHM9bmV3IGk7Zm9yKGxldCBpPTAsbz1lLmxlbmd0aC8zO2khPT1vO2krKyl7dGhpcy5nZXRWZXJ0ZXgoaSxzKTtjb25zdCBlPXMubm9ybTIoKTtlPnQmJih0PWUpfXRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9TWF0aC5zcXJ0KHQpfWNhbGN1bGF0ZVdvcmxkQUFCQih0LGUscyxpKXtjb25zdCBvPSRlLG49dHM7by5wb3NpdGlvbj10LG8ucXVhdGVybmlvbj1lLHRoaXMuYWFiYi50b1dvcmxkRnJhbWUobyxuKSxzLmNvcHkobi5sb3dlckJvdW5kKSxpLmNvcHkobi51cHBlckJvdW5kKX12b2x1bWUoKXtyZXR1cm4gNCpNYXRoLlBJKnRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMvM319Y29uc3QgX2U9bmV3IGksSGU9bmV3IGEsVWU9bmV3IGksR2U9bmV3IGksRGU9bmV3IGksWGU9bmV3IGk7T2UuY29tcHV0ZU5vcm1hbD0odCxlLHMsaSk9PntlLnZzdWIodCxYZSkscy52c3ViKGUsRGUpLERlLmNyb3NzKFhlLGkpLGkuaXNaZXJvKCl8fGkubm9ybWFsaXplKCl9O2NvbnN0IFllPW5ldyBpLFplPW5ldyBpLEtlPW5ldyBpLFFlPW5ldyBhLEplPW5ldyBpLCRlPW5ldyB2LHRzPW5ldyBhO09lLmNyZWF0ZVRvcnVzPSh0PTEsZT0uNSxzPTgsaT02LG89MipNYXRoLlBJKT0+e2NvbnN0IG49W10scj1bXTtmb3IobGV0IHI9MDtyPD1zO3IrKylmb3IobGV0IGE9MDthPD1pO2ErKyl7Y29uc3QgbD1hL2kqbyxoPXIvcypNYXRoLlBJKjIsYz0odCtlKk1hdGguY29zKGgpKSpNYXRoLmNvcyhsKSx1PSh0K2UqTWF0aC5jb3MoaCkpKk1hdGguc2luKGwpLGQ9ZSpNYXRoLnNpbihoKTtuLnB1c2goYyx1LGQpfWZvcihsZXQgdD0xO3Q8PXM7dCsrKWZvcihsZXQgZT0xO2U8PWk7ZSsrKXtjb25zdCBzPShpKzEpKnQrZS0xLG89KGkrMSkqKHQtMSkrZS0xLG49KGkrMSkqKHQtMSkrZSxhPShpKzEpKnQrZTtyLnB1c2gocyxvLGEpLHIucHVzaChvLG4sYSl9cmV0dXJuIG5ldyBPZShuLHIpfTtjbGFzcyBlcyBleHRlbmRzIGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5lcXVhdGlvbnM9W119c29sdmUodCxlKXtyZXR1cm4gMH1hZGRFcXVhdGlvbih0KXt0LmVuYWJsZWQmJnRoaXMuZXF1YXRpb25zLnB1c2godCl9cmVtb3ZlRXF1YXRpb24odCl7Y29uc3QgZT10aGlzLmVxdWF0aW9ucyxzPWUuaW5kZXhPZih0KTstMSE9PXMmJmUuc3BsaWNlKHMsMSl9cmVtb3ZlQWxsRXF1YXRpb25zKCl7dGhpcy5lcXVhdGlvbnMubGVuZ3RoPTB9fXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pdGVyYXRpb25zPTEwLHRoaXMudG9sZXJhbmNlPTFlLTd9c29sdmUodCxlKXtsZXQgcz0wO2NvbnN0IGk9dGhpcy5pdGVyYXRpb25zLG89dGhpcy50b2xlcmFuY2UqdGhpcy50b2xlcmFuY2Usbj10aGlzLmVxdWF0aW9ucyxyPW4ubGVuZ3RoLGE9ZS5ib2RpZXMsbD1hLmxlbmd0aCxoPXQ7bGV0IGMsdSxkLHAseSxtO2lmKDAhPT1yKWZvcihsZXQgdD0wO3QhPT1sO3QrKylhW3RdLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTtjb25zdCB2PWlzLHc9b3MsZj1zczt2Lmxlbmd0aD1yLHcubGVuZ3RoPXIsZi5sZW5ndGg9cjtmb3IobGV0IHQ9MDt0IT09cjt0Kyspe2NvbnN0IGU9blt0XTtmW3RdPTAsd1t0XT1lLmNvbXB1dGVCKGgpLHZbdF09MS9lLmNvbXB1dGVDKCl9aWYoMCE9PXIpe2ZvcihsZXQgdD0wO3QhPT1sO3QrKyl7Y29uc3QgZT1hW3RdLHM9ZS52bGFtYmRhLGk9ZS53bGFtYmRhO3Muc2V0KDAsMCwwKSxpLnNldCgwLDAsMCl9Zm9yKHM9MDtzIT09aTtzKyspe3A9MDtmb3IobGV0IHQ9MDt0IT09cjt0Kyspe2NvbnN0IGU9blt0XTtjPXdbdF0sdT12W3RdLG09Zlt0XSx5PWUuY29tcHV0ZUdXbGFtYmRhKCksZD11KihjLXktZS5lcHMqbSksbStkPGUubWluRm9yY2U/ZD1lLm1pbkZvcmNlLW06bStkPmUubWF4Rm9yY2UmJihkPWUubWF4Rm9yY2UtbSksZlt0XSs9ZCxwKz1kPjA/ZDotZCxlLmFkZFRvV2xhbWJkYShkKX1pZihwKnA8bylicmVha31mb3IobGV0IHQ9MDt0IT09bDt0Kyspe2NvbnN0IGU9YVt0XSxzPWUudmVsb2NpdHksaT1lLmFuZ3VsYXJWZWxvY2l0eTtlLnZsYW1iZGEudm11bChlLmxpbmVhckZhY3RvcixlLnZsYW1iZGEpLHMudmFkZChlLnZsYW1iZGEscyksZS53bGFtYmRhLnZtdWwoZS5hbmd1bGFyRmFjdG9yLGUud2xhbWJkYSksaS52YWRkKGUud2xhbWJkYSxpKX1sZXQgdD1uLmxlbmd0aDtjb25zdCBlPTEvaDtmb3IoO3QtLTspblt0XS5tdWx0aXBsaWVyPWZbdF0qZX1yZXR1cm4gc319Y29uc3Qgc3M9W10saXM9W10sb3M9W107Y2xhc3MgbnMgZXh0ZW5kcyBjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMub2JqZWN0cz1bXSx0aGlzLnR5cGU9T2JqZWN0fXJlbGVhc2UoLi4udCl7Y29uc3QgZT10Lmxlbmd0aDtmb3IobGV0IHM9MDtzIT09ZTtzKyspdGhpcy5vYmplY3RzLnB1c2godFtzXSk7cmV0dXJuIHRoaXN9Z2V0KCl7cmV0dXJuIDA9PT10aGlzLm9iamVjdHMubGVuZ3RoP3RoaXMuY29uc3RydWN0T2JqZWN0KCk6dGhpcy5vYmplY3RzLnBvcCgpfWNvbnN0cnVjdE9iamVjdCgpe3Rocm93IG5ldyBFcnJvcigiY29uc3RydWN0T2JqZWN0KCkgbm90IGltcGxlbWVudGVkIGluIHRoaXMgUG9vbCBzdWJjbGFzcyB5ZXQhIil9cmVzaXplKHQpe2NvbnN0IGU9dGhpcy5vYmplY3RzO2Zvcig7ZS5sZW5ndGg+dDspZS5wb3AoKTtmb3IoO2UubGVuZ3RoPHQ7KWUucHVzaCh0aGlzLmNvbnN0cnVjdE9iamVjdCgpKTtyZXR1cm4gdGhpc319e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnR5cGU9aX1jb25zdHJ1Y3RPYmplY3QoKXtyZXR1cm4gbmV3IGl9fWNvbnN0IHJzPW0udHlwZXMuU1BIRVJFLGFzPW0udHlwZXMuU1BIRVJFfG0udHlwZXMuUExBTkUsbHM9bS50eXBlcy5CT1h8bS50eXBlcy5CT1gsaHM9bS50eXBlcy5TUEhFUkV8bS50eXBlcy5CT1gsY3M9bS50eXBlcy5QTEFORXxtLnR5cGVzLkJPWCx1cz1tLnR5cGVzLkNPTlZFWFBPTFlIRURST04sZHM9bS50eXBlcy5TUEhFUkV8bS50eXBlcy5DT05WRVhQT0xZSEVEUk9OLHBzPW0udHlwZXMuUExBTkV8bS50eXBlcy5DT05WRVhQT0xZSEVEUk9OLHlzPW0udHlwZXMuQk9YfG0udHlwZXMuQ09OVkVYUE9MWUhFRFJPTixtcz1tLnR5cGVzLlNQSEVSRXxtLnR5cGVzLkhFSUdIVEZJRUxELHZzPW0udHlwZXMuQk9YfG0udHlwZXMuSEVJR0hURklFTEQsd3M9bS50eXBlcy5DT05WRVhQT0xZSEVEUk9OfG0udHlwZXMuSEVJR0hURklFTEQsZnM9bS50eXBlcy5QQVJUSUNMRXxtLnR5cGVzLlNQSEVSRSx4cz1tLnR5cGVzLlBMQU5FfG0udHlwZXMuUEFSVElDTEUsZ3M9bS50eXBlcy5CT1h8bS50eXBlcy5QQVJUSUNMRSxicz1tLnR5cGVzLlBBUlRJQ0xFfG0udHlwZXMuQ09OVkVYUE9MWUhFRFJPTixBcz1tLnR5cGVzLlNQSEVSRXxtLnR5cGVzLlRSSU1FU0gsQnM9bS50eXBlcy5QTEFORXxtLnR5cGVzLlRSSU1FU0g7Y2xhc3MgRXN7Y29uc3RydWN0b3IodCl7dGhpcy5jb250YWN0UG9pbnRQb29sPVtdLHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w9W10sdGhpcy5yZXN1bHQ9W10sdGhpcy5mcmljdGlvblJlc3VsdD1bXSx0aGlzLnYzcG9vbD1uZXcgbnMsdGhpcy53b3JsZD10LHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbD10LmRlZmF1bHRDb250YWN0TWF0ZXJpYWwsdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbj0hMX1jcmVhdGVDb250YWN0RXF1YXRpb24odCxlLHMsaSxvLG4pe2xldCByO3RoaXMuY29udGFjdFBvaW50UG9vbC5sZW5ndGg/KHI9dGhpcy5jb250YWN0UG9pbnRQb29sLnBvcCgpLHIuYmk9dCxyLmJqPWUpOnI9bmV3IEl0KHQsZSksci5lbmFibGVkPXQuY29sbGlzaW9uUmVzcG9uc2UmJmUuY29sbGlzaW9uUmVzcG9uc2UmJnMuY29sbGlzaW9uUmVzcG9uc2UmJmkuY29sbGlzaW9uUmVzcG9uc2U7Y29uc3QgYT10aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7ci5yZXN0aXR1dGlvbj1hLnJlc3RpdHV0aW9uLHIuc2V0U3Bvb2tQYXJhbXMoYS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsYS5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uLHRoaXMud29ybGQuZHQpO2NvbnN0IGw9cy5tYXRlcmlhbHx8dC5tYXRlcmlhbCxoPWkubWF0ZXJpYWx8fGUubWF0ZXJpYWw7cmV0dXJuIGwmJmgmJmwucmVzdGl0dXRpb24+PTAmJmgucmVzdGl0dXRpb24+PTAmJihyLnJlc3RpdHV0aW9uPWwucmVzdGl0dXRpb24qaC5yZXN0aXR1dGlvbiksci5zaT1vfHxzLHIuc2o9bnx8aSxyfWNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QodCxlKXtjb25zdCBzPXQuYmksaT10LmJqLG89dC5zaSxuPXQuc2oscj10aGlzLndvcmxkLGE9dGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO2xldCBsPWEuZnJpY3Rpb247Y29uc3QgaD1vLm1hdGVyaWFsfHxzLm1hdGVyaWFsLGM9bi5tYXRlcmlhbHx8aS5tYXRlcmlhbDtpZihoJiZjJiZoLmZyaWN0aW9uPj0wJiZjLmZyaWN0aW9uPj0wJiYobD1oLmZyaWN0aW9uKmMuZnJpY3Rpb24pLGw+MCl7Y29uc3Qgbz1sKnIuZ3Jhdml0eS5sZW5ndGgoKTtsZXQgbj1zLmludk1hc3MraS5pbnZNYXNzO24+MCYmKG49MS9uKTtjb25zdCBoPXRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wsYz1oLmxlbmd0aD9oLnBvcCgpOm5ldyBvZShzLGksbypuKSx1PWgubGVuZ3RoP2gucG9wKCk6bmV3IG9lKHMsaSxvKm4pO3JldHVybiBjLmJpPXUuYmk9cyxjLmJqPXUuYmo9aSxjLm1pbkZvcmNlPXUubWluRm9yY2U9LW8qbixjLm1heEZvcmNlPXUubWF4Rm9yY2U9bypuLGMucmkuY29weSh0LnJpKSxjLnJqLmNvcHkodC5yaiksdS5yaS5jb3B5KHQucmkpLHUucmouY29weSh0LnJqKSx0Lm5pLnRhbmdlbnRzKGMudCx1LnQpLGMuc2V0U3Bvb2tQYXJhbXMoYS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLGEuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sci5kdCksdS5zZXRTcG9va1BhcmFtcyhhLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsYS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbixyLmR0KSxjLmVuYWJsZWQ9dS5lbmFibGVkPXQuZW5hYmxlZCxlLnB1c2goYyx1KSwhMH1yZXR1cm4hMX1jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKHQpe2xldCBlPXRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aC0xXTtpZighdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KGUsdGhpcy5mcmljdGlvblJlc3VsdCl8fDE9PT10KXJldHVybjtjb25zdCBzPXRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGgtMl0saT10aGlzLmZyaWN0aW9uUmVzdWx0W3RoaXMuZnJpY3Rpb25SZXN1bHQubGVuZ3RoLTFdO3pzLnNldFplcm8oKSxGcy5zZXRaZXJvKCksU3Muc2V0WmVybygpO2NvbnN0IG89ZS5iaTtlLmJqO2ZvcihsZXQgcz0wO3MhPT10O3MrKyllPXRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aC0xLXNdLGUuYmkhPT1vPyh6cy52YWRkKGUubmksenMpLEZzLnZhZGQoZS5yaSxGcyksU3MudmFkZChlLnJqLFNzKSk6KHpzLnZzdWIoZS5uaSx6cyksRnMudmFkZChlLnJqLEZzKSxTcy52YWRkKGUucmksU3MpKTtjb25zdCBuPTEvdDtGcy5zY2FsZShuLHMucmkpLFNzLnNjYWxlKG4scy5yaiksaS5yaS5jb3B5KHMucmkpLGkucmouY29weShzLnJqKSx6cy5ub3JtYWxpemUoKSx6cy50YW5nZW50cyhzLnQsaS50KX1nZXRDb250YWN0cyh0LGUscyxpLG8sbixyKXt0aGlzLmNvbnRhY3RQb2ludFBvb2w9byx0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sPXIsdGhpcy5yZXN1bHQ9aSx0aGlzLmZyaWN0aW9uUmVzdWx0PW47Y29uc3QgYT1xcyxsPVRzLGg9TXMsYz1Dcztmb3IobGV0IGk9MCxvPXQubGVuZ3RoO2khPT1vO2krKyl7Y29uc3Qgbz10W2ldLG49ZVtpXTtsZXQgcj1udWxsO28ubWF0ZXJpYWwmJm4ubWF0ZXJpYWwmJihyPXMuZ2V0Q29udGFjdE1hdGVyaWFsKG8ubWF0ZXJpYWwsbi5tYXRlcmlhbCl8fG51bGwpO2NvbnN0IHU9by50eXBlJlMuS0lORU1BVElDJiZuLnR5cGUmUy5TVEFUSUN8fG8udHlwZSZTLlNUQVRJQyYmbi50eXBlJlMuS0lORU1BVElDfHxvLnR5cGUmUy5LSU5FTUFUSUMmJm4udHlwZSZTLktJTkVNQVRJQztmb3IobGV0IHQ9MDt0PG8uc2hhcGVzLmxlbmd0aDt0Kyspe28ucXVhdGVybmlvbi5tdWx0KG8uc2hhcGVPcmllbnRhdGlvbnNbdF0sYSksby5xdWF0ZXJuaW9uLnZtdWx0KG8uc2hhcGVPZmZzZXRzW3RdLGgpLGgudmFkZChvLnBvc2l0aW9uLGgpO2NvbnN0IGU9by5zaGFwZXNbdF07Zm9yKGxldCB0PTA7dDxuLnNoYXBlcy5sZW5ndGg7dCsrKXtuLnF1YXRlcm5pb24ubXVsdChuLnNoYXBlT3JpZW50YXRpb25zW3RdLGwpLG4ucXVhdGVybmlvbi52bXVsdChuLnNoYXBlT2Zmc2V0c1t0XSxjKSxjLnZhZGQobi5wb3NpdGlvbixjKTtjb25zdCBpPW4uc2hhcGVzW3RdO2lmKCEoZS5jb2xsaXNpb25GaWx0ZXJNYXNrJmkuY29sbGlzaW9uRmlsdGVyR3JvdXAmJmkuY29sbGlzaW9uRmlsdGVyTWFzayZlLmNvbGxpc2lvbkZpbHRlckdyb3VwKSljb250aW51ZTtpZihoLmRpc3RhbmNlVG8oYyk+ZS5ib3VuZGluZ1NwaGVyZVJhZGl1cytpLmJvdW5kaW5nU3BoZXJlUmFkaXVzKWNvbnRpbnVlO2xldCBkPW51bGw7ZS5tYXRlcmlhbCYmaS5tYXRlcmlhbCYmKGQ9cy5nZXRDb250YWN0TWF0ZXJpYWwoZS5tYXRlcmlhbCxpLm1hdGVyaWFsKXx8bnVsbCksdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsPWR8fHJ8fHMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtjb25zdCBwPXRoaXNbZS50eXBlfGkudHlwZV07aWYocCl7bGV0IHQ9ITE7dD1lLnR5cGU8aS50eXBlP3AuY2FsbCh0aGlzLGUsaSxoLGMsYSxsLG8sbixlLGksdSk6cC5jYWxsKHRoaXMsaSxlLGMsaCxsLGEsbixvLGUsaSx1KSx0JiZ1JiYocy5zaGFwZU92ZXJsYXBLZWVwZXIuc2V0KGUuaWQsaS5pZCkscy5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoby5pZCxuLmlkKSl9fX19fXNwaGVyZVNwaGVyZSh0LGUscyxpLG8sbixyLGEsbCxoLGMpe2lmKGMpcmV0dXJuIHMuZGlzdGFuY2VTcXVhcmVkKGkpPCh0LnJhZGl1cytlLnJhZGl1cykqKjI7Y29uc3QgdT10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7aS52c3ViKHMsdS5uaSksdS5uaS5ub3JtYWxpemUoKSx1LnJpLmNvcHkodS5uaSksdS5yai5jb3B5KHUubmkpLHUucmkubXVsdCh0LnJhZGl1cyx1LnJpKSx1LnJqLm11bHQoLWUucmFkaXVzLHUucmopLHUucmkudmFkZChzLHUucmkpLHUucmkudnN1YihyLnBvc2l0aW9uLHUucmkpLHUucmoudmFkZChpLHUucmopLHUucmoudnN1YihhLnBvc2l0aW9uLHUucmopLHRoaXMucmVzdWx0LnB1c2godSksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHUsdGhpcy5mcmljdGlvblJlc3VsdCl9c3BoZXJlUGxhbmUodCxlLHMsaSxvLG4scixhLGwsaCxjKXtjb25zdCB1PXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTtpZih1Lm5pLnNldCgwLDAsMSksbi52bXVsdCh1Lm5pLHUubmkpLHUubmkubmVnYXRlKHUubmkpLHUubmkubm9ybWFsaXplKCksdS5uaS5tdWx0KHQucmFkaXVzLHUucmkpLHMudnN1YihpLEtzKSx1Lm5pLm11bHQodS5uaS5kb3QoS3MpLFFzKSxLcy52c3ViKFFzLHUucmopLC1Lcy5kb3QodS5uaSk8PXQucmFkaXVzKXtpZihjKXJldHVybiEwO2NvbnN0IHQ9dS5yaSxlPXUucmo7dC52YWRkKHMsdCksdC52c3ViKHIucG9zaXRpb24sdCksZS52YWRkKGksZSksZS52c3ViKGEucG9zaXRpb24sZSksdGhpcy5yZXN1bHQucHVzaCh1KSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QodSx0aGlzLmZyaWN0aW9uUmVzdWx0KX19Ym94Qm94KHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7cmV0dXJuIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsPXQubWF0ZXJpYWwsZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWw9ZS5tYXRlcmlhbCx0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZT10LmNvbGxpc2lvblJlc3BvbnNlLGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlPWUuY29sbGlzaW9uUmVzcG9uc2UsdGhpcy5jb252ZXhDb252ZXgodC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24scyxpLG8sbixyLGEsdCxlLGMpfXNwaGVyZUJveCh0LGUscyxpLG8sbixyLGEsbCxoLGMpe2NvbnN0IHU9dGhpcy52M3Bvb2wsZD1yaTtzLnZzdWIoaSxzaSksZS5nZXRTaWRlTm9ybWFscyhkLG4pO2NvbnN0IHA9dC5yYWRpdXM7bGV0IHk9ITE7Y29uc3QgbT1saSx2PWhpLHc9Y2k7bGV0IGY9bnVsbCx4PTAsZz0wLGI9MCxBPW51bGw7Zm9yKGxldCB0PTAsZT1kLmxlbmd0aDt0IT09ZSYmITE9PT15O3QrKyl7Y29uc3QgZT1paTtlLmNvcHkoZFt0XSk7Y29uc3Qgcz1lLm5vcm0oKTtlLm5vcm1hbGl6ZSgpO2NvbnN0IGk9c2kuZG90KGUpO2lmKGk8cytwJiZpPjApe2NvbnN0IG89b2ksbj1uaTtvLmNvcHkoZFsodCsxKSUzXSksbi5jb3B5KGRbKHQrMiklM10pO2NvbnN0IHI9by5ub3JtKCksYT1uLm5vcm0oKTtvLm5vcm1hbGl6ZSgpLG4ubm9ybWFsaXplKCk7Y29uc3QgbD1zaS5kb3QobyksaD1zaS5kb3Qobik7aWYobDxyJiZsPi1yJiZoPGEmJmg+LWEpe2NvbnN0IHQ9TWF0aC5hYnMoaS1zLXApO2lmKChudWxsPT09QXx8dDxBKSYmKEE9dCxnPWwsYj1oLGY9cyxtLmNvcHkoZSksdi5jb3B5KG8pLHcuY29weShuKSx4KyssYykpcmV0dXJuITB9fX1pZih4KXt5PSEwO2NvbnN0IG89dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpO20ubXVsdCgtcCxvLnJpKSxvLm5pLmNvcHkobSksby5uaS5uZWdhdGUoby5uaSksbS5tdWx0KGYsbSksdi5tdWx0KGcsdiksbS52YWRkKHYsbSksdy5tdWx0KGIsdyksbS52YWRkKHcsby5yaiksby5yaS52YWRkKHMsby5yaSksby5yaS52c3ViKHIucG9zaXRpb24sby5yaSksby5yai52YWRkKGksby5yaiksby5yai52c3ViKGEucG9zaXRpb24sby5yaiksdGhpcy5yZXN1bHQucHVzaChvKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobyx0aGlzLmZyaWN0aW9uUmVzdWx0KX1sZXQgQj11LmdldCgpO2NvbnN0IEU9YWk7Zm9yKGxldCBvPTA7MiE9PW8mJiF5O28rKylmb3IobGV0IG49MDsyIT09biYmIXk7bisrKWZvcihsZXQgdT0wOzIhPT11JiYheTt1KyspaWYoQi5zZXQoMCwwLDApLG8/Qi52YWRkKGRbMF0sQik6Qi52c3ViKGRbMF0sQiksbj9CLnZhZGQoZFsxXSxCKTpCLnZzdWIoZFsxXSxCKSx1P0IudmFkZChkWzJdLEIpOkIudnN1YihkWzJdLEIpLGkudmFkZChCLEUpLEUudnN1YihzLEUpLEUubm9ybTIoKTxwKnApe2lmKGMpcmV0dXJuITA7eT0hMDtjb25zdCBvPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTtvLnJpLmNvcHkoRSksby5yaS5ub3JtYWxpemUoKSxvLm5pLmNvcHkoby5yaSksby5yaS5tdWx0KHAsby5yaSksby5yai5jb3B5KEIpLG8ucmkudmFkZChzLG8ucmkpLG8ucmkudnN1YihyLnBvc2l0aW9uLG8ucmkpLG8ucmoudmFkZChpLG8ucmopLG8ucmoudnN1YihhLnBvc2l0aW9uLG8ucmopLHRoaXMucmVzdWx0LnB1c2gobyksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KG8sdGhpcy5mcmljdGlvblJlc3VsdCl9dS5yZWxlYXNlKEIpLEI9bnVsbDtjb25zdCB6PXUuZ2V0KCksRj11LmdldCgpLFM9dS5nZXQoKSxNPXUuZ2V0KCksQz11LmdldCgpLHE9ZC5sZW5ndGg7Zm9yKGxldCBvPTA7byE9PXEmJiF5O28rKylmb3IobGV0IG49MDtuIT09cSYmIXk7bisrKWlmKG8lMyE9biUzKXtkW25dLmNyb3NzKGRbb10seiksei5ub3JtYWxpemUoKSxkW29dLnZhZGQoZFtuXSxGKSxTLmNvcHkocyksUy52c3ViKEYsUyksUy52c3ViKGksUyk7Y29uc3QgdT1TLmRvdCh6KTt6Lm11bHQodSxNKTtsZXQgbT0wO2Zvcig7bT09PW8lM3x8bT09PW4lMzspbSsrO0MuY29weShzKSxDLnZzdWIoTSxDKSxDLnZzdWIoRixDKSxDLnZzdWIoaSxDKTtjb25zdCB2PU1hdGguYWJzKHUpLHc9Qy5ub3JtKCk7aWYodjxkW21dLm5vcm0oKSYmdzxwKXtpZihjKXJldHVybiEwO3k9ITA7Y29uc3Qgbz10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7Ri52YWRkKE0sby5yaiksby5yai5jb3B5KG8ucmopLEMubmVnYXRlKG8ubmkpLG8ubmkubm9ybWFsaXplKCksby5yaS5jb3B5KG8ucmopLG8ucmkudmFkZChpLG8ucmkpLG8ucmkudnN1YihzLG8ucmkpLG8ucmkubm9ybWFsaXplKCksby5yaS5tdWx0KHAsby5yaSksby5yaS52YWRkKHMsby5yaSksby5yaS52c3ViKHIucG9zaXRpb24sby5yaSksby5yai52YWRkKGksby5yaiksby5yai52c3ViKGEucG9zaXRpb24sby5yaiksdGhpcy5yZXN1bHQucHVzaChvKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobyx0aGlzLmZyaWN0aW9uUmVzdWx0KX19dS5yZWxlYXNlKHosRixTLE0sQyl9cGxhbmVCb3godCxlLHMsaSxvLG4scixhLGwsaCxjKXtyZXR1cm4gZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWw9ZS5tYXRlcmlhbCxlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZT1lLmNvbGxpc2lvblJlc3BvbnNlLGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmlkPWUuaWQsdGhpcy5wbGFuZUNvbnZleCh0LGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHMsaSxvLG4scixhLHQsZSxjKX1jb252ZXhDb252ZXgodCxlLHMsaSxvLG4scixhLGwsaCxjLHUsZCl7Y29uc3QgcD16aTtpZighKHMuZGlzdGFuY2VUbyhpKT50LmJvdW5kaW5nU3BoZXJlUmFkaXVzK2UuYm91bmRpbmdTcGhlcmVSYWRpdXMpJiZ0LmZpbmRTZXBhcmF0aW5nQXhpcyhlLHMsbyxpLG4scCx1LGQpKXtjb25zdCB1PVtdLGQ9Rmk7dC5jbGlwQWdhaW5zdEh1bGwocyxvLGUsaSxuLHAsLTEwMCwxMDAsdSk7bGV0IHk9MDtmb3IobGV0IG89MDtvIT09dS5sZW5ndGg7bysrKXtpZihjKXJldHVybiEwO2NvbnN0IG49dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpLG09bi5yaSx2PW4ucmo7cC5uZWdhdGUobi5uaSksdVtvXS5ub3JtYWwubmVnYXRlKGQpLGQubXVsdCh1W29dLmRlcHRoLGQpLHVbb10ucG9pbnQudmFkZChkLG0pLHYuY29weSh1W29dLnBvaW50KSxtLnZzdWIocyxtKSx2LnZzdWIoaSx2KSxtLnZhZGQocyxtKSxtLnZzdWIoci5wb3NpdGlvbixtKSx2LnZhZGQoaSx2KSx2LnZzdWIoYS5wb3NpdGlvbix2KSx0aGlzLnJlc3VsdC5wdXNoKG4pLHkrKyx0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9ufHx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobix0aGlzLmZyaWN0aW9uUmVzdWx0KX10aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uJiZ5JiZ0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UoeSl9fXNwaGVyZUNvbnZleCh0LGUscyxpLG8sbixyLGEsbCxoLGMpe2NvbnN0IHU9dGhpcy52M3Bvb2w7cy52c3ViKGksdWkpO2NvbnN0IGQ9ZS5mYWNlTm9ybWFscyxwPWUuZmFjZXMseT1lLnZlcnRpY2VzLG09dC5yYWRpdXM7bGV0IHY9ITE7Zm9yKGxldCBvPTA7byE9PXkubGVuZ3RoO28rKyl7Y29uc3QgdT15W29dLGQ9bWk7bi52bXVsdCh1LGQpLGkudmFkZChkLGQpO2NvbnN0IHA9eWk7aWYoZC52c3ViKHMscCkscC5ub3JtMigpPG0qbSl7aWYoYylyZXR1cm4hMDt2PSEwO2NvbnN0IG89dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpO3JldHVybiBvLnJpLmNvcHkocCksby5yaS5ub3JtYWxpemUoKSxvLm5pLmNvcHkoby5yaSksby5yaS5tdWx0KG0sby5yaSksZC52c3ViKGksby5yaiksby5yaS52YWRkKHMsby5yaSksby5yaS52c3ViKHIucG9zaXRpb24sby5yaSksby5yai52YWRkKGksby5yaiksby5yai52c3ViKGEucG9zaXRpb24sby5yaiksdGhpcy5yZXN1bHQucHVzaChvKSx2b2lkIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChvLHRoaXMuZnJpY3Rpb25SZXN1bHQpfX1mb3IobGV0IG89MCx3PXAubGVuZ3RoO28hPT13JiYhMT09PXY7bysrKXtjb25zdCB3PWRbb10sZj1wW29dLHg9dmk7bi52bXVsdCh3LHgpO2NvbnN0IGc9d2k7bi52bXVsdCh5W2ZbMF1dLGcpLGcudmFkZChpLGcpO2NvbnN0IGI9Zmk7eC5tdWx0KC1tLGIpLHMudmFkZChiLGIpO2NvbnN0IEE9eGk7Yi52c3ViKGcsQSk7Y29uc3QgQj1BLmRvdCh4KSxFPWdpO2lmKHMudnN1YihnLEUpLEI8MCYmRS5kb3QoeCk+MCl7Y29uc3Qgbz1bXTtmb3IobGV0IHQ9MCxlPWYubGVuZ3RoO3QhPT1lO3QrKyl7Y29uc3QgZT11LmdldCgpO24udm11bHQoeVtmW3RdXSxlKSxpLnZhZGQoZSxlKSxvLnB1c2goZSl9aWYoZWkobyx4LHMpKXtpZihjKXJldHVybiEwO3Y9ITA7Y29uc3Qgbj10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7eC5tdWx0KC1tLG4ucmkpLHgubmVnYXRlKG4ubmkpO2NvbnN0IGQ9dS5nZXQoKTt4Lm11bHQoLUIsZCk7Y29uc3QgcD11LmdldCgpO3gubXVsdCgtbSxwKSxzLnZzdWIoaSxuLnJqKSxuLnJqLnZhZGQocCxuLnJqKSxuLnJqLnZhZGQoZCxuLnJqKSxuLnJqLnZhZGQoaSxuLnJqKSxuLnJqLnZzdWIoYS5wb3NpdGlvbixuLnJqKSxuLnJpLnZhZGQocyxuLnJpKSxuLnJpLnZzdWIoci5wb3NpdGlvbixuLnJpKSx1LnJlbGVhc2UoZCksdS5yZWxlYXNlKHApLHRoaXMucmVzdWx0LnB1c2gobiksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KG4sdGhpcy5mcmljdGlvblJlc3VsdCk7Zm9yKGxldCB0PTAsZT1vLmxlbmd0aDt0IT09ZTt0KyspdS5yZWxlYXNlKG9bdF0pO3JldHVybn1mb3IobGV0IGQ9MDtkIT09Zi5sZW5ndGg7ZCsrKXtjb25zdCBwPXUuZ2V0KCksdj11LmdldCgpO24udm11bHQoeVtmWyhkKzEpJWYubGVuZ3RoXV0scCksbi52bXVsdCh5W2ZbKGQrMiklZi5sZW5ndGhdXSx2KSxpLnZhZGQocCxwKSxpLnZhZGQodix2KTtjb25zdCB3PWRpO3YudnN1YihwLHcpO2NvbnN0IHg9cGk7dy51bml0KHgpO2NvbnN0IGc9dS5nZXQoKSxiPXUuZ2V0KCk7cy52c3ViKHAsYik7Y29uc3QgQT1iLmRvdCh4KTt4Lm11bHQoQSxnKSxnLnZhZGQocCxnKTtjb25zdCBCPXUuZ2V0KCk7aWYoZy52c3ViKHMsQiksQT4wJiZBKkE8dy5ub3JtMigpJiZCLm5vcm0yKCk8bSptKXtpZihjKXJldHVybiEwO2NvbnN0IG49dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpO2cudnN1YihpLG4ucmopLGcudnN1YihzLG4ubmkpLG4ubmkubm9ybWFsaXplKCksbi5uaS5tdWx0KG0sbi5yaSksbi5yai52YWRkKGksbi5yaiksbi5yai52c3ViKGEucG9zaXRpb24sbi5yaiksbi5yaS52YWRkKHMsbi5yaSksbi5yaS52c3ViKHIucG9zaXRpb24sbi5yaSksdGhpcy5yZXN1bHQucHVzaChuKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobix0aGlzLmZyaWN0aW9uUmVzdWx0KTtmb3IobGV0IHQ9MCxlPW8ubGVuZ3RoO3QhPT1lO3QrKyl1LnJlbGVhc2Uob1t0XSk7cmV0dXJuIHUucmVsZWFzZShwKSx1LnJlbGVhc2UodiksdS5yZWxlYXNlKGcpLHUucmVsZWFzZShCKSx2b2lkIHUucmVsZWFzZShiKX11LnJlbGVhc2UocCksdS5yZWxlYXNlKHYpLHUucmVsZWFzZShnKSx1LnJlbGVhc2UoQiksdS5yZWxlYXNlKGIpfWZvcihsZXQgdD0wLGU9by5sZW5ndGg7dCE9PWU7dCsrKXUucmVsZWFzZShvW3RdKX19fXBsYW5lQ29udmV4KHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT1iaSxkPUFpO2Quc2V0KDAsMCwxKSxvLnZtdWx0KGQsZCk7bGV0IHA9MDtjb25zdCB5PUJpO2ZvcihsZXQgbz0wO28hPT1lLnZlcnRpY2VzLmxlbmd0aDtvKyspe2lmKHUuY29weShlLnZlcnRpY2VzW29dKSxuLnZtdWx0KHUsdSksaS52YWRkKHUsdSksdS52c3ViKHMseSksZC5kb3QoeSk8PTApe2lmKGMpcmV0dXJuITA7Y29uc3Qgbz10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCksbj1FaTtkLm11bHQoZC5kb3QoeSksbiksdS52c3ViKG4sbiksbi52c3ViKHMsby5yaSksby5uaS5jb3B5KGQpLHUudnN1YihpLG8ucmopLG8ucmkudmFkZChzLG8ucmkpLG8ucmkudnN1YihyLnBvc2l0aW9uLG8ucmkpLG8ucmoudmFkZChpLG8ucmopLG8ucmoudnN1YihhLnBvc2l0aW9uLG8ucmopLHRoaXMucmVzdWx0LnB1c2gobykscCsrLHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb258fHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChvLHRoaXMuZnJpY3Rpb25SZXN1bHQpfX10aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uJiZwJiZ0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UocCl9Ym94Q29udmV4KHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7cmV0dXJuIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsPXQubWF0ZXJpYWwsdC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2U9dC5jb2xsaXNpb25SZXNwb25zZSx0aGlzLmNvbnZleENvbnZleCh0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixlLHMsaSxvLG4scixhLHQsZSxjKX1zcGhlcmVIZWlnaHRmaWVsZCh0LGUscyxpLG8sbixyLGEsbCxoLGMpe2NvbnN0IHU9ZS5kYXRhLGQ9dC5yYWRpdXMscD1lLmVsZW1lbnRTaXplLHk9V2ksbT1raTt2LnBvaW50VG9Mb2NhbEZyYW1lKGksbixzLG0pO2xldCB3PU1hdGguZmxvb3IoKG0ueC1kKS9wKS0xLGY9TWF0aC5jZWlsKChtLngrZCkvcCkrMSx4PU1hdGguZmxvb3IoKG0ueS1kKS9wKS0xLGc9TWF0aC5jZWlsKChtLnkrZCkvcCkrMTtpZihmPDB8fGc8MHx8dz51Lmxlbmd0aHx8eD51WzBdLmxlbmd0aClyZXR1cm47dzwwJiYodz0wKSxmPDAmJihmPTApLHg8MCYmKHg9MCksZzwwJiYoZz0wKSx3Pj11Lmxlbmd0aCYmKHc9dS5sZW5ndGgtMSksZj49dS5sZW5ndGgmJihmPXUubGVuZ3RoLTEpLGc+PXVbMF0ubGVuZ3RoJiYoZz11WzBdLmxlbmd0aC0xKSx4Pj11WzBdLmxlbmd0aCYmKHg9dVswXS5sZW5ndGgtMSk7Y29uc3QgYj1bXTtlLmdldFJlY3RNaW5NYXgodyx4LGYsZyxiKTtjb25zdCBBPWJbMF0sQj1iWzFdO2lmKG0uei1kPkJ8fG0ueitkPEEpcmV0dXJuO2NvbnN0IEU9dGhpcy5yZXN1bHQ7Zm9yKGxldCBsPXc7bDxmO2wrKylmb3IobGV0IGg9eDtoPGc7aCsrKXtjb25zdCB1PUUubGVuZ3RoO2xldCBkPSExO2lmKGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIobCxoLCExKSx2LnBvaW50VG9Xb3JsZEZyYW1lKGksbixlLnBpbGxhck9mZnNldCx5KSxzLmRpc3RhbmNlVG8oeSk8ZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMrdC5ib3VuZGluZ1NwaGVyZVJhZGl1cyYmKGQ9dGhpcy5zcGhlcmVDb252ZXgodCxlLnBpbGxhckNvbnZleCxzLHksbyxuLHIsYSx0LGUsYykpLGMmJmQpcmV0dXJuITA7aWYoZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihsLGgsITApLHYucG9pbnRUb1dvcmxkRnJhbWUoaSxuLGUucGlsbGFyT2Zmc2V0LHkpLHMuZGlzdGFuY2VUbyh5KTxlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyt0LmJvdW5kaW5nU3BoZXJlUmFkaXVzJiYoZD10aGlzLnNwaGVyZUNvbnZleCh0LGUucGlsbGFyQ29udmV4LHMseSxvLG4scixhLHQsZSxjKSksYyYmZClyZXR1cm4hMDtpZihFLmxlbmd0aC11PjIpcmV0dXJufX1ib3hIZWlnaHRmaWVsZCh0LGUscyxpLG8sbixyLGEsbCxoLGMpe3JldHVybiB0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbD10Lm1hdGVyaWFsLHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlPXQuY29sbGlzaW9uUmVzcG9uc2UsdGhpcy5jb252ZXhIZWlnaHRmaWVsZCh0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixlLHMsaSxvLG4scixhLHQsZSxjKX1jb252ZXhIZWlnaHRmaWVsZCh0LGUscyxpLG8sbixyLGEsbCxoLGMpe2NvbnN0IHU9ZS5kYXRhLGQ9ZS5lbGVtZW50U2l6ZSxwPXQuYm91bmRpbmdTcGhlcmVSYWRpdXMseT1qaSxtPVZpLHc9TGk7di5wb2ludFRvTG9jYWxGcmFtZShpLG4scyx3KTtsZXQgZj1NYXRoLmZsb29yKCh3LngtcCkvZCktMSx4PU1hdGguY2VpbCgody54K3ApL2QpKzEsZz1NYXRoLmZsb29yKCh3LnktcCkvZCktMSxiPU1hdGguY2VpbCgody55K3ApL2QpKzE7aWYoeDwwfHxiPDB8fGY+dS5sZW5ndGh8fGc+dVswXS5sZW5ndGgpcmV0dXJuO2Y8MCYmKGY9MCkseDwwJiYoeD0wKSxnPDAmJihnPTApLGI8MCYmKGI9MCksZj49dS5sZW5ndGgmJihmPXUubGVuZ3RoLTEpLHg+PXUubGVuZ3RoJiYoeD11Lmxlbmd0aC0xKSxiPj11WzBdLmxlbmd0aCYmKGI9dVswXS5sZW5ndGgtMSksZz49dVswXS5sZW5ndGgmJihnPXVbMF0ubGVuZ3RoLTEpO2NvbnN0IEE9W107ZS5nZXRSZWN0TWluTWF4KGYsZyx4LGIsQSk7Y29uc3QgQj1BWzBdLEU9QVsxXTtpZighKHcuei1wPkV8fHcueitwPEIpKWZvcihsZXQgbD1mO2w8eDtsKyspZm9yKGxldCBoPWc7aDxiO2grKyl7bGV0IHU9ITE7aWYoZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihsLGgsITEpLHYucG9pbnRUb1dvcmxkRnJhbWUoaSxuLGUucGlsbGFyT2Zmc2V0LHkpLHMuZGlzdGFuY2VUbyh5KTxlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyt0LmJvdW5kaW5nU3BoZXJlUmFkaXVzJiYodT10aGlzLmNvbnZleENvbnZleCh0LGUucGlsbGFyQ29udmV4LHMseSxvLG4scixhLG51bGwsbnVsbCxjLG0sbnVsbCkpLGMmJnUpcmV0dXJuITA7aWYoZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihsLGgsITApLHYucG9pbnRUb1dvcmxkRnJhbWUoaSxuLGUucGlsbGFyT2Zmc2V0LHkpLHMuZGlzdGFuY2VUbyh5KTxlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyt0LmJvdW5kaW5nU3BoZXJlUmFkaXVzJiYodT10aGlzLmNvbnZleENvbnZleCh0LGUucGlsbGFyQ29udmV4LHMseSxvLG4scixhLG51bGwsbnVsbCxjLG0sbnVsbCkpLGMmJnUpcmV0dXJuITB9fXNwaGVyZVBhcnRpY2xlKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT1xaTtpZih1LnNldCgwLDAsMSksaS52c3ViKHMsdSksdS5ub3JtMigpPD10LnJhZGl1cyp0LnJhZGl1cyl7aWYoYylyZXR1cm4hMDtjb25zdCBzPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGEscixlLHQsbCxoKTt1Lm5vcm1hbGl6ZSgpLHMucmouY29weSh1KSxzLnJqLm11bHQodC5yYWRpdXMscy5yaikscy5uaS5jb3B5KHUpLHMubmkubmVnYXRlKHMubmkpLHMucmkuc2V0KDAsMCwwKSx0aGlzLnJlc3VsdC5wdXNoKHMpLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChzLHRoaXMuZnJpY3Rpb25SZXN1bHQpfX1wbGFuZVBhcnRpY2xlKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT1TaTt1LnNldCgwLDAsMSksci5xdWF0ZXJuaW9uLnZtdWx0KHUsdSk7Y29uc3QgZD1NaTtpZihpLnZzdWIoci5wb3NpdGlvbixkKSx1LmRvdChkKTw9MCl7aWYoYylyZXR1cm4hMDtjb25zdCBzPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGEscixlLHQsbCxoKTtzLm5pLmNvcHkodSkscy5uaS5uZWdhdGUocy5uaSkscy5yaS5zZXQoMCwwLDApO2NvbnN0IG89Q2k7dS5tdWx0KHUuZG90KGkpLG8pLGkudnN1YihvLG8pLHMucmouY29weShvKSx0aGlzLnJlc3VsdC5wdXNoKHMpLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChzLHRoaXMuZnJpY3Rpb25SZXN1bHQpfX1ib3hQYXJ0aWNsZSh0LGUscyxpLG8sbixyLGEsbCxoLGMpe3JldHVybiB0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbD10Lm1hdGVyaWFsLHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlPXQuY29sbGlzaW9uUmVzcG9uc2UsdGhpcy5jb252ZXhQYXJ0aWNsZSh0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixlLHMsaSxvLG4scixhLHQsZSxjKX1jb252ZXhQYXJ0aWNsZSh0LGUscyxpLG8sbixyLGEsbCxoLGMpe2xldCB1PS0xO2NvbnN0IGQ9TmkscD1JaTtsZXQgeT1udWxsO2NvbnN0IG09UGk7aWYobS5jb3B5KGkpLG0udnN1YihzLG0pLG8uY29uanVnYXRlKFRpKSxUaS52bXVsdChtLG0pLHQucG9pbnRJc0luc2lkZShtKSl7dC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUmJnQuY29tcHV0ZVdvcmxkVmVydGljZXMocyxvKSx0LndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSYmdC5jb21wdXRlV29ybGRGYWNlTm9ybWFscyhvKTtmb3IobGV0IGU9MCxzPXQuZmFjZXMubGVuZ3RoO2UhPT1zO2UrKyl7Y29uc3Qgcz1bdC53b3JsZFZlcnRpY2VzW3QuZmFjZXNbZV1bMF1dXSxvPXQud29ybGRGYWNlTm9ybWFsc1tlXTtpLnZzdWIoc1swXSxSaSk7Y29uc3Qgbj0tby5kb3QoUmkpO2lmKG51bGw9PT15fHxNYXRoLmFicyhuKTxNYXRoLmFicyh5KSl7aWYoYylyZXR1cm4hMDt5PW4sdT1lLGQuY29weShvKX19aWYoLTEhPT11KXtjb25zdCBvPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGEscixlLHQsbCxoKTtkLm11bHQoeSxwKSxwLnZhZGQoaSxwKSxwLnZzdWIocyxwKSxvLnJqLmNvcHkocCksZC5uZWdhdGUoby5uaSksby5yaS5zZXQoMCwwLDApO2NvbnN0IG49by5yaSxjPW8ucmo7bi52YWRkKGksbiksbi52c3ViKGEucG9zaXRpb24sbiksYy52YWRkKHMsYyksYy52c3ViKHIucG9zaXRpb24sYyksdGhpcy5yZXN1bHQucHVzaChvKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobyx0aGlzLmZyaWN0aW9uUmVzdWx0KX1lbHNlIGNvbnNvbGUud2FybigiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlISIpfX1zcGhlcmVUcmltZXNoKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT1rcyxkPVdzLHA9T3MseT1fcyxtPUhzLHc9VXMsZj1Zcyx4PVZzLGc9THMsYj1aczt2LnBvaW50VG9Mb2NhbEZyYW1lKGksbixzLG0pO2NvbnN0IEE9dC5yYWRpdXM7Zi5sb3dlckJvdW5kLnNldChtLngtQSxtLnktQSxtLnotQSksZi51cHBlckJvdW5kLnNldChtLngrQSxtLnkrQSxtLnorQSksZS5nZXRUcmlhbmdsZXNJbkFBQkIoZixiKTtjb25zdCBCPWpzLEU9dC5yYWRpdXMqdC5yYWRpdXM7Zm9yKGxldCBvPTA7bzxiLmxlbmd0aDtvKyspZm9yKGxldCB1PTA7dTwzO3UrKylpZihlLmdldFZlcnRleChlLmluZGljZXNbMypiW29dK3VdLEIpLEIudnN1YihtLGcpLGcubm9ybTIoKTw9RSl7aWYoeC5jb3B5KEIpLHYucG9pbnRUb1dvcmxkRnJhbWUoaSxuLHgsQiksQi52c3ViKHMsZyksYylyZXR1cm4hMDtsZXQgbz10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7by5uaS5jb3B5KGcpLG8ubmkubm9ybWFsaXplKCksby5yaS5jb3B5KG8ubmkpLG8ucmkuc2NhbGUodC5yYWRpdXMsby5yaSksby5yaS52YWRkKHMsby5yaSksby5yaS52c3ViKHIucG9zaXRpb24sby5yaSksby5yai5jb3B5KEIpLG8ucmoudnN1YihhLnBvc2l0aW9uLG8ucmopLHRoaXMucmVzdWx0LnB1c2gobyksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KG8sdGhpcy5mcmljdGlvblJlc3VsdCl9Zm9yKGxldCBvPTA7bzxiLmxlbmd0aDtvKyspZm9yKGxldCBmPTA7ZjwzO2YrKyl7ZS5nZXRWZXJ0ZXgoZS5pbmRpY2VzWzMqYltvXStmXSx1KSxlLmdldFZlcnRleChlLmluZGljZXNbMypiW29dKyhmKzEpJTNdLGQpLGQudnN1Yih1LHApLG0udnN1YihkLHcpO2NvbnN0IHg9dy5kb3QocCk7bS52c3ViKHUsdyk7bGV0IGc9dy5kb3QocCk7aWYoZz4wJiZ4PDApe2lmKG0udnN1Yih1LHcpLHkuY29weShwKSx5Lm5vcm1hbGl6ZSgpLGc9dy5kb3QoeSkseS5zY2FsZShnLHcpLHcudmFkZCh1LHcpLHcuZGlzdGFuY2VUbyhtKTx0LnJhZGl1cyl7aWYoYylyZXR1cm4hMDtjb25zdCBvPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTt3LnZzdWIobSxvLm5pKSxvLm5pLm5vcm1hbGl6ZSgpLG8ubmkuc2NhbGUodC5yYWRpdXMsby5yaSksby5yaS52YWRkKHMsby5yaSksby5yaS52c3ViKHIucG9zaXRpb24sby5yaSksdi5wb2ludFRvV29ybGRGcmFtZShpLG4sdyx3KSx3LnZzdWIoYS5wb3NpdGlvbixvLnJqKSx2LnZlY3RvclRvV29ybGRGcmFtZShuLG8ubmksby5uaSksdi52ZWN0b3JUb1dvcmxkRnJhbWUobixvLnJpLG8ucmkpLHRoaXMucmVzdWx0LnB1c2gobyksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KG8sdGhpcy5mcmljdGlvblJlc3VsdCl9fX1jb25zdCB6PUdzLEY9RHMsUz1YcyxNPUlzO2ZvcihsZXQgbz0wLHU9Yi5sZW5ndGg7byE9PXU7bysrKXtlLmdldFRyaWFuZ2xlVmVydGljZXMoYltvXSx6LEYsUyksZS5nZXROb3JtYWwoYltvXSxNKSxtLnZzdWIoeix3KTtsZXQgdT13LmRvdChNKTtpZihNLnNjYWxlKHUsdyksbS52c3ViKHcsdyksdT13LmRpc3RhbmNlVG8obSksWS5wb2ludEluVHJpYW5nbGUodyx6LEYsUykmJnU8dC5yYWRpdXMpe2lmKGMpcmV0dXJuITA7bGV0IG89dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpO3cudnN1YihtLG8ubmkpLG8ubmkubm9ybWFsaXplKCksby5uaS5zY2FsZSh0LnJhZGl1cyxvLnJpKSxvLnJpLnZhZGQocyxvLnJpKSxvLnJpLnZzdWIoci5wb3NpdGlvbixvLnJpKSx2LnBvaW50VG9Xb3JsZEZyYW1lKGksbix3LHcpLHcudnN1YihhLnBvc2l0aW9uLG8ucmopLHYudmVjdG9yVG9Xb3JsZEZyYW1lKG4sby5uaSxvLm5pKSx2LnZlY3RvclRvV29ybGRGcmFtZShuLG8ucmksby5yaSksdGhpcy5yZXN1bHQucHVzaChvKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobyx0aGlzLmZyaWN0aW9uUmVzdWx0KX19Yi5sZW5ndGg9MH1wbGFuZVRyaW1lc2godCxlLHMsbyxuLHIsYSxsLGgsYyx1KXtjb25zdCBkPW5ldyBpLHA9UHM7cC5zZXQoMCwwLDEpLG4udm11bHQocCxwKTtmb3IobGV0IG49MDtuPGUudmVydGljZXMubGVuZ3RoLzM7bisrKXtlLmdldFZlcnRleChuLGQpO2NvbnN0IHk9bmV3IGk7eS5jb3B5KGQpLHYucG9pbnRUb1dvcmxkRnJhbWUobyxyLHksZCk7Y29uc3QgbT1OcztpZihkLnZzdWIocyxtKSxwLmRvdChtKTw9MCl7aWYodSlyZXR1cm4hMDtjb25zdCBzPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGEsbCx0LGUsaCxjKTtzLm5pLmNvcHkocCk7Y29uc3QgaT1ScztwLnNjYWxlKG0uZG90KHApLGkpLGQudnN1YihpLGkpLHMucmkuY29weShpKSxzLnJpLnZzdWIoYS5wb3NpdGlvbixzLnJpKSxzLnJqLmNvcHkoZCkscy5yai52c3ViKGwucG9zaXRpb24scy5yaiksdGhpcy5yZXN1bHQucHVzaChzKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qocyx0aGlzLmZyaWN0aW9uUmVzdWx0KX19fX1jb25zdCB6cz1uZXcgaSxGcz1uZXcgaSxTcz1uZXcgaSxNcz1uZXcgaSxDcz1uZXcgaSxxcz1uZXcgZCxUcz1uZXcgZDtFcy5wcm90b3R5cGVbbHNdPUVzLnByb3RvdHlwZS5ib3hCb3gsRXMucHJvdG90eXBlW3lzXT1Fcy5wcm90b3R5cGUuYm94Q29udmV4LEVzLnByb3RvdHlwZVtnc109RXMucHJvdG90eXBlLmJveFBhcnRpY2xlLEVzLnByb3RvdHlwZVtyc109RXMucHJvdG90eXBlLnNwaGVyZVNwaGVyZTtjb25zdCBQcz1uZXcgaSxOcz1uZXcgaSxScz1uZXcgaTtFcy5wcm90b3R5cGVbQnNdPUVzLnByb3RvdHlwZS5wbGFuZVRyaW1lc2g7Y29uc3QgSXM9bmV3IGksTHM9bmV3IGksanM9bmV3IGksVnM9bmV3IGksa3M9bmV3IGksV3M9bmV3IGksT3M9bmV3IGksX3M9bmV3IGksSHM9bmV3IGksVXM9bmV3IGksR3M9bmV3IGksRHM9bmV3IGksWHM9bmV3IGksWXM9bmV3IGEsWnM9W107RXMucHJvdG90eXBlW0FzXT1Fcy5wcm90b3R5cGUuc3BoZXJlVHJpbWVzaDtjb25zdCBLcz1uZXcgaSxRcz1uZXcgaTtFcy5wcm90b3R5cGVbYXNdPUVzLnByb3RvdHlwZS5zcGhlcmVQbGFuZTtjb25zdCBKcz1uZXcgaSwkcz1uZXcgaSx0aT1uZXcgaTtmdW5jdGlvbiBlaSh0LGUscyl7bGV0IGk9bnVsbDtjb25zdCBvPXQubGVuZ3RoO2ZvcihsZXQgbj0wO24hPT1vO24rKyl7Y29uc3Qgcj10W25dLGE9SnM7dFsobisxKSVvXS52c3ViKHIsYSk7Y29uc3QgbD0kczthLmNyb3NzKGUsbCk7Y29uc3QgaD10aTtzLnZzdWIocixoKTtjb25zdCBjPWwuZG90KGgpO2lmKCEobnVsbD09PWl8fGM+MCYmITA9PT1pfHxjPD0wJiYhMT09PWkpKXJldHVybiExO251bGw9PT1pJiYoaT1jPjApfXJldHVybiEwfWNvbnN0IHNpPW5ldyBpLGlpPW5ldyBpLG9pPW5ldyBpLG5pPW5ldyBpLHJpPVtuZXcgaSxuZXcgaSxuZXcgaSxuZXcgaSxuZXcgaSxuZXcgaV0sYWk9bmV3IGksbGk9bmV3IGksaGk9bmV3IGksY2k9bmV3IGk7RXMucHJvdG90eXBlW2hzXT1Fcy5wcm90b3R5cGUuc3BoZXJlQm94O2NvbnN0IHVpPW5ldyBpLGRpPW5ldyBpLHBpPW5ldyBpLHlpPW5ldyBpLG1pPW5ldyBpLHZpPW5ldyBpLHdpPW5ldyBpLGZpPW5ldyBpLHhpPW5ldyBpLGdpPW5ldyBpO0VzLnByb3RvdHlwZVtkc109RXMucHJvdG90eXBlLnNwaGVyZUNvbnZleCxFcy5wcm90b3R5cGVbY3NdPUVzLnByb3RvdHlwZS5wbGFuZUJveDtjb25zdCBiaT1uZXcgaSxBaT1uZXcgaSxCaT1uZXcgaSxFaT1uZXcgaTtFcy5wcm90b3R5cGVbcHNdPUVzLnByb3RvdHlwZS5wbGFuZUNvbnZleDtjb25zdCB6aT1uZXcgaSxGaT1uZXcgaTtFcy5wcm90b3R5cGVbdXNdPUVzLnByb3RvdHlwZS5jb252ZXhDb252ZXg7Y29uc3QgU2k9bmV3IGksTWk9bmV3IGksQ2k9bmV3IGk7RXMucHJvdG90eXBlW3hzXT1Fcy5wcm90b3R5cGUucGxhbmVQYXJ0aWNsZTtjb25zdCBxaT1uZXcgaTtFcy5wcm90b3R5cGVbZnNdPUVzLnByb3RvdHlwZS5zcGhlcmVQYXJ0aWNsZTtjb25zdCBUaT1uZXcgZCxQaT1uZXcgaSxOaT1uZXcgaSxSaT1uZXcgaSxJaT1uZXcgaTtFcy5wcm90b3R5cGVbYnNdPUVzLnByb3RvdHlwZS5jb252ZXhQYXJ0aWNsZSxFcy5wcm90b3R5cGVbdnNdPUVzLnByb3RvdHlwZS5ib3hIZWlnaHRmaWVsZDtjb25zdCBMaT1uZXcgaSxqaT1uZXcgaSxWaT1bMF07RXMucHJvdG90eXBlW3dzXT1Fcy5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQ7Y29uc3Qga2k9bmV3IGksV2k9bmV3IGk7RXMucHJvdG90eXBlW21zXT1Fcy5wcm90b3R5cGUuc3BoZXJlSGVpZ2h0ZmllbGQ7Y2xhc3MgT2l7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnQ9W10sdGhpcy5wcmV2aW91cz1bXX1nZXRLZXkodCxlKXtpZihlPHQpe2NvbnN0IHM9ZTtlPXQsdD1zfXJldHVybiB0PDwxNnxlfXNldCh0LGUpe2NvbnN0IHM9dGhpcy5nZXRLZXkodCxlKSxpPXRoaXMuY3VycmVudDtsZXQgbz0wO2Zvcig7cz5pW29dOylvKys7aWYocyE9PWlbb10pe2ZvcihsZXQgdD1pLmxlbmd0aC0xO3Q+PW87dC0tKWlbdCsxXT1pW3RdO2lbb109c319dGljaygpe2NvbnN0IHQ9dGhpcy5jdXJyZW50O3RoaXMuY3VycmVudD10aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXM9dCx0aGlzLmN1cnJlbnQubGVuZ3RoPTB9Z2V0RGlmZih0LGUpe2NvbnN0IHM9dGhpcy5jdXJyZW50LGk9dGhpcy5wcmV2aW91cyxvPXMubGVuZ3RoLG49aS5sZW5ndGg7bGV0IHI9MDtmb3IobGV0IGU9MDtlPG87ZSsrKXtsZXQgbz0hMTtjb25zdCBuPXNbZV07Zm9yKDtuPmlbcl07KXIrKztvPW49PT1pW3JdLG98fF9pKHQsbil9cj0wO2ZvcihsZXQgdD0wO3Q8bjt0Kyspe2xldCBvPSExO2NvbnN0IG49aVt0XTtmb3IoO24+c1tyXTspcisrO289c1tyXT09PW4sb3x8X2koZSxuKX19fWZ1bmN0aW9uIF9pKHQsZSl7dC5wdXNoKCg0Mjk0OTAxNzYwJmUpPj4xNiw2NTUzNSZlKX1jbGFzcyBIaXtjb25zdHJ1Y3Rvcigpe3RoaXMuZGF0YT17a2V5czpbXX19Z2V0KHQsZSl7aWYodD5lKXtjb25zdCBzPWU7ZT10LHQ9c31yZXR1cm4gdGhpcy5kYXRhW3QrIi0iK2VdfXNldCh0LGUscyl7aWYodD5lKXtjb25zdCBzPWU7ZT10LHQ9c31jb25zdCBpPXQrIi0iK2U7dGhpcy5nZXQodCxlKXx8dGhpcy5kYXRhLmtleXMucHVzaChpKSx0aGlzLmRhdGFbaV09c31yZXNldCgpe2NvbnN0IHQ9dGhpcy5kYXRhLGU9dC5rZXlzO2Zvcig7ZS5sZW5ndGg+MDspe2RlbGV0ZSB0W2UucG9wKCldfX19Y2xhc3MgVWkgZXh0ZW5kcyB1e2NvbnN0cnVjdG9yKHQ9e30pe3N1cGVyKCksdGhpcy5kdD0tMSx0aGlzLmFsbG93U2xlZXA9ISF0LmFsbG93U2xlZXAsdGhpcy5jb250YWN0cz1bXSx0aGlzLmZyaWN0aW9uRXF1YXRpb25zPVtdLHRoaXMucXVhdE5vcm1hbGl6ZVNraXA9dm9pZCAwIT09dC5xdWF0Tm9ybWFsaXplU2tpcD90LnF1YXROb3JtYWxpemVTa2lwOjAsdGhpcy5xdWF0Tm9ybWFsaXplRmFzdD12b2lkIDAhPT10LnF1YXROb3JtYWxpemVGYXN0JiZ0LnF1YXROb3JtYWxpemVGYXN0LHRoaXMudGltZT0wLHRoaXMuc3RlcG51bWJlcj0wLHRoaXMuZGVmYXVsdF9kdD0xLzYwLHRoaXMubmV4dElkPTAsdGhpcy5ncmF2aXR5PW5ldyBpLHQuZ3Jhdml0eSYmdGhpcy5ncmF2aXR5LmNvcHkodC5ncmF2aXR5KSx0aGlzLmJyb2FkcGhhc2U9dm9pZCAwIT09dC5icm9hZHBoYXNlP3QuYnJvYWRwaGFzZTpuZXcgRCx0aGlzLmJvZGllcz1bXSx0aGlzLmhhc0FjdGl2ZUJvZGllcz0hMSx0aGlzLnNvbHZlcj12b2lkIDAhPT10LnNvbHZlcj90LnNvbHZlcjpuZXcgZXMsdGhpcy5jb25zdHJhaW50cz1bXSx0aGlzLm5hcnJvd3BoYXNlPW5ldyBFcyh0aGlzKSx0aGlzLmNvbGxpc2lvbk1hdHJpeD1uZXcgYyx0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzPW5ldyBjLHRoaXMuYm9keU92ZXJsYXBLZWVwZXI9bmV3IE9pLHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyPW5ldyBPaSx0aGlzLm1hdGVyaWFscz1bXSx0aGlzLmNvbnRhY3RtYXRlcmlhbHM9W10sdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZT1uZXcgSGksdGhpcy5kZWZhdWx0TWF0ZXJpYWw9bmV3IGxlKCJkZWZhdWx0IiksdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsPW5ldyBhZSh0aGlzLmRlZmF1bHRNYXRlcmlhbCx0aGlzLmRlZmF1bHRNYXRlcmlhbCx7ZnJpY3Rpb246LjMscmVzdGl0dXRpb246MH0pLHRoaXMuZG9Qcm9maWxpbmc9ITEsdGhpcy5wcm9maWxlPXtzb2x2ZTowLG1ha2VDb250YWN0Q29uc3RyYWludHM6MCxicm9hZHBoYXNlOjAsaW50ZWdyYXRlOjAsbmFycm93cGhhc2U6MH0sdGhpcy5hY2N1bXVsYXRvcj0wLHRoaXMuc3Vic3lzdGVtcz1bXSx0aGlzLmFkZEJvZHlFdmVudD17dHlwZToiYWRkQm9keSIsYm9keTpudWxsfSx0aGlzLnJlbW92ZUJvZHlFdmVudD17dHlwZToicmVtb3ZlQm9keSIsYm9keTpudWxsfSx0aGlzLmlkVG9Cb2R5TWFwPXt9LHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKX1nZXRDb250YWN0TWF0ZXJpYWwodCxlKXtyZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQodC5pZCxlLmlkKX1udW1PYmplY3RzKCl7cmV0dXJuIHRoaXMuYm9kaWVzLmxlbmd0aH1jb2xsaXNpb25NYXRyaXhUaWNrKCl7Y29uc3QgdD10aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzO3RoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXM9dGhpcy5jb2xsaXNpb25NYXRyaXgsdGhpcy5jb2xsaXNpb25NYXRyaXg9dCx0aGlzLmNvbGxpc2lvbk1hdHJpeC5yZXNldCgpLHRoaXMuYm9keU92ZXJsYXBLZWVwZXIudGljaygpLHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyLnRpY2soKX1hZGRDb25zdHJhaW50KHQpe3RoaXMuY29uc3RyYWludHMucHVzaCh0KX1yZW1vdmVDb25zdHJhaW50KHQpe2NvbnN0IGU9dGhpcy5jb25zdHJhaW50cy5pbmRleE9mKHQpOy0xIT09ZSYmdGhpcy5jb25zdHJhaW50cy5zcGxpY2UoZSwxKX1yYXlUZXN0KHQsZSxzKXtzIGluc3RhbmNlb2YgWD90aGlzLnJheWNhc3RDbG9zZXN0KHQsZSx7c2tpcEJhY2tmYWNlczohMH0scyk6dGhpcy5yYXljYXN0QWxsKHQsZSx7c2tpcEJhY2tmYWNlczohMH0scyl9cmF5Y2FzdEFsbCh0LGUscz17fSxpKXtyZXR1cm4gcy5tb2RlPVkuQUxMLHMuZnJvbT10LHMudG89ZSxzLmNhbGxiYWNrPWksR2kuaW50ZXJzZWN0V29ybGQodGhpcyxzKX1yYXljYXN0QW55KHQsZSxzPXt9LGkpe3JldHVybiBzLm1vZGU9WS5BTlkscy5mcm9tPXQscy50bz1lLHMucmVzdWx0PWksR2kuaW50ZXJzZWN0V29ybGQodGhpcyxzKX1yYXljYXN0Q2xvc2VzdCh0LGUscz17fSxpKXtyZXR1cm4gcy5tb2RlPVkuQ0xPU0VTVCxzLmZyb209dCxzLnRvPWUscy5yZXN1bHQ9aSxHaS5pbnRlcnNlY3RXb3JsZCh0aGlzLHMpfWFkZCh0KXt0aGlzLmJvZGllcy5pbmNsdWRlcyh0KXx8KHQuaW5kZXg9dGhpcy5ib2RpZXMubGVuZ3RoLHRoaXMuYm9kaWVzLnB1c2godCksdC53b3JsZD10aGlzLHQuaW5pdFBvc2l0aW9uLmNvcHkodC5wb3NpdGlvbiksdC5pbml0VmVsb2NpdHkuY29weSh0LnZlbG9jaXR5KSx0LnRpbWVMYXN0U2xlZXB5PXRoaXMudGltZSx0IGluc3RhbmNlb2YgUyYmKHQuaW5pdEFuZ3VsYXJWZWxvY2l0eS5jb3B5KHQuYW5ndWxhclZlbG9jaXR5KSx0LmluaXRRdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKSksdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyh0aGlzLmJvZGllcy5sZW5ndGgpLHRoaXMuYWRkQm9keUV2ZW50LmJvZHk9dCx0aGlzLmlkVG9Cb2R5TWFwW3QuaWRdPXQsdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuYWRkQm9keUV2ZW50KSl9cmVtb3ZlKHQpe3Qud29ybGQ9bnVsbDtjb25zdCBlPXRoaXMuYm9kaWVzLmxlbmd0aC0xLHM9dGhpcy5ib2RpZXMsaT1zLmluZGV4T2YodCk7aWYoLTEhPT1pKXtzLnNwbGljZShpLDEpO2ZvcihsZXQgdD0wO3QhPT1zLmxlbmd0aDt0Kyspc1t0XS5pbmRleD10O3RoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHMoZSksdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keT10LGRlbGV0ZSB0aGlzLmlkVG9Cb2R5TWFwW3QuaWRdLHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCl9fWdldEJvZHlCeUlkKHQpe3JldHVybiB0aGlzLmlkVG9Cb2R5TWFwW3RdfWdldFNoYXBlQnlJZCh0KXtjb25zdCBlPXRoaXMuYm9kaWVzO2ZvcihsZXQgcz0wLGk9ZS5sZW5ndGg7czxpO3MrKyl7Y29uc3QgaT1lW3NdLnNoYXBlcztmb3IobGV0IGU9MCxzPWkubGVuZ3RoO2U8cztlKyspe2NvbnN0IHM9aVtlXTtpZihzLmlkPT09dClyZXR1cm4gc319fWFkZE1hdGVyaWFsKHQpe3RoaXMubWF0ZXJpYWxzLnB1c2godCl9YWRkQ29udGFjdE1hdGVyaWFsKHQpe3RoaXMuY29udGFjdG1hdGVyaWFscy5wdXNoKHQpLHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KHQubWF0ZXJpYWxzWzBdLmlkLHQubWF0ZXJpYWxzWzFdLmlkLHQpfXN0ZXAodCxlPTAscz0xMCl7aWYoMD09PWUpdGhpcy5pbnRlcm5hbFN0ZXAodCksdGhpcy50aW1lKz10O2Vsc2V7dGhpcy5hY2N1bXVsYXRvcis9ZTtsZXQgaT0wO2Zvcig7dGhpcy5hY2N1bXVsYXRvcj49dCYmaTxzOyl0aGlzLmludGVybmFsU3RlcCh0KSx0aGlzLmFjY3VtdWxhdG9yLT10LGkrKztjb25zdCBvPXRoaXMuYWNjdW11bGF0b3IldC90O2ZvcihsZXQgdD0wO3QhPT10aGlzLmJvZGllcy5sZW5ndGg7dCsrKXtjb25zdCBlPXRoaXMuYm9kaWVzW3RdO2UucHJldmlvdXNQb3NpdGlvbi5sZXJwKGUucG9zaXRpb24sbyxlLmludGVycG9sYXRlZFBvc2l0aW9uKSxlLnByZXZpb3VzUXVhdGVybmlvbi5zbGVycChlLnF1YXRlcm5pb24sbyxlLmludGVycG9sYXRlZFF1YXRlcm5pb24pLGUucHJldmlvdXNRdWF0ZXJuaW9uLm5vcm1hbGl6ZSgpfXRoaXMudGltZSs9ZX19aW50ZXJuYWxTdGVwKHQpe3RoaXMuZHQ9dDtjb25zdCBlPXRoaXMuY29udGFjdHMscz1RaSxpPUppLG89dGhpcy5udW1PYmplY3RzKCksbj10aGlzLmJvZGllcyxyPXRoaXMuc29sdmVyLGE9dGhpcy5ncmF2aXR5LGw9dGhpcy5kb1Byb2ZpbGluZyxoPXRoaXMucHJvZmlsZSxjPVMuRFlOQU1JQztsZXQgdT0tMS8wO2NvbnN0IGQ9dGhpcy5jb25zdHJhaW50cyxwPUtpLHk9KGEubm9ybSgpLGEueCksbT1hLnksdj1hLno7bGV0IHc9MDtmb3IobCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpLHc9MDt3IT09bzt3Kyspe2NvbnN0IHQ9blt3XTtpZih0LnR5cGU9PT1jKXtjb25zdCBlPXQuZm9yY2Uscz10Lm1hc3M7ZS54Kz1zKnksZS55Kz1zKm0sZS56Kz1zKnZ9fWZvcihsZXQgdD0wLGU9dGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDt0IT09ZTt0KyspdGhpcy5zdWJzeXN0ZW1zW3RdLnVwZGF0ZSgpO2wmJih1PXBlcmZvcm1hbmNlLm5vdygpKSxzLmxlbmd0aD0wLGkubGVuZ3RoPTAsdGhpcy5icm9hZHBoYXNlLmNvbGxpc2lvblBhaXJzKHRoaXMscyxpKSxsJiYoaC5icm9hZHBoYXNlPXBlcmZvcm1hbmNlLm5vdygpLXUpO2xldCBmPWQubGVuZ3RoO2Zvcih3PTA7dyE9PWY7dysrKXtjb25zdCB0PWRbd107aWYoIXQuY29sbGlkZUNvbm5lY3RlZClmb3IobGV0IGU9cy5sZW5ndGgtMTtlPj0wO2UtPTEpKHQuYm9keUE9PT1zW2VdJiZ0LmJvZHlCPT09aVtlXXx8dC5ib2R5Qj09PXNbZV0mJnQuYm9keUE9PT1pW2VdKSYmKHMuc3BsaWNlKGUsMSksaS5zcGxpY2UoZSwxKSl9dGhpcy5jb2xsaXNpb25NYXRyaXhUaWNrKCksbCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpO2NvbnN0IHg9WmksZz1lLmxlbmd0aDtmb3Iodz0wO3chPT1nO3crKyl4LnB1c2goZVt3XSk7ZS5sZW5ndGg9MDtjb25zdCBiPXRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO2Zvcih3PTA7dyE9PWI7dysrKXAucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW3ddKTtmb3IodGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg9MCx0aGlzLm5hcnJvd3BoYXNlLmdldENvbnRhY3RzKHMsaSx0aGlzLGUseCx0aGlzLmZyaWN0aW9uRXF1YXRpb25zLHApLGwmJihoLm5hcnJvd3BoYXNlPXBlcmZvcm1hbmNlLm5vdygpLXUpLGwmJih1PXBlcmZvcm1hbmNlLm5vdygpKSx3PTA7dzx0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDt3Kyspci5hZGRFcXVhdGlvbih0aGlzLmZyaWN0aW9uRXF1YXRpb25zW3ddKTtjb25zdCBBPWUubGVuZ3RoO2ZvcihsZXQgdD0wO3QhPT1BO3QrKyl7Y29uc3Qgcz1lW3RdLGk9cy5iaSxvPXMuYmosbj1zLnNpLGE9cy5zajtsZXQgbDtsPWkubWF0ZXJpYWwmJm8ubWF0ZXJpYWwmJnRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKGkubWF0ZXJpYWwsby5tYXRlcmlhbCl8fHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtsZXQgaD1sLmZyaWN0aW9uO2lmKGkubWF0ZXJpYWwmJm8ubWF0ZXJpYWwmJihpLm1hdGVyaWFsLmZyaWN0aW9uPj0wJiZvLm1hdGVyaWFsLmZyaWN0aW9uPj0wJiYoaD1pLm1hdGVyaWFsLmZyaWN0aW9uKm8ubWF0ZXJpYWwuZnJpY3Rpb24pLGkubWF0ZXJpYWwucmVzdGl0dXRpb24+PTAmJm8ubWF0ZXJpYWwucmVzdGl0dXRpb24+PTAmJihzLnJlc3RpdHV0aW9uPWkubWF0ZXJpYWwucmVzdGl0dXRpb24qby5tYXRlcmlhbC5yZXN0aXR1dGlvbikpLHIuYWRkRXF1YXRpb24ocyksaS5hbGxvd1NsZWVwJiZpLnR5cGU9PT1TLkRZTkFNSUMmJmkuc2xlZXBTdGF0ZT09PVMuU0xFRVBJTkcmJm8uc2xlZXBTdGF0ZT09PVMuQVdBS0UmJm8udHlwZSE9PVMuU1RBVElDKXtvLnZlbG9jaXR5Lm5vcm0yKCkrby5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKT49MipvLnNsZWVwU3BlZWRMaW1pdCoqMiYmKGkud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZT0hMCl9aWYoby5hbGxvd1NsZWVwJiZvLnR5cGU9PT1TLkRZTkFNSUMmJm8uc2xlZXBTdGF0ZT09PVMuU0xFRVBJTkcmJmkuc2xlZXBTdGF0ZT09PVMuQVdBS0UmJmkudHlwZSE9PVMuU1RBVElDKXtpLnZlbG9jaXR5Lm5vcm0yKCkraS5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKT49MippLnNsZWVwU3BlZWRMaW1pdCoqMiYmKG8ud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZT0hMCl9dGhpcy5jb2xsaXNpb25NYXRyaXguc2V0KGksbywhMCksdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cy5nZXQoaSxvKXx8KFlpLmJvZHk9byxZaS5jb250YWN0PXMsaS5kaXNwYXRjaEV2ZW50KFlpKSxZaS5ib2R5PWksby5kaXNwYXRjaEV2ZW50KFlpKSksdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoaS5pZCxvLmlkKSx0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQobi5pZCxhLmlkKX1mb3IodGhpcy5lbWl0Q29udGFjdEV2ZW50cygpLGwmJihoLm1ha2VDb250YWN0Q29uc3RyYWludHM9cGVyZm9ybWFuY2Uubm93KCktdSx1PXBlcmZvcm1hbmNlLm5vdygpKSx3PTA7dyE9PW87dysrKXtjb25zdCB0PW5bd107dC53YWtlVXBBZnRlck5hcnJvd3BoYXNlJiYodC53YWtlVXAoKSx0Lndha2VVcEFmdGVyTmFycm93cGhhc2U9ITEpfWZvcihmPWQubGVuZ3RoLHc9MDt3IT09Zjt3Kyspe2NvbnN0IHQ9ZFt3XTt0LnVwZGF0ZSgpO2ZvcihsZXQgZT0wLHM9dC5lcXVhdGlvbnMubGVuZ3RoO2UhPT1zO2UrKyl7Y29uc3Qgcz10LmVxdWF0aW9uc1tlXTtyLmFkZEVxdWF0aW9uKHMpfX1yLnNvbHZlKHQsdGhpcyksbCYmKGguc29sdmU9cGVyZm9ybWFuY2Uubm93KCktdSksci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtjb25zdCBCPU1hdGgucG93O2Zvcih3PTA7dyE9PW87dysrKXtjb25zdCBlPW5bd107aWYoZS50eXBlJmMpe2NvbnN0IHM9QigxLWUubGluZWFyRGFtcGluZyx0KSxpPWUudmVsb2NpdHk7aS5tdWx0KHMsaSk7Y29uc3Qgbz1lLmFuZ3VsYXJWZWxvY2l0eTtpZihvKXtjb25zdCBzPUIoMS1lLmFuZ3VsYXJEYW1waW5nLHQpO28ubXVsdChzLG8pfX19Zm9yKHRoaXMuZGlzcGF0Y2hFdmVudChYaSksdz0wO3chPT1vO3crKyl7Y29uc3QgdD1uW3ddO3QucHJlU3RlcCYmdC5wcmVTdGVwLmNhbGwodCl9bCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpO2NvbnN0IEU9dGhpcy5zdGVwbnVtYmVyJSh0aGlzLnF1YXROb3JtYWxpemVTa2lwKzEpPT0wLHo9dGhpcy5xdWF0Tm9ybWFsaXplRmFzdDtmb3Iodz0wO3chPT1vO3crKyluW3ddLmludGVncmF0ZSh0LEUseik7Zm9yKHRoaXMuY2xlYXJGb3JjZXMoKSx0aGlzLmJyb2FkcGhhc2UuZGlydHk9ITAsbCYmKGguaW50ZWdyYXRlPXBlcmZvcm1hbmNlLm5vdygpLXUpLHRoaXMudGltZSs9dCx0aGlzLnN0ZXBudW1iZXIrPTEsdGhpcy5kaXNwYXRjaEV2ZW50KERpKSx3PTA7dyE9PW87dysrKXtjb25zdCB0PW5bd10sZT10LnBvc3RTdGVwO2UmJmUuY2FsbCh0KX1sZXQgRj0hMDtpZih0aGlzLmFsbG93U2xlZXApZm9yKEY9ITEsdz0wO3chPT1vO3crKyl7Y29uc3QgdD1uW3ddO3Quc2xlZXBUaWNrKHRoaXMudGltZSksdC5zbGVlcFN0YXRlIT09Uy5TTEVFUElORyYmKEY9ITApfXRoaXMuaGFzQWN0aXZlQm9kaWVzPUZ9Y2xlYXJGb3JjZXMoKXtjb25zdCB0PXRoaXMuYm9kaWVzLGU9dC5sZW5ndGg7Zm9yKGxldCBzPTA7cyE9PWU7cysrKXtjb25zdCBlPXRbc107ZS5mb3JjZSxlLnRvcnF1ZTtlLmZvcmNlLnNldCgwLDAsMCksZS50b3JxdWUuc2V0KDAsMCwwKX19fW5ldyBhO2NvbnN0IEdpPW5ldyBZO2lmKFVpLnByb3RvdHlwZS5hZGRCb2R5PVVpLnByb3RvdHlwZS5hZGQsVWkucHJvdG90eXBlLnJlbW92ZUJvZHk9VWkucHJvdG90eXBlLnJlbW92ZSwidW5kZWZpbmVkIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYocGVyZm9ybWFuY2U9e30pLCFwZXJmb3JtYW5jZS5ub3cpe2xldCB0PURhdGUubm93KCk7cGVyZm9ybWFuY2UudGltaW5nJiZwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0JiYodD1wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSxwZXJmb3JtYW5jZS5ub3c9KCk9PkRhdGUubm93KCktdH1jb25zdCBEaT17dHlwZToicG9zdFN0ZXAifSxYaT17dHlwZToicHJlU3RlcCJ9LFlpPXt0eXBlOlMuQ09MTElERV9FVkVOVF9OQU1FLGJvZHk6bnVsbCxjb250YWN0Om51bGx9LFppPVtdLEtpPVtdLFFpPVtdLEppPVtdO1VpLnByb3RvdHlwZS5lbWl0Q29udGFjdEV2ZW50cz0oKCk9Pntjb25zdCB0PVtdLGU9W10scz17dHlwZToiYmVnaW5Db250YWN0Iixib2R5QTpudWxsLGJvZHlCOm51bGx9LGk9e3R5cGU6ImVuZENvbnRhY3QiLGJvZHlBOm51bGwsYm9keUI6bnVsbH0sbz17dHlwZToiYmVnaW5TaGFwZUNvbnRhY3QiLGJvZHlBOm51bGwsYm9keUI6bnVsbCxzaGFwZUE6bnVsbCxzaGFwZUI6bnVsbH0sbj17dHlwZToiZW5kU2hhcGVDb250YWN0Iixib2R5QTpudWxsLGJvZHlCOm51bGwsc2hhcGVBOm51bGwsc2hhcGVCOm51bGx9O3JldHVybiBmdW5jdGlvbigpe2NvbnN0IHI9dGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCJiZWdpbkNvbnRhY3QiKSxhPXRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcigiZW5kQ29udGFjdCIpO2lmKChyfHxhKSYmdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKHQsZSkscil7Zm9yKGxldCBlPTAsaT10Lmxlbmd0aDtlPGk7ZSs9MilzLmJvZHlBPXRoaXMuZ2V0Qm9keUJ5SWQodFtlXSkscy5ib2R5Qj10aGlzLmdldEJvZHlCeUlkKHRbZSsxXSksdGhpcy5kaXNwYXRjaEV2ZW50KHMpO3MuYm9keUE9cy5ib2R5Qj1udWxsfWlmKGEpe2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzO3QrPTIpaS5ib2R5QT10aGlzLmdldEJvZHlCeUlkKGVbdF0pLGkuYm9keUI9dGhpcy5nZXRCb2R5QnlJZChlW3QrMV0pLHRoaXMuZGlzcGF0Y2hFdmVudChpKTtpLmJvZHlBPWkuYm9keUI9bnVsbH10Lmxlbmd0aD1lLmxlbmd0aD0wO2NvbnN0IGw9dGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCJiZWdpblNoYXBlQ29udGFjdCIpLGg9dGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCJlbmRTaGFwZUNvbnRhY3QiKTtpZigobHx8aCkmJnRoaXMuc2hhcGVPdmVybGFwS2VlcGVyLmdldERpZmYodCxlKSxsKXtmb3IobGV0IGU9MCxzPXQubGVuZ3RoO2U8cztlKz0yKXtjb25zdCBzPXRoaXMuZ2V0U2hhcGVCeUlkKHRbZV0pLGk9dGhpcy5nZXRTaGFwZUJ5SWQodFtlKzFdKTtvLnNoYXBlQT1zLG8uc2hhcGVCPWksby5ib2R5QT1zLmJvZHksby5ib2R5Qj1pLmJvZHksdGhpcy5kaXNwYXRjaEV2ZW50KG8pfW8uYm9keUE9by5ib2R5Qj1vLnNoYXBlQT1vLnNoYXBlQj1udWxsfWlmKGgpe2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzO3QrPTIpe2NvbnN0IHM9dGhpcy5nZXRTaGFwZUJ5SWQoZVt0XSksaT10aGlzLmdldFNoYXBlQnlJZChlW3QrMV0pO24uc2hhcGVBPXMsbi5zaGFwZUI9aSxuLmJvZHlBPXMuYm9keSxuLmJvZHlCPWkuYm9keSx0aGlzLmRpc3BhdGNoRXZlbnQobil9bi5ib2R5QT1uLmJvZHlCPW4uc2hhcGVBPW4uc2hhcGVCPW51bGx9fX0pKCk7bGV0ICRpPXt9O2NvbnN0IHRvPXt9LGVvPXt9LHNvPW5ldyBVaSxpbz17c3RlcDoxLzYwfTtmdW5jdGlvbiBvbyh0LGUpe3N3aXRjaCh0KXtjYXNlIkJveCI6cmV0dXJuIG5ldyBiKG5ldyBpKC4uLmUpKTtjYXNlIkNvbnZleFBvbHloZWRyb24iOmNvbnN0W3QscyxvXT1lO3JldHVybiBuZXcgZih7dmVydGljZXM6dC5tYXAoKFt0LGUsc10pPT5uZXcgaSh0LGUscykpLG5vcm1hbHM6bz9vLm1hcCgoW3QsZSxzXSk9Pm5ldyBpKHQsZSxzKSk6bnVsbCxmYWNlczpzfSk7Y2FzZSJDeWxpbmRlciI6cmV0dXJuIG5ldyBBZSguLi5lKTtjYXNlIkhlaWdodGZpZWxkIjpyZXR1cm4gbmV3IEZlKC4uLmUpO2Nhc2UiUGFydGljbGUiOnJldHVybiBuZXcgQmU7Y2FzZSJQbGFuZSI6cmV0dXJuIG5ldyBFZTtjYXNlIlNwaGVyZSI6cmV0dXJuIG5ldyBiZSguLi5lKTtjYXNlIlRyaW1lc2giOnJldHVybiBuZXcgT2UoLi4uZSl9fWZ1bmN0aW9uIG5vKCl7c2VsZi5wb3N0TWVzc2FnZSh7b3A6InN5bmMiLGJvZGllczpzby5ib2RpZXMubWFwKHQ9PnQudXVpZCl9KSwkaT1zby5ib2RpZXMucmVkdWNlKChlLHMpPT50KHt9LGUse1tzLnV1aWRdOnN9KSx7fSl9c2VsZi5vbm1lc3NhZ2U9cz0+e2NvbnN0e29wOm8sdXVpZDpuLHR5cGU6cixwb3NpdGlvbnM6YSxxdWF0ZXJuaW9uczpsLHByb3BzOmh9PXMuZGF0YTtzd2l0Y2gobyl7Y2FzZSJpbml0Ijp7Y29uc3R7Z3Jhdml0eTp0LHRvbGVyYW5jZTplLHN0ZXA6cyxpdGVyYXRpb25zOmksYWxsb3dTbGVlcDpvLGJyb2FkcGhhc2U6bixheGlzSW5kZXg6cixkZWZhdWx0Q29udGFjdE1hdGVyaWFsOmF9PWgsbD17TmFpdmVCcm9hZHBoYXNlOkQsU0FQQnJvYWRwaGFzZTpFdH07c28uYWxsb3dTbGVlcD1vLHNvLmdyYXZpdHkuc2V0KHRbMF0sdFsxXSx0WzJdKSxzby5zb2x2ZXIudG9sZXJhbmNlPWUsc28uc29sdmVyLml0ZXJhdGlvbnM9aSxzby5icm9hZHBoYXNlPW5ldyhsW24rIkJyb2FkcGhhc2UiXXx8RCkoc28pLHNvLmJyb2FkcGhhc2UuYXhpc0luZGV4PW51bGwhPXI/cjowLE9iamVjdC5hc3NpZ24oc28uZGVmYXVsdENvbnRhY3RNYXRlcmlhbCxhKSxpby5zdGVwPXM7YnJlYWt9Y2FzZSJzdGVwIjpzby5zdGVwKGlvLnN0ZXApO2ZvcihsZXQgdD0wO3Q8c28uYm9kaWVzLmxlbmd0aDt0Kyspe2xldCBlPXNvLmJvZGllc1t0XSxzPWUucG9zaXRpb24saT1lLnF1YXRlcm5pb247YVszKnQrMF09cy54LGFbMyp0KzFdPXMueSxhWzMqdCsyXT1zLnosbFs0KnQrMF09aS54LGxbNCp0KzFdPWkueSxsWzQqdCsyXT1pLnosbFs0KnQrM109aS53fXNlbGYucG9zdE1lc3NhZ2Uoe29wOiJmcmFtZSIscG9zaXRpb25zOmEscXVhdGVybmlvbnM6bCxhY3RpdmU6c28uaGFzQWN0aXZlQm9kaWVzfSxbYS5idWZmZXIsbC5idWZmZXJdKTticmVhaztjYXNlImFkZEJvZGllcyI6Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspe2NvbnN0IG89aFtzXSx7YXJnczphPVtdLHBvc2l0aW9uOmw9WzAsMCwwXSxyb3RhdGlvbjpjPVswLDAsMF0sc2NhbGU6dT1bMSwxLDFdLHR5cGU6cCxtYXNzOnksbWF0ZXJpYWw6bSxzaGFwZXM6dixvbkNvbGxpZGU6d309byxmPWUobyxbImFyZ3MiLCJwb3NpdGlvbiIsInJvdGF0aW9uIiwic2NhbGUiLCJ0eXBlIiwibWFzcyIsIm1hdGVyaWFsIiwic2hhcGVzIiwib25Db2xsaWRlIl0pLHg9bmV3IFModCh7fSxmLHttYXNzOiJTdGF0aWMiPT09cD8wOnksdHlwZTpwP1NbcC50b1VwcGVyQ2FzZSgpXTp2b2lkIDAsbWF0ZXJpYWw6bT9uZXcgbGUobSk6dm9pZCAwfSkpO3gudXVpZD1uW3NdLCJDb21wb3VuZCI9PT1yP3YuZm9yRWFjaCh0PT57bGV0e3R5cGU6cyxhcmdzOm8scG9zaXRpb246bixyb3RhdGlvbjpyLG1hdGVyaWFsOmF9PXQsbD1lKHQsWyJ0eXBlIiwiYXJncyIsInBvc2l0aW9uIiwicm90YXRpb24iLCJtYXRlcmlhbCJdKTtjb25zdCBoPXguYWRkU2hhcGUob28ocyxvKSxuP25ldyBpKC4uLm4pOnZvaWQgMCxyP25ldyBkKC4uLnIpOnZvaWQgMCk7YSYmKGgubWF0ZXJpYWw9bmV3IGxlKGEpKSxPYmplY3QuYXNzaWduKGgsbCl9KTp4LmFkZFNoYXBlKG9vKHIsYSkpLHgucG9zaXRpb24uc2V0KGxbMF0sbFsxXSxsWzJdKSx4LnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGNbMF0sY1sxXSxjWzJdKSxzby5hZGRCb2R5KHgpLHcmJnguYWRkRXZlbnRMaXN0ZW5lcigiY29sbGlkZSIsKHt0eXBlOnQsY29udGFjdDplLHRhcmdldDpzfSk9Pntjb25zdHtuaTppLHJpOm8scmo6bn09ZTtzZWxmLnBvc3RNZXNzYWdlKHtvcDoiZXZlbnQiLHR5cGU6dCxib2R5OngudXVpZCx0YXJnZXQ6cy51dWlkLGNvbnRhY3Q6e25pOmkudG9BcnJheSgpLHJpOm8udG9BcnJheSgpLHJqOm4udG9BcnJheSgpLGltcGFjdFZlbG9jaXR5OmUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCgpfSxjb2xsaXNpb25GaWx0ZXJzOntib2R5RmlsdGVyR3JvdXA6eC5jb2xsaXNpb25GaWx0ZXJHcm91cCxib2R5RmlsdGVyTWFzazp4LmNvbGxpc2lvbkZpbHRlck1hc2ssdGFyZ2V0RmlsdGVyR3JvdXA6cy5jb2xsaXNpb25GaWx0ZXJHcm91cCx0YXJnZXRGaWx0ZXJNYXNrOnMuY29sbGlzaW9uRmlsdGVyTWFza319KX0pfW5vKCk7YnJlYWs7Y2FzZSJyZW1vdmVCb2RpZXMiOmZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXNvLnJlbW92ZUJvZHkoJGlbblt0XV0pO25vKCk7YnJlYWs7Y2FzZSJzZXRQb3NpdGlvbiI6JGlbbl0ucG9zaXRpb24uc2V0KGhbMF0saFsxXSxoWzJdKTticmVhaztjYXNlInNldFJvdGF0aW9uIjokaVtuXS5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihoWzBdLGhbMV0saFsyXSwiWFlaIik7YnJlYWs7Y2FzZSJzZXRWZWxvY2l0eSI6JGlbbl0udmVsb2NpdHkuc2V0KGhbMF0saFsxXSxoWzJdKTticmVhaztjYXNlInNldEFuZ3VsYXJWZWxvY2l0eSI6JGlbbl0uYW5ndWxhclZlbG9jaXR5LnNldChoWzBdLGhbMV0saFsyXSk7YnJlYWs7Y2FzZSJzZXRNYXNzIjokaVtuXS5tYXNzPWg7YnJlYWs7Y2FzZSJzZXRMaW5lYXJEYW1waW5nIjokaVtuXS5saW5lYXJEYW1waW5nPWg7YnJlYWs7Y2FzZSJzZXRBbmd1bGFyRGFtcGluZyI6JGlbbl0uYW5ndWxhckRhbXBpbmc9aDticmVhaztjYXNlInNldEFsbG93U2xlZXAiOiRpW25dLmFsbG93U2xlZXA9aDticmVhaztjYXNlInNldFNsZWVwU3BlZWRMaW1pdCI6JGlbbl0uc2xlZXBTcGVlZExpbWl0PWg7YnJlYWs7Y2FzZSJzZXRTbGVlcFRpbWVMaW1pdCI6JGlbbl0uc2xlZXBUaW1lTGltaXQ9aDticmVhaztjYXNlInNldENvbGxpc2lvbkZpbHRlckdyb3VwIjokaVtuXS5jb2xsaXNpb25GaWx0ZXJHcm91cD1oO2JyZWFrO2Nhc2Uic2V0Q29sbGlzaW9uRmlsdGVyTWFzayI6Y2FzZSJzZXRDb2xsaXNpb25GaWx0ZXJNYXNrIjokaVtuXS5jb2xsaXNpb25GaWx0ZXJNYXNrPWg7YnJlYWs7Y2FzZSJzZXRGaXhlZFJvdGF0aW9uIjokaVtuXS5maXhlZFJvdGF0aW9uPWg7YnJlYWs7Y2FzZSJhcHBseUZvcmNlIjokaVtuXS5hcHBseUZvcmNlKG5ldyBpKC4uLmhbMF0pLG5ldyBpKC4uLmhbMV0pKTticmVhaztjYXNlImFwcGx5SW1wdWxzZSI6JGlbbl0uYXBwbHlJbXB1bHNlKG5ldyBpKC4uLmhbMF0pLG5ldyBpKC4uLmhbMV0pKTticmVhaztjYXNlImFwcGx5TG9jYWxGb3JjZSI6JGlbbl0uYXBwbHlMb2NhbEZvcmNlKG5ldyBpKC4uLmhbMF0pLG5ldyBpKC4uLmhbMV0pKTticmVhaztjYXNlImFwcGx5TG9jYWxJbXB1bHNlIjokaVtuXS5hcHBseUxvY2FsSW1wdWxzZShuZXcgaSguLi5oWzBdKSxuZXcgaSguLi5oWzFdKSk7YnJlYWs7Y2FzZSJhZGRDb25zdHJhaW50Ijp7Y29uc3RbcyxvLGFdPWg7bGV0IGwse3Bpdm90QTpjLHBpdm90Qjp1LGF4aXNBOmQsYXhpc0I6cH09YSx5PWUoYSxbInBpdm90QSIsInBpdm90QiIsImF4aXNBIiwiYXhpc0IiXSk7c3dpdGNoKGM9QXJyYXkuaXNBcnJheShjKT9uZXcgaSguLi5jKTp2b2lkIDAsdT1BcnJheS5pc0FycmF5KHUpP25ldyBpKC4uLnUpOnZvaWQgMCxkPUFycmF5LmlzQXJyYXkoZCk/bmV3IGkoLi4uZCk6dm9pZCAwLHA9QXJyYXkuaXNBcnJheShwKT9uZXcgaSguLi5wKTp2b2lkIDAscil7Y2FzZSJQb2ludFRvUG9pbnQiOmw9bmV3IFV0KCRpW3NdLGMsJGlbb10sdSxhLm1heEZvcmNlKTticmVhaztjYXNlIkNvbmVUd2lzdCI6bD1uZXcgUXQoJGlbc10sJGlbb10sdCh7cGl2b3RBOmMscGl2b3RCOnUsYXhpc0E6ZCxheGlzQjpwfSx5KSk7YnJlYWs7Y2FzZSJIaW5nZSI6bD1uZXcgZWUoJGlbc10sJGlbb10sdCh7cGl2b3RBOmMscGl2b3RCOnUsYXhpc0E6ZCxheGlzQjpwfSx5KSk7YnJlYWs7Y2FzZSJEaXN0YW5jZSI6bD1uZXcgSnQoJGlbc10sJGlbb10sYS5kaXN0YW5jZSxhLm1heEZvcmNlKTticmVhaztjYXNlIkxvY2siOmw9bmV3ICR0KCRpW3NdLCRpW29dLGEpO2JyZWFrO2RlZmF1bHQ6bD1uZXcgRnQoJGlbc10sJGlbb10sYSl9bC51dWlkPW4sc28uYWRkQ29uc3RyYWludChsKTticmVha31jYXNlInJlbW92ZUNvbnN0cmFpbnQiOnNvLnJlbW92ZUNvbnN0cmFpbnQobik7YnJlYWs7Y2FzZSJlbmFibGVDb25zdHJhaW50Ijpzby5jb25zdHJhaW50cy5maWx0ZXIoKHt1dWlkOnR9KT0+dD09PW4pLm1hcCh0PT50LmVuYWJsZSgpKTticmVhaztjYXNlImRpc2FibGVDb25zdHJhaW50Ijpzby5jb25zdHJhaW50cy5maWx0ZXIoKHt1dWlkOnR9KT0+dD09PW4pLm1hcCh0PT50LmRpc2FibGUoKSk7YnJlYWs7Y2FzZSJhZGRTcHJpbmciOntjb25zdFt0LGUsc109aDtsZXR7d29ybGRBbmNob3JBOm8sd29ybGRBbmNob3JCOnIsbG9jYWxBbmNob3JBOmEsbG9jYWxBbmNob3JCOmwscmVzdExlbmd0aDpjLHN0aWZmbmVzczp1LGRhbXBpbmc6ZH09cztvPUFycmF5LmlzQXJyYXkobyk/bmV3IGkoLi4ubyk6dm9pZCAwLHI9QXJyYXkuaXNBcnJheShyKT9uZXcgaSguLi5yKTp2b2lkIDAsYT1BcnJheS5pc0FycmF5KGEpP25ldyBpKC4uLmEpOnZvaWQgMCxsPUFycmF5LmlzQXJyYXkobCk/bmV3IGkoLi4ubCk6dm9pZCAwO2xldCBwPW5ldyBoZSgkaVt0XSwkaVtlXSx7d29ybGRBbmNob3JBOm8sd29ybGRBbmNob3JCOnIsbG9jYWxBbmNob3JBOmEsbG9jYWxBbmNob3JCOmwscmVzdExlbmd0aDpjLHN0aWZmbmVzczp1LGRhbXBpbmc6ZH0pO3AudXVpZD1uO2xldCB5PXQ9PnAuYXBwbHlGb3JjZSgpO3RvW25dPXksc28uYWRkRXZlbnRMaXN0ZW5lcigicG9zdFN0ZXAiLHRvW25dKTticmVha31jYXNlInJlbW92ZVNwcmluZyI6c28ucmVtb3ZlRXZlbnRMaXN0ZW5lcigicG9zdFN0ZXAiLHRvW25dKTticmVhaztjYXNlImFkZFJheSI6e2NvbnN0e2Zyb206cyx0bzpvfT1oLHI9ZShoLFsiZnJvbSIsInRvIl0pLGE9bmV3IFkocz9uZXcgaSguLi5zKTp2b2lkIDAsbz9uZXcgaSguLi5vKTp2b2lkIDApO3IubW9kZT1ZW3IubW9kZS50b1VwcGVyQ2FzZSgpXSxyLnJlc3VsdD1uZXcgWCxlb1tuXT0oKT0+e2EuaW50ZXJzZWN0V29ybGQoc28scik7Y29uc3QgaT1yLnJlc3VsdCx7Ym9keTpsLHNoYXBlOmgscmF5RnJvbVdvcmxkOmMscmF5VG9Xb3JsZDp1LGhpdE5vcm1hbFdvcmxkOmQsaGl0UG9pbnRXb3JsZDpwfT1pLHk9ZShpLFsiYm9keSIsInNoYXBlIiwicmF5RnJvbVdvcmxkIiwicmF5VG9Xb3JsZCIsImhpdE5vcm1hbFdvcmxkIiwiaGl0UG9pbnRXb3JsZCJdKTtzZWxmLnBvc3RNZXNzYWdlKHQoe29wOiJldmVudCIsdHlwZToicmF5aGl0IixyYXk6e2Zyb206cyx0bzpvLGRpcmVjdGlvbjphLmRpcmVjdGlvbi50b0FycmF5KCksY29sbGlzaW9uRmlsdGVyR3JvdXA6YS5jb2xsaXNpb25GaWx0ZXJHcm91cCxjb2xsaXNpb25GaWx0ZXJNYXNrOmEuY29sbGlzaW9uRmlsdGVyTWFzayx1dWlkOm59LGJvZHk6bD9sLnV1aWQ6bnVsbCxzaGFwZTpoP3Qoe30saCx7Ym9keTpsLnV1aWR9KTpudWxsLHJheUZyb21Xb3JsZDpjLnRvQXJyYXkoKSxyYXlUb1dvcmxkOnUudG9BcnJheSgpLGhpdE5vcm1hbFdvcmxkOmQudG9BcnJheSgpLGhpdFBvaW50V29ybGQ6cC50b0FycmF5KCl9LHkpKX0sc28uYWRkRXZlbnRMaXN0ZW5lcigicHJlU3RlcCIsZW9bbl0pO2JyZWFrfWNhc2UicmVtb3ZlUmF5Ijpzby5yZW1vdmVFdmVudExpc3RlbmVyKCJwcmVTdGVwIixlb1tuXSksZGVsZXRlIGVvW25dfX07Cgo=\",null,!1);export default function({children:L,step:u=1/60,gravity:p=[0,-10,0],tolerance:y=.001,iterations:a=5,allowSleep:s=!0,broadphase:V=\"Naive\",axisIndex:h=0,defaultContactMaterial:x={contactEquationStiffness:1e6},size:Y=1e3}){const{invalidate:R}=m(),[z]=G(()=>new W),[S]=G({}),[K]=G({}),[k]=G(()=>({positions:new Float32Array(3*Y),quaternions:new Float32Array(4*Y)})),n=d({});l(()=>{function b(){z.postMessage(Z({op:\"step\"},k),[k.positions.buffer,k.quaternions.buffer])}return z.postMessage({op:\"init\",props:{gravity:p,tolerance:y,step:u,iterations:a,broadphase:V,allowSleep:s,axisIndex:h,defaultContactMaterial:x}}),z.onmessage=G=>{switch(G.data.op){case\"frame\":k.positions=G.data.positions,k.quaternions=G.data.quaternions,requestAnimationFrame(b),G.data.active&&R();break;case\"sync\":n.current=G.data.bodies.reduce((b,d)=>Z({},b,{[d]:G.data.bodies.indexOf(d)}),{});break;case\"event\":switch(G.data.type){case\"collide\":S[G.data.body](Z({},G.data,{body:K[G.data.body],target:K[G.data.target]}));break;case\"rayhit\":S[G.data.ray.uuid](Z({},G.data,{body:G.data.body?K[G.data.body]:null}))}}},b(),()=>z.terminate()},[]);const o=c(()=>({worker:z,bodies:n,buffers:k,refs:K,events:S}),[z,n,k,S,K]);return(b.createElement(X.Provider,{value:o},L))}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n"],"sourceRoot":""}