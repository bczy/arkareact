{"version":3,"sources":["../node_modules/use-cannon/dist/Provider-d2ad9f14.js","../node_modules/process/browser.js","../node_modules/buffer/index.js","../node_modules/webpack/buildin/global.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js"],"names":["m","Object","prototype","toString","call","process","L","module","require","u","b","G","d","l","Buffer","from","atob","Uint8Array","length","Array","forEach","charCodeAt","String","fromCharCode","apply","Uint16Array","buffer","Z","indexOf","c","substring","Worker","assign","eval","X","Blob","type","URL","createObjectURL","children","step","gravity","W","tolerance","p","iterations","s","allowSleep","a","broadphase","y","axisIndex","V","defaultContactMaterial","h","contactEquationStiffness","size","x","Y","K","S","positions","Float32Array","quaternions","R","z","postMessage","op","props","onmessage","data","requestAnimationFrame","current","bodies","reduce","body","target","terminate","k","worker","buffers","refs","events","createElement","Provider","value","cachedSetTimeout","cachedClearTimeout","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","arguments","i","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","base64","ieee754","isArray","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","arg","encodingOrOffset","allocUnsafe","TypeError","ArrayBuffer","byteOffset","byteLength","undefined","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","actual","write","slice","fromString","obj","isBuffer","checked","copy","val","fromObject","assertSize","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","bidirectionalIndexOf","isNaN","arrayIndexOf","lastIndexOf","arr","indexSize","arrLength","valLength","read","buf","readUInt16BE","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","Math","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","global","foo","subarray","typedArraySupport","poolSize","_augment","Symbol","species","defineProperty","configurable","fill","allocUnsafeSlow","_isBuffer","compare","list","pos","swap16","swap32","swap64","equals","inspect","max","match","join","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","trim","replace","stringtrim","base64clean","src","dst","g","Function","window","b64","lens","getLens","validLen","placeHoldersLen","tmp","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","len2","encodeChunk","lookup","num","output","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","log","LN2"],"mappings":"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","file":"static/js/3.28c2fb60.chunk.js","sourcesContent":["import b,{useState as G,useRef as d,useEffect as l,useMemo as Z}from\"react\";import{_ as c,c as X}from\"./index-1f49f84c.js\";import\"three\";import\"react-three-fiber\";const m=\"[object process]\"===Object.prototype.toString.call(\"undefined\"!=typeof process?process:0),L=m&&\"function\"==typeof module.require?module.require:null;const u=function(b,G=null,d=!1){const l=m?function(b,G){return Buffer.from(b,\"base64\").toString(G?\"utf16\":\"utf8\")}(b,d):function(b,G){const d=atob(b);if(G){const b=new Uint8Array(d.length);return Array.prototype.forEach.call(b,(b,G,l)=>{l[G]=d.charCodeAt(G)}),String.fromCharCode.apply(null,new Uint16Array(b.buffer))}return d}(b,d),Z=l.indexOf(\"\\n\",10)+1,c=l.substring(Z)+(G?\"//# sourceMappingURL=\"+G:\"\");if(L){const b=L(\"worker_threads\").Worker;return function(G){return new b(c,Object.assign({},G,{eval:!0}))}}const X=new Blob([c],{type:\"application/javascript\"}),u=URL.createObjectURL(X);return function(b){return new Worker(u,b)}}(\"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwpmdW5jdGlvbiB0KCl7cmV0dXJuKHQ9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHM9YXJndW1lbnRzW2VdO2Zvcih2YXIgaSBpbiBzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLGkpJiYodFtpXT1zW2ldKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBlKHQsZSl7aWYobnVsbD09dClyZXR1cm57fTt2YXIgcyxpLG89e30sbj1PYmplY3Qua2V5cyh0KTtmb3IoaT0wO2k8bi5sZW5ndGg7aSsrKXM9bltpXSxlLmluZGV4T2Yocyk+PTB8fChvW3NdPXRbc10pO3JldHVybiBvfWNsYXNzIHN7Y29uc3RydWN0b3IodCl7dGhpcy5lbGVtZW50cz10fHxbMCwwLDAsMCwwLDAsMCwwLDBdfWlkZW50aXR5KCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzO3RbMF09MSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTEsdFs1XT0wLHRbNl09MCx0WzddPTAsdFs4XT0xfXNldFplcm8oKXtjb25zdCB0PXRoaXMuZWxlbWVudHM7dFswXT0wLHRbMV09MCx0WzJdPTAsdFszXT0wLHRbNF09MCx0WzVdPTAsdFs2XT0wLHRbN109MCx0WzhdPTB9c2V0VHJhY2Uoe3g6dCx5OmUsejpzfSl7Y29uc3QgaT10aGlzLmVsZW1lbnRzO2lbMF09dCxpWzRdPWUsaVs4XT1zfWdldFRyYWNlKHQpe3Q9dHx8bmV3IGk7Y29uc3QgZT10aGlzLmVsZW1lbnRzO3QueD1lWzBdLHQueT1lWzRdLHQuej1lWzhdfXZtdWx0KHQsZT1uZXcgaSl7Y29uc3Qgcz10aGlzLmVsZW1lbnRzLG89dC54LG49dC55LHI9dC56O3JldHVybiBlLng9c1swXSpvK3NbMV0qbitzWzJdKnIsZS55PXNbM10qbytzWzRdKm4rc1s1XSpyLGUuej1zWzZdKm8rc1s3XSpuK3NbOF0qcixlfXNtdWx0KHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5lbGVtZW50cy5sZW5ndGg7ZSsrKXRoaXMuZWxlbWVudHNbZV0qPXR9bW11bHQoe2VsZW1lbnRzOnR9LGUpe2NvbnN0IGk9ZXx8bmV3IHM7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IHM9MDtzPDM7cysrKXtsZXQgbz0wO2ZvcihsZXQgaT0wO2k8MztpKyspbys9dFtlKzMqaV0qdGhpcy5lbGVtZW50c1tpKzMqc107aS5lbGVtZW50c1tlKzMqc109b31yZXR1cm4gaX1zY2FsZSh7eDp0LHk6ZSx6Oml9LG89bmV3IHMpe2NvbnN0IG49dGhpcy5lbGVtZW50cyxyPW8uZWxlbWVudHM7Zm9yKGxldCBzPTA7MyE9PXM7cysrKXJbMypzKzBdPXQqblszKnMrMF0sclszKnMrMV09ZSpuWzMqcysxXSxyWzMqcysyXT1pKm5bMypzKzJdO3JldHVybiBvfXNvbHZlKHQsZT1uZXcgaSl7Y29uc3Qgcz1bXTtmb3IodmFyIG89MDtvPDEyO28rKylzLnB1c2goMCk7bGV0IG47Zm9yKG89MDtvPDM7bysrKWZvcihuPTA7bjwzO24rKylzW28rNCpuXT10aGlzLmVsZW1lbnRzW28rMypuXTtzWzNdPXQueCxzWzddPXQueSxzWzExXT10Lno7bGV0IHI9Mztjb25zdCBhPXI7bGV0IGw7bGV0IGg7ZG97aWYoMD09PXNbKG89YS1yKSs0Km9dKWZvcihuPW8rMTtuPGE7bisrKWlmKDAhPT1zW28rNCpuXSl7bD00O2Rve2g9NC1sLHNbaCs0Km9dKz1zW2grNCpuXX13aGlsZSgtLWwpO2JyZWFrfWlmKDAhPT1zW28rNCpvXSlmb3Iobj1vKzE7bjxhO24rKyl7Y29uc3QgdD1zW28rNCpuXS9zW28rNCpvXTtsPTQ7ZG97aD00LWwsc1toKzQqbl09aDw9bz8wOnNbaCs0Km5dLXNbaCs0Km9dKnR9d2hpbGUoLS1sKX19d2hpbGUoLS1yKTtpZihlLno9c1sxMV0vc1sxMF0sZS55PShzWzddLXNbNl0qZS56KS9zWzVdLGUueD0oc1szXS1zWzJdKmUuei1zWzFdKmUueSkvc1swXSxpc05hTihlLngpfHxpc05hTihlLnkpfHxpc05hTihlLnopfHxlLng9PT0xLzB8fGUueT09PTEvMHx8ZS56PT09MS8wKXRocm93IkNvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9WyIrZS50b1N0cmluZygpKyJdLCBiPVsiK3QudG9TdHJpbmcoKSsiXSwgQT1bIit0aGlzLnRvU3RyaW5nKCkrIl0iO3JldHVybiBlfWUodCxlLHMpe2lmKHZvaWQgMD09PXMpcmV0dXJuIHRoaXMuZWxlbWVudHNbZSszKnRdO3RoaXMuZWxlbWVudHNbZSszKnRdPXN9Y29weSh7ZWxlbWVudHM6dH0pe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMuZWxlbWVudHNbZV09dFtlXTtyZXR1cm4gdGhpc310b1N0cmluZygpe2xldCB0PSIiO2ZvcihsZXQgZT0wO2U8OTtlKyspdCs9dGhpcy5lbGVtZW50c1tlXSsiLCI7cmV0dXJuIHR9cmV2ZXJzZSh0PW5ldyBzKXtjb25zdCBlPVtdO2Zvcih2YXIgaT0wO2k8MTg7aSsrKWUucHVzaCgwKTtsZXQgbztmb3IoaT0wO2k8MztpKyspZm9yKG89MDtvPDM7bysrKWVbaSs2Km9dPXRoaXMuZWxlbWVudHNbaSszKm9dO2VbM109MSxlWzldPTAsZVsxNV09MCxlWzRdPTAsZVsxMF09MSxlWzE2XT0wLGVbNV09MCxlWzExXT0wLGVbMTddPTE7bGV0IG49Mztjb25zdCByPW47bGV0IGE7bGV0IGw7ZG97aWYoMD09PWVbKGk9ci1uKSs2KmldKWZvcihvPWkrMTtvPHI7bysrKWlmKDAhPT1lW2krNipvXSl7YT02O2Rve2w9Ni1hLGVbbCs2KmldKz1lW2wrNipvXX13aGlsZSgtLWEpO2JyZWFrfWlmKDAhPT1lW2krNippXSlmb3Iobz1pKzE7bzxyO28rKyl7dmFyIGg9ZVtpKzYqb10vZVtpKzYqaV07YT02O2Rve2w9Ni1hLGVbbCs2Km9dPWw8PWk/MDplW2wrNipvXS1lW2wrNippXSpofXdoaWxlKC0tYSl9fXdoaWxlKC0tbik7aT0yO2Rve289aS0xO2Rve2g9ZVtpKzYqb10vZVtpKzYqaV07YT02O2Rve2w9Ni1hLGVbbCs2Km9dPWVbbCs2Km9dLWVbbCs2KmldKmh9d2hpbGUoLS1hKX13aGlsZShvLS0pfXdoaWxlKC0taSk7aT0yO2Rve2g9MS9lW2krNippXTthPTY7ZG97bD02LWEsZVtsKzYqaV09ZVtsKzYqaV0qaH13aGlsZSgtLWEpfXdoaWxlKGktLSk7aT0yO2Rve289Mjtkb3tpZihsPWVbMytvKzYqaV0saXNOYU4obCl8fGw9PT0xLzApdGhyb3ciQ291bGQgbm90IHJldmVyc2UhIEE9WyIrdGhpcy50b1N0cmluZygpKyJdIjt0LmUoaSxvLGwpfXdoaWxlKG8tLSl9d2hpbGUoaS0tKTtyZXR1cm4gdH1zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpe2NvbnN0IGU9dC54LHM9dC55LGk9dC56LG89dC53LG49ZStlLHI9cytzLGE9aStpLGw9ZSpuLGg9ZSpyLGM9ZSphLHU9cypyLGQ9cyphLHA9aSphLHk9bypuLG09bypyLHY9byphLGY9dGhpcy5lbGVtZW50cztyZXR1cm4gZlswXT0xLSh1K3ApLGZbMV09aC12LGZbMl09YyttLGZbM109aCt2LGZbNF09MS0obCtwKSxmWzVdPWQteSxmWzZdPWMtbSxmWzddPWQreSxmWzhdPTEtKGwrdSksdGhpc310cmFuc3Bvc2UodD1uZXcgcyl7Y29uc3QgZT10LmVsZW1lbnRzLGk9dGhpcy5lbGVtZW50cztmb3IobGV0IHQ9MDszIT09dDt0KyspZm9yKGxldCBzPTA7MyE9PXM7cysrKWVbMyp0K3NdPWlbMypzK3RdO3JldHVybiB0fX1jbGFzcyBpe2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wKXt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9c31jcm9zcyh0LGU9bmV3IGkpe2NvbnN0IHM9dC54LG89dC55LG49dC56LHI9dGhpcy54LGE9dGhpcy55LGw9dGhpcy56O3JldHVybiBlLng9YSpuLWwqbyxlLnk9bCpzLXIqbixlLno9cipvLWEqcyxlfXNldCh0LGUscyl7cmV0dXJuIHRoaXMueD10LHRoaXMueT1lLHRoaXMuej1zLHRoaXN9c2V0WmVybygpe3RoaXMueD10aGlzLnk9dGhpcy56PTB9dmFkZCh7eDp0LHk6ZSx6OnN9LG8pe2lmKCFvKXJldHVybiBuZXcgaSh0aGlzLngrdCx0aGlzLnkrZSx0aGlzLnorcyk7by54PXQrdGhpcy54LG8ueT1lK3RoaXMueSxvLno9cyt0aGlzLnp9dnN1Yih7eDp0LHk6ZSx6OnN9LG8pe2lmKCFvKXJldHVybiBuZXcgaSh0aGlzLngtdCx0aGlzLnktZSx0aGlzLnotcyk7by54PXRoaXMueC10LG8ueT10aGlzLnktZSxvLno9dGhpcy56LXN9Y3Jvc3NtYXQoKXtyZXR1cm4gbmV3IHMoWzAsLXRoaXMueix0aGlzLnksdGhpcy56LDAsLXRoaXMueCwtdGhpcy55LHRoaXMueCwwXSl9bm9ybWFsaXplKCl7Y29uc3QgdD10aGlzLngsZT10aGlzLnkscz10aGlzLnosaT1NYXRoLnNxcnQodCp0K2UqZStzKnMpO2lmKGk+MCl7Y29uc3QgdD0xL2k7dGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXR9ZWxzZSB0aGlzLng9MCx0aGlzLnk9MCx0aGlzLno9MDtyZXR1cm4gaX11bml0KHQ9bmV3IGkpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LG89dGhpcy56O2xldCBuPU1hdGguc3FydChlKmUrcypzK28qbyk7cmV0dXJuIG4+MD8obj0xL24sdC54PWUqbix0Lnk9cypuLHQuej1vKm4pOih0Lng9MSx0Lnk9MCx0Lno9MCksdH1ub3JtKCl7Y29uc3QgdD10aGlzLngsZT10aGlzLnkscz10aGlzLno7cmV0dXJuIE1hdGguc3FydCh0KnQrZSplK3Mqcyl9bm9ybTIoKXtyZXR1cm4gdGhpcy5kb3QodGhpcyl9ZGlzdGFuY2VUbyh0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxpPXRoaXMueixvPXQueCxuPXQueSxyPXQuejtyZXR1cm4gTWF0aC5zcXJ0KChvLWUpKihvLWUpKyhuLXMpKihuLXMpKyhyLWkpKihyLWkpKX1kaXN0YW5jZVNxdWFyZWQodCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksaT10aGlzLnosbz10Lngsbj10Lnkscj10Lno7cmV0dXJuKG8tZSkqKG8tZSkrKG4tcykqKG4tcykrKHItaSkqKHItaSl9bXVsdCh0LGU9bmV3IGkpe2NvbnN0IHM9dGhpcy54LG89dGhpcy55LG49dGhpcy56O3JldHVybiBlLng9dCpzLGUueT10Km8sZS56PXQqbixlfXZtdWwoe3g6dCx5OmUsejpzfSxvPW5ldyBpKXtyZXR1cm4gby54PXQqdGhpcy54LG8ueT1lKnRoaXMueSxvLno9cyp0aGlzLnosb31hZGRTY2FsZWRWZWN0b3IodCx7eDplLHk6cyx6Om99LG49bmV3IGkpe3JldHVybiBuLng9dGhpcy54K3QqZSxuLnk9dGhpcy55K3QqcyxuLno9dGhpcy56K3QqbyxufWRvdCh7eDp0LHk6ZSx6OnN9KXtyZXR1cm4gdGhpcy54KnQrdGhpcy55KmUrdGhpcy56KnN9aXNaZXJvKCl7cmV0dXJuIDA9PT10aGlzLngmJjA9PT10aGlzLnkmJjA9PT10aGlzLnp9bmVnYXRlKHQ9bmV3IGkpe3JldHVybiB0Lng9LXRoaXMueCx0Lnk9LXRoaXMueSx0Lno9LXRoaXMueix0fXRhbmdlbnRzKHQsZSl7Y29uc3Qgcz10aGlzLm5vcm0oKTtpZihzPjApe2NvbnN0IG89bmV3IGksbj0xL3M7by5zZXQodGhpcy54Km4sdGhpcy55Km4sdGhpcy56Km4pO2NvbnN0IHI9bmV3IGk7TWF0aC5hYnMoby54KTwuOT8oci5zZXQoMSwwLDApLG8uY3Jvc3Mocix0KSk6KHIuc2V0KDAsMSwwKSxvLmNyb3NzKHIsdCkpLG8uY3Jvc3ModCxlKX1lbHNlIHQuc2V0KDEsMCwwKSxlLnNldCgwLDEsMCl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy54KyIsIit0aGlzLnkrIiwiK3RoaXMuen10b0FycmF5KCl7cmV0dXJuW3RoaXMueCx0aGlzLnksdGhpcy56XX1jb3B5KHt4OnQseTplLHo6c30pe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9cyx0aGlzfWxlcnAodCxlLHMpe2NvbnN0IGk9dGhpcy54LG89dGhpcy55LG49dGhpcy56O3MueD1pKyh0LngtaSkqZSxzLnk9bysodC55LW8pKmUscy56PW4rKHQuei1uKSplfWFsbW9zdEVxdWFscyh7eDp0LHk6ZSx6OnN9LGk9MWUtNil7cmV0dXJuIShNYXRoLmFicyh0aGlzLngtdCk+aXx8TWF0aC5hYnModGhpcy55LWUpPml8fE1hdGguYWJzKHRoaXMuei1zKT5pKX1hbG1vc3RaZXJvKHQ9MWUtNil7cmV0dXJuIShNYXRoLmFicyh0aGlzLngpPnR8fE1hdGguYWJzKHRoaXMueSk+dHx8TWF0aC5hYnModGhpcy56KT50KX1pc0FudGlwYXJhbGxlbFRvKHQsZSl7cmV0dXJuIHRoaXMubmVnYXRlKGFudGlwX25lZyksKG5ldyBpKS5hbG1vc3RFcXVhbHModCxlKX1jbG9uZSgpe3JldHVybiBuZXcgaSh0aGlzLngsdGhpcy55LHRoaXMueil9fWZ1bmN0aW9uIG8oKXt9aS5aRVJPPW5ldyBpKDAsMCwwKSxpLlVOSVRfWD1uZXcgaSgxLDAsMCksaS5VTklUX1k9bmV3IGkoMCwxLDApLGkuVU5JVF9aPW5ldyBpKDAsMCwxKSxpLnByb3RvdHlwZS5sZW5ndGg9aS5wcm90b3R5cGUubm9ybSxpLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkPWkucHJvdG90eXBlLm5vcm0yLGkucHJvdG90eXBlLnNjYWxlPWkucHJvdG90eXBlLm11bHQsby5kZWZhdWx0cz0odD17fSxlKT0+e2ZvcihsZXQgcyBpbiBlKXMgaW4gdHx8KHRbc109ZVtzXSk7cmV0dXJuIHR9O2NsYXNzIG57Y29uc3RydWN0b3IodD17fSl7dGhpcy5sb3dlckJvdW5kPW5ldyBpLHQubG93ZXJCb3VuZCYmdGhpcy5sb3dlckJvdW5kLmNvcHkodC5sb3dlckJvdW5kKSx0aGlzLnVwcGVyQm91bmQ9bmV3IGksdC51cHBlckJvdW5kJiZ0aGlzLnVwcGVyQm91bmQuY29weSh0LnVwcGVyQm91bmQpfXNldEZyb21Qb2ludHModCxlLHMsaSl7Y29uc3Qgbz10aGlzLmxvd2VyQm91bmQsbj10aGlzLnVwcGVyQm91bmQsYT1zO28uY29weSh0WzBdKSxhJiZhLnZtdWx0KG8sbyksbi5jb3B5KG8pO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKXtsZXQgcz10W2VdO2EmJihhLnZtdWx0KHMscikscz1yKSxzLng+bi54JiYobi54PXMueCkscy54PG8ueCYmKG8ueD1zLngpLHMueT5uLnkmJihuLnk9cy55KSxzLnk8by55JiYoby55PXMueSkscy56Pm4ueiYmKG4uej1zLnopLHMuejxvLnomJihvLno9cy56KX1yZXR1cm4gZSYmKGUudmFkZChvLG8pLGUudmFkZChuLG4pKSxpJiYoby54LT1pLG8ueS09aSxvLnotPWksbi54Kz1pLG4ueSs9aSxuLnorPWkpLHRoaXN9Y29weSh7bG93ZXJCb3VuZDp0LHVwcGVyQm91bmQ6ZX0pe3JldHVybiB0aGlzLmxvd2VyQm91bmQuY29weSh0KSx0aGlzLnVwcGVyQm91bmQuY29weShlKSx0aGlzfWNsb25lKCl7cmV0dXJuKG5ldyBuKS5jb3B5KHRoaXMpfWV4dGVuZCh7bG93ZXJCb3VuZDp0LHVwcGVyQm91bmQ6ZX0pe3RoaXMubG93ZXJCb3VuZC54PU1hdGgubWluKHRoaXMubG93ZXJCb3VuZC54LHQueCksdGhpcy51cHBlckJvdW5kLng9TWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsZS54KSx0aGlzLmxvd2VyQm91bmQueT1NYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueSx0LnkpLHRoaXMudXBwZXJCb3VuZC55PU1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC55LGUueSksdGhpcy5sb3dlckJvdW5kLno9TWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosdC56KSx0aGlzLnVwcGVyQm91bmQuej1NYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueixlLnopfW92ZXJsYXBzKHtsb3dlckJvdW5kOnQsdXBwZXJCb3VuZDplfSl7Y29uc3Qgcz10aGlzLmxvd2VyQm91bmQsaT10aGlzLnVwcGVyQm91bmQsbz10LG49ZSxyPW8ueDw9aS54JiZpLng8PW4ueHx8cy54PD1uLngmJm4ueDw9aS54LGE9by55PD1pLnkmJmkueTw9bi55fHxzLnk8PW4ueSYmbi55PD1pLnksbD1vLno8PWkueiYmaS56PD1uLnp8fHMuejw9bi56JiZuLno8PWkuejtyZXR1cm4gciYmYSYmbH12b2x1bWUoKXtjb25zdCB0PXRoaXMubG93ZXJCb3VuZCxlPXRoaXMudXBwZXJCb3VuZDtyZXR1cm4oZS54LXQueCkqKGUueS10LnkpKihlLnotdC56KX1jb250YWlucyh7bG93ZXJCb3VuZDp0LHVwcGVyQm91bmQ6ZX0pe2NvbnN0IHM9dGhpcy5sb3dlckJvdW5kLGk9dGhpcy51cHBlckJvdW5kLG89dCxuPWU7cmV0dXJuIHMueDw9by54JiZpLng+PW4ueCYmcy55PD1vLnkmJmkueT49bi55JiZzLno8PW8ueiYmaS56Pj1uLnp9Z2V0Q29ybmVycyh0LGUscyxpLG8sbixyLGEpe2NvbnN0IGw9dGhpcy5sb3dlckJvdW5kLGg9dGhpcy51cHBlckJvdW5kO3QuY29weShsKSxlLnNldChoLngsbC55LGwueikscy5zZXQoaC54LGgueSxsLnopLGkuc2V0KGwueCxoLnksaC56KSxvLnNldChoLngsbC55LGgueiksbi5zZXQobC54LGgueSxsLnopLHIuc2V0KGwueCxsLnksaC56KSxhLmNvcHkoaCl9dG9Mb2NhbEZyYW1lKHQsZSl7Y29uc3Qgcz1hLGk9c1swXSxvPXNbMV0sbj1zWzJdLHI9c1szXSxsPXNbNF0saD1zWzVdLGM9c1s2XSx1PXNbN107dGhpcy5nZXRDb3JuZXJzKGksbyxuLHIsbCxoLGMsdSk7Zm9yKGxldCBlPTA7OCE9PWU7ZSsrKXtjb25zdCBpPXNbZV07dC5wb2ludFRvTG9jYWwoaSxpKX1yZXR1cm4gZS5zZXRGcm9tUG9pbnRzKHMpfXRvV29ybGRGcmFtZSh0LGUpe2NvbnN0IHM9YSxpPXNbMF0sbz1zWzFdLG49c1syXSxyPXNbM10sbD1zWzRdLGg9c1s1XSxjPXNbNl0sdT1zWzddO3RoaXMuZ2V0Q29ybmVycyhpLG8sbixyLGwsaCxjLHUpO2ZvcihsZXQgZT0wOzghPT1lO2UrKyl7Y29uc3QgaT1zW2VdO3QucG9pbnRUb1dvcmxkKGksaSl9cmV0dXJuIGUuc2V0RnJvbVBvaW50cyhzKX1vdmVybGFwc1JheSh7X2RpcmVjdGlvbjp0LGZyb206ZX0pe2NvbnN0IHM9MS90LngsaT0xL3QueSxvPTEvdC56LG49KHRoaXMubG93ZXJCb3VuZC54LWUueCkqcyxyPSh0aGlzLnVwcGVyQm91bmQueC1lLngpKnMsYT0odGhpcy5sb3dlckJvdW5kLnktZS55KSppLGw9KHRoaXMudXBwZXJCb3VuZC55LWUueSkqaSxoPSh0aGlzLmxvd2VyQm91bmQuei1lLnopKm8sYz0odGhpcy51cHBlckJvdW5kLnotZS56KSpvLHU9TWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4obixyKSxNYXRoLm1pbihhLGwpKSxNYXRoLm1pbihoLGMpKSxkPU1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KG4sciksTWF0aC5tYXgoYSxsKSksTWF0aC5tYXgoaCxjKSk7cmV0dXJuIShkPDApJiYhKHU+ZCl9fWNvbnN0IHI9bmV3IGksYT1bbmV3IGksbmV3IGksbmV3IGksbmV3IGksbmV3IGksbmV3IGksbmV3IGksbmV3IGldO2NsYXNzIGx7Y29uc3RydWN0b3IoKXt0aGlzLm1hdHJpeD1bXX1nZXQodCxlKXtpZih0PXQuaW5kZXgsKGU9ZS5pbmRleCk+dCl7Y29uc3Qgcz1lO2U9dCx0PXN9cmV0dXJuIHRoaXMubWF0cml4Wyh0Kih0KzEpPj4xKStlLTFdfXNldCh0LGUscyl7aWYodD10LmluZGV4LChlPWUuaW5kZXgpPnQpe2NvbnN0IHM9ZTtlPXQsdD1zfXRoaXMubWF0cml4Wyh0Kih0KzEpPj4xKStlLTFdPXM/MTowfXJlc2V0KCl7Zm9yKGxldCB0PTAsZT10aGlzLm1hdHJpeC5sZW5ndGg7dCE9PWU7dCsrKXRoaXMubWF0cml4W3RdPTB9c2V0TnVtT2JqZWN0cyh0KXt0aGlzLm1hdHJpeC5sZW5ndGg9dCoodC0xKT4+MX19Y2xhc3MgaHthZGRFdmVudExpc3RlbmVyKHQsZSl7dm9pZCAwPT09dGhpcy5fbGlzdGVuZXJzJiYodGhpcy5fbGlzdGVuZXJzPXt9KTtjb25zdCBzPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gdm9pZCAwPT09c1t0XSYmKHNbdF09W10pLHNbdF0uaW5jbHVkZXMoZSl8fHNbdF0ucHVzaChlKSx0aGlzfWhhc0V2ZW50TGlzdGVuZXIodCxlKXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuITE7Y29uc3Qgcz10aGlzLl9saXN0ZW5lcnM7cmV0dXJuISh2b2lkIDA9PT1zW3RdfHwhc1t0XS5pbmNsdWRlcyhlKSl9aGFzQW55RXZlbnRMaXN0ZW5lcih0KXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuITE7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX2xpc3RlbmVyc1t0XX1yZW1vdmVFdmVudExpc3RlbmVyKHQsZSl7aWYodm9pZCAwPT09dGhpcy5fbGlzdGVuZXJzKXJldHVybiB0aGlzO2NvbnN0IHM9dGhpcy5fbGlzdGVuZXJzO2lmKHZvaWQgMD09PXNbdF0pcmV0dXJuIHRoaXM7Y29uc3QgaT1zW3RdLmluZGV4T2YoZSk7cmV0dXJuLTEhPT1pJiZzW3RdLnNwbGljZShpLDEpLHRoaXN9ZGlzcGF0Y2hFdmVudCh0KXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuIHRoaXM7Y29uc3QgZT10aGlzLl9saXN0ZW5lcnNbdC50eXBlXTtpZih2b2lkIDAhPT1lKXt0LnRhcmdldD10aGlzO2ZvcihsZXQgcz0wLGk9ZS5sZW5ndGg7czxpO3MrKyllW3NdLmNhbGwodGhpcyx0KX1yZXR1cm4gdGhpc319Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0PXt9KXt0aGlzLmlkPWMuaWRDb3VudGVyKyssdGhpcy50eXBlPXQudHlwZXx8MCx0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzPTAsdGhpcy5jb2xsaXNpb25SZXNwb25zZT0hdC5jb2xsaXNpb25SZXNwb25zZXx8dC5jb2xsaXNpb25SZXNwb25zZSx0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwPXZvaWQgMCE9PXQuY29sbGlzaW9uRmlsdGVyR3JvdXA/dC5jb2xsaXNpb25GaWx0ZXJHcm91cDoxLHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzaz12b2lkIDAhPT10LmNvbGxpc2lvbkZpbHRlck1hc2s/dC5jb2xsaXNpb25GaWx0ZXJNYXNrOi0xLHRoaXMubWF0ZXJpYWw9dC5tYXRlcmlhbD90Lm1hdGVyaWFsOm51bGwsdGhpcy5ib2R5PW51bGx9dXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKXt0aHJvdyJjb21wdXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgIit0aGlzLnR5cGV9dm9sdW1lKCl7dGhyb3cidm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICIrdGhpcy50eXBlfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGUpe3Rocm93ImNhbGN1bGF0ZUxvY2FsSW5lcnRpYSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAiK3RoaXMudHlwZX19Yy5wcm90b3R5cGUuY29uc3RydWN0b3I9YyxjLmlkQ291bnRlcj0wLGMudHlwZXM9e1NQSEVSRToxLFBMQU5FOjIsQk9YOjQsQ09NUE9VTkQ6OCxDT05WRVhQT0xZSEVEUk9OOjE2LEhFSUdIVEZJRUxEOjMyLFBBUlRJQ0xFOjY0LENZTElOREVSOjEyOCxUUklNRVNIOjI1Nn07Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0LGUscyxpKXt0aGlzLng9dm9pZCAwIT09dD90OjAsdGhpcy55PXZvaWQgMCE9PWU/ZTowLHRoaXMuej12b2lkIDAhPT1zP3M6MCx0aGlzLnc9dm9pZCAwIT09aT9pOjF9c2V0KHQsZSxzLGkpe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9cyx0aGlzLnc9aSx0aGlzfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMueCsiLCIrdGhpcy55KyIsIit0aGlzLnorIiwiK3RoaXMud310b0FycmF5KCl7cmV0dXJuW3RoaXMueCx0aGlzLnksdGhpcy56LHRoaXMud119c2V0RnJvbUF4aXNBbmdsZSh7eDp0LHk6ZSx6OnN9LGkpe2NvbnN0IG89TWF0aC5zaW4oLjUqaSk7cmV0dXJuIHRoaXMueD10Km8sdGhpcy55PWUqbyx0aGlzLno9cypvLHRoaXMudz1NYXRoLmNvcyguNSppKSx0aGlzfXRvQXhpc0FuZ2xlKHQ9bmV3IGkpe3RoaXMubm9ybWFsaXplKCk7Y29uc3QgZT0yKk1hdGguYWNvcyh0aGlzLncpLHM9TWF0aC5zcXJ0KDEtdGhpcy53KnRoaXMudyk7cmV0dXJuIHM8LjAwMT8odC54PXRoaXMueCx0Lnk9dGhpcy55LHQuej10aGlzLnopOih0Lng9dGhpcy54L3MsdC55PXRoaXMueS9zLHQuej10aGlzLnovcyksW3QsZV19c2V0RnJvbVZlY3RvcnModCxlKXtpZih0LmlzQW50aXBhcmFsbGVsVG8oZSkpe2NvbnN0IGU9ZCxzPXA7dC50YW5nZW50cyhlLHMpLHRoaXMuc2V0RnJvbUF4aXNBbmdsZShlLE1hdGguUEkpfWVsc2V7Y29uc3Qgcz10LmNyb3NzKGUpO3RoaXMueD1zLngsdGhpcy55PXMueSx0aGlzLno9cy56LHRoaXMudz1NYXRoLnNxcnQodC5ub3JtKCkqKjIqZS5ub3JtKCkqKjIpK3QuZG90KGUpLHRoaXMubm9ybWFsaXplKCl9cmV0dXJuIHRoaXN9bXVsdCh7eDp0LHk6ZSx6OnMsdzppfSxvPW5ldyB1KXtjb25zdCBuPXRoaXMueCxyPXRoaXMueSxhPXRoaXMueixsPXRoaXMudyxoPXQsYz1lLGQ9cyxwPWk7cmV0dXJuIG8ueD1uKnArbCpoK3IqZC1hKmMsby55PXIqcCtsKmMrYSpoLW4qZCxvLno9YSpwK2wqZCtuKmMtcipoLG8udz1sKnAtbipoLXIqYy1hKmQsb31pbnZlcnNlKHQpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGk9dGhpcy56LG89dGhpcy53O3Q9dHx8bmV3IHUsdGhpcy5jb25qdWdhdGUodCk7Y29uc3Qgbj0xLyhlKmUrcypzK2kqaStvKm8pO3JldHVybiB0LngqPW4sdC55Kj1uLHQueio9bix0LncqPW4sdH1jb25qdWdhdGUodD1uZXcgdSl7cmV0dXJuIHQueD0tdGhpcy54LHQueT0tdGhpcy55LHQuej0tdGhpcy56LHQudz10aGlzLncsdH1ub3JtYWxpemUoKXtsZXQgdD1NYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudyk7cmV0dXJuIDA9PT10Pyh0aGlzLng9MCx0aGlzLnk9MCx0aGlzLno9MCx0aGlzLnc9MCk6KHQ9MS90LHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXMudyo9dCksdGhpc31ub3JtYWxpemVGYXN0KCl7Y29uc3QgdD0oMy0odGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudykpLzI7cmV0dXJuIDA9PT10Pyh0aGlzLng9MCx0aGlzLnk9MCx0aGlzLno9MCx0aGlzLnc9MCk6KHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXMudyo9dCksdGhpc312bXVsdCh0LGU9bmV3IGkpe2NvbnN0IHM9dC54LG89dC55LG49dC56LHI9dGhpcy54LGE9dGhpcy55LGw9dGhpcy56LGg9dGhpcy53LGM9aCpzK2Eqbi1sKm8sdT1oKm8rbCpzLXIqbixkPWgqbityKm8tYSpzLHA9LXIqcy1hKm8tbCpuO3JldHVybiBlLng9YypoK3AqLXIrdSotbC1kKi1hLGUueT11KmgrcCotYStkKi1yLWMqLWwsZS56PWQqaCtwKi1sK2MqLWEtdSotcixlfWNvcHkoe3g6dCx5OmUsejpzLHc6aX0pe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9cyx0aGlzLnc9aSx0aGlzfXRvRXVsZXIodCxlPSJZWlgiKXtsZXQgcyxpLG87Y29uc3Qgbj10aGlzLngscj10aGlzLnksYT10aGlzLnosbD10aGlzLnc7c3dpdGNoKGUpe2Nhc2UiWVpYIjpjb25zdCB0PW4qcithKmw7aWYodD4uNDk5JiYocz0yKk1hdGguYXRhbjIobixsKSxpPU1hdGguUEkvMixvPTApLHQ8LS40OTkmJihzPS0yKk1hdGguYXRhbjIobixsKSxpPS1NYXRoLlBJLzIsbz0wKSxpc05hTihzKSl7Y29uc3QgZT1uKm4saD1yKnIsYz1hKmE7cz1NYXRoLmF0YW4yKDIqcipsLTIqbiphLDEtMipoLTIqYyksaT1NYXRoLmFzaW4oMip0KSxvPU1hdGguYXRhbjIoMipuKmwtMipyKmEsMS0yKmUtMipjKX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiRXVsZXIgb3JkZXIgIitlKyIgbm90IHN1cHBvcnRlZCB5ZXQuIil9dC55PXMsdC56PWksdC54PW99c2V0RnJvbUV1bGVyKHQsZSxzLGk9IlhZWiIpe2NvbnN0IG89TWF0aC5jb3ModC8yKSxuPU1hdGguY29zKGUvMikscj1NYXRoLmNvcyhzLzIpLGE9TWF0aC5zaW4odC8yKSxsPU1hdGguc2luKGUvMiksaD1NYXRoLnNpbihzLzIpO3JldHVybiJYWVoiPT09aT8odGhpcy54PWEqbipyK28qbCpoLHRoaXMueT1vKmwqci1hKm4qaCx0aGlzLno9bypuKmgrYSpsKnIsdGhpcy53PW8qbipyLWEqbCpoKToiWVhaIj09PWk/KHRoaXMueD1hKm4qcitvKmwqaCx0aGlzLnk9bypsKnItYSpuKmgsdGhpcy56PW8qbipoLWEqbCpyLHRoaXMudz1vKm4qcithKmwqaCk6IlpYWSI9PT1pPyh0aGlzLng9YSpuKnItbypsKmgsdGhpcy55PW8qbCpyK2EqbipoLHRoaXMuej1vKm4qaCthKmwqcix0aGlzLnc9bypuKnItYSpsKmgpOiJaWVgiPT09aT8odGhpcy54PWEqbipyLW8qbCpoLHRoaXMueT1vKmwqcithKm4qaCx0aGlzLno9bypuKmgtYSpsKnIsdGhpcy53PW8qbipyK2EqbCpoKToiWVpYIj09PWk/KHRoaXMueD1hKm4qcitvKmwqaCx0aGlzLnk9bypsKnIrYSpuKmgsdGhpcy56PW8qbipoLWEqbCpyLHRoaXMudz1vKm4qci1hKmwqaCk6IlhaWSI9PT1pJiYodGhpcy54PWEqbipyLW8qbCpoLHRoaXMueT1vKmwqci1hKm4qaCx0aGlzLno9bypuKmgrYSpsKnIsdGhpcy53PW8qbipyK2EqbCpoKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB1KHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9c2xlcnAoe3g6dCx5OmUsejpzLHc6aX0sbyxuPW5ldyB1KXtjb25zdCByPXRoaXMueCxhPXRoaXMueSxsPXRoaXMueixoPXRoaXMudztsZXQgYyxkLHAseSxtLHY9dCxmPWUsdz1zLHg9aTtyZXR1cm4gZD1yKnYrYSpmK2wqdytoKngsZDwwJiYoZD0tZCx2PS12LGY9LWYsdz0tdyx4PS14KSwxLWQ+MWUtNj8oYz1NYXRoLmFjb3MoZCkscD1NYXRoLnNpbihjKSx5PU1hdGguc2luKCgxLW8pKmMpL3AsbT1NYXRoLnNpbihvKmMpL3ApOih5PTEtbyxtPW8pLG4ueD15KnIrbSp2LG4ueT15KmErbSpmLG4uej15KmwrbSp3LG4udz15KmgrbSp4LG59aW50ZWdyYXRlKHQsZSxzLGkpe2k9aXx8bmV3IHU7Y29uc3Qgbz10Lngqcy54LG49dC55KnMueSxyPXQueipzLnosYT10aGlzLngsbD10aGlzLnksaD10aGlzLnosYz10aGlzLncsZD0uNSplO3JldHVybiBpLngrPWQqKG8qYytuKmgtcipsKSxpLnkrPWQqKG4qYytyKmEtbypoKSxpLnorPWQqKHIqYytvKmwtbiphKSxpLncrPWQqKC1vKmEtbipsLXIqaCksaX19Y29uc3QgZD1uZXcgaSxwPW5ldyBpO2NsYXNzIHl7Y29uc3RydWN0b3IodCl7bGV0IGU9IiI7InN0cmluZyI9PXR5cGVvZih0PXR8fHt9KT8oZT10LHQ9e30pOiJvYmplY3QiPT10eXBlb2YgdCYmKGU9IiIpLHRoaXMubmFtZT1lLHRoaXMuaWQ9eS5pZENvdW50ZXIrKyx0aGlzLmZyaWN0aW9uPXZvaWQgMCE9PXQuZnJpY3Rpb24/dC5mcmljdGlvbjotMSx0aGlzLnJlc3RpdHV0aW9uPXZvaWQgMCE9PXQucmVzdGl0dXRpb24/dC5yZXN0aXR1dGlvbjotMX19eS5pZENvdW50ZXI9MDtjbGFzcyBte2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMucG9zaXRpb249bmV3IGksdC5wb3NpdGlvbiYmdGhpcy5wb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pLHRoaXMucXVhdGVybmlvbj1uZXcgdSx0LnF1YXRlcm5pb24mJnRoaXMucXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbil9cG9pbnRUb0xvY2FsKHQsZSl7cmV0dXJuIG0ucG9pbnRUb0xvY2FsRnJhbWUodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdCxlKX1wb2ludFRvV29ybGQodCxlKXtyZXR1cm4gbS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLnBvc2l0aW9uLHRoaXMucXVhdGVybmlvbix0LGUpfXZlY3RvclRvV29ybGRGcmFtZSh0LGUpe2U9ZXx8bmV3IGk7cmV0dXJuIHRoaXMucXVhdGVybmlvbi52bXVsdCh0LGUpLGV9fWNvbnN0IHY9bmV3IHU7bS5wb2ludFRvTG9jYWxGcmFtZT0odCxlLHMsbyk9PntvPW98fG5ldyBpO3JldHVybiBzLnZzdWIodCxvKSxlLmNvbmp1Z2F0ZSh2KSx2LnZtdWx0KG8sbyksb30sbS5wb2ludFRvV29ybGRGcmFtZT0odCxlLHMsbyk9PntvPW98fG5ldyBpO3JldHVybiBlLnZtdWx0KHMsbyksby52YWRkKHQsbyksb30sbS52ZWN0b3JUb1dvcmxkRnJhbWU9KHQsZSxzKT0+KHQudm11bHQoZSxzKSxzKSxtLnZlY3RvclRvTG9jYWxGcmFtZT0odCxlLHMsbyk9PntvPW98fG5ldyBpO3JldHVybiBlLncqPS0xLGUudm11bHQocyxvKSxlLncqPS0xLG99O2NsYXNzIGYgZXh0ZW5kcyBje2NvbnN0cnVjdG9yKHQsZSxzLG89bnVsbCl7c3VwZXIoe3R5cGU6Yy50eXBlcy5DT05WRVhQT0xZSEVEUk9OfSksbz8odGhpcy52ZXJ0aWNlcz1vLnZlcnRpY2VzLm1hcCh0PT5uZXcgaSh0LngsdC55LHQueikpLHRoaXMuZmFjZXM9by5mYWNlcy5tYXAodD0+W3QuYSx0LmIsdC5jXSksdGhpcy5mYWNlTm9ybWFscz1vLmZhY2VzLm1hcCh0PT5uZXcgaSh0Lm5vcm1hbC54LHQubm9ybWFsLnksdC5ub3JtYWwueikpLHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9by5ib3VuZGluZ1NwaGVyZT9vLmJvdW5kaW5nU3BoZXJlLnJhZGl1czp0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkpOih0aGlzLnZlcnRpY2VzPXR8fFtdLHRoaXMuZmFjZXM9ZXx8W10sdGhpcy5mYWNlTm9ybWFscz1bXSx0aGlzLmNvbXB1dGVOb3JtYWxzKCksdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpKSx0aGlzLndvcmxkVmVydGljZXM9W10sdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGU9ITAsdGhpcy53b3JsZEZhY2VOb3JtYWxzPVtdLHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlPSEwLHRoaXMudW5pcXVlQXhlcz1zP3Muc2xpY2UoKTpudWxsLHRoaXMudW5pcXVlRWRnZXM9W10sdGhpcy5jb21wdXRlRWRnZXMoKX1jb21wdXRlRWRnZXMoKXtjb25zdCB0PXRoaXMuZmFjZXMsZT10aGlzLnZlcnRpY2VzLHM9dGhpcy51bmlxdWVFZGdlcztzLmxlbmd0aD0wO2NvbnN0IG89bmV3IGk7Zm9yKGxldCBpPTA7aSE9PXQubGVuZ3RoO2krKyl7Y29uc3Qgbj10W2ldLHI9bi5sZW5ndGg7Zm9yKGxldCB0PTA7dCE9PXI7dCsrKXtjb25zdCBpPSh0KzEpJXI7ZVtuW3RdXS52c3ViKGVbbltpXV0sbyksby5ub3JtYWxpemUoKTtsZXQgYT0hMTtmb3IobGV0IHQ9MDt0IT09cy5sZW5ndGg7dCsrKWlmKHNbdF0uYWxtb3N0RXF1YWxzKG8pfHxzW3RdLmFsbW9zdEVxdWFscyhvKSl7YT0hMDticmVha31hfHxzLnB1c2goby5jbG9uZSgpKX19fWNvbXB1dGVOb3JtYWxzKCl7dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg9dGhpcy5mYWNlcy5sZW5ndGg7Zm9yKGxldCB0PTA7dDx0aGlzLmZhY2VzLmxlbmd0aDt0Kyspe2ZvcihsZXQgZT0wO2U8dGhpcy5mYWNlc1t0XS5sZW5ndGg7ZSsrKWlmKCF0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbdF1bZV1dKXRocm93IG5ldyBFcnJvcigiVmVydGV4ICIrdGhpcy5mYWNlc1t0XVtlXSsiIG5vdCBmb3VuZCEiKTtjb25zdCBlPXRoaXMuZmFjZU5vcm1hbHNbdF18fG5ldyBpO3RoaXMuZ2V0RmFjZU5vcm1hbCh0LGUpLGUubmVnYXRlKGUpLHRoaXMuZmFjZU5vcm1hbHNbdF09ZTtjb25zdCBzPXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1t0XVswXV07aWYoZS5kb3Qocyk8MCl7Y29uc29sZS5lcnJvcigiLmZhY2VOb3JtYWxzWyIrdCsiXSA9IFZlYzMoIitlLnRvU3RyaW5nKCkrIikgbG9va3MgbGlrZSBpdCBwb2ludHMgaW50byB0aGUgc2hhcGU/IFRoZSB2ZXJ0aWNlcyBmb2xsb3cuIE1ha2Ugc3VyZSB0aGV5IGFyZSBvcmRlcmVkIENDVyBhcm91bmQgdGhlIG5vcm1hbCwgdXNpbmcgdGhlIHJpZ2h0IGhhbmQgcnVsZS4iKTtmb3IobGV0IGU9MDtlPHRoaXMuZmFjZXNbdF0ubGVuZ3RoO2UrKyljb25zb2xlLndhcm4oIi52ZXJ0aWNlc1siK3RoaXMuZmFjZXNbdF1bZV0rIl0gPSBWZWMzKCIrdGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW3RdW2VdXS50b1N0cmluZygpKyIpIil9fX1nZXRGYWNlTm9ybWFsKHQsZSl7Y29uc3Qgcz10aGlzLmZhY2VzW3RdLGk9dGhpcy52ZXJ0aWNlc1tzWzBdXSxvPXRoaXMudmVydGljZXNbc1sxXV0sbj10aGlzLnZlcnRpY2VzW3NbMl1dO3JldHVybiBmLmNvbXB1dGVOb3JtYWwoaSxvLG4sZSl9Y2xpcEFnYWluc3RIdWxsKHQsZSxzLG8sbixyLGEsbCxoKXtjb25zdCBjPW5ldyBpO2xldCB1PS0xLGQ9LU51bWJlci5NQVhfVkFMVUU7Zm9yKGxldCB0PTA7dDxzLmZhY2VzLmxlbmd0aDt0Kyspe2MuY29weShzLmZhY2VOb3JtYWxzW3RdKSxuLnZtdWx0KGMsYyk7Y29uc3QgZT1jLmRvdChyKTtlPmQmJihkPWUsdT10KX1jb25zdCBwPVtdO2ZvcihsZXQgdD0wO3Q8cy5mYWNlc1t1XS5sZW5ndGg7dCsrKXtjb25zdCBlPXMudmVydGljZXNbcy5mYWNlc1t1XVt0XV0scj1uZXcgaTtyLmNvcHkoZSksbi52bXVsdChyLHIpLG8udmFkZChyLHIpLHAucHVzaChyKX11Pj0wJiZ0aGlzLmNsaXBGYWNlQWdhaW5zdEh1bGwocix0LGUscCxhLGwsaCl9ZmluZFNlcGFyYXRpbmdBeGlzKHQsZSxzLG8sbixyLGEsbCl7Y29uc3QgaD1uZXcgaSxjPW5ldyBpLHU9bmV3IGksZD1uZXcgaSxwPW5ldyBpLHk9bmV3IGk7bGV0IG09TnVtYmVyLk1BWF9WQUxVRTtjb25zdCB2PXRoaXM7aWYodi51bmlxdWVBeGVzKWZvcihsZXQgaT0wO2khPT12LnVuaXF1ZUF4ZXMubGVuZ3RoO2krKyl7aWYocy52bXVsdCh2LnVuaXF1ZUF4ZXNbaV0saCksITE9PT0odz12LnRlc3RTZXBBeGlzKGgsdCxlLHMsbyxuKSkpcmV0dXJuITE7dzxtJiYobT13LHIuY29weShoKSl9ZWxzZXtjb25zdCBpPWE/YS5sZW5ndGg6di5mYWNlcy5sZW5ndGg7Zm9yKGxldCBsPTA7bDxpO2wrKyl7dmFyIGY9YT9hW2xdOmw7aWYoaC5jb3B5KHYuZmFjZU5vcm1hbHNbZl0pLHMudm11bHQoaCxoKSwhMT09PSh3PXYudGVzdFNlcEF4aXMoaCx0LGUscyxvLG4pKSlyZXR1cm4hMTt3PG0mJihtPXcsci5jb3B5KGgpKX19aWYodC51bmlxdWVBeGVzKWZvcihsZXQgaT0wO2khPT10LnVuaXF1ZUF4ZXMubGVuZ3RoO2krKyl7aWYobi52bXVsdCh0LnVuaXF1ZUF4ZXNbaV0sYyksITE9PT0odz12LnRlc3RTZXBBeGlzKGMsdCxlLHMsbyxuKSkpcmV0dXJuITE7dzxtJiYobT13LHIuY29weShjKSl9ZWxzZXtjb25zdCBpPWw/bC5sZW5ndGg6dC5mYWNlcy5sZW5ndGg7Zm9yKGxldCBhPTA7YTxpO2ErKyl7dmFyIHc7Zj1sP2xbYV06YTtpZihjLmNvcHkodC5mYWNlTm9ybWFsc1tmXSksbi52bXVsdChjLGMpLCExPT09KHc9di50ZXN0U2VwQXhpcyhjLHQsZSxzLG8sbikpKXJldHVybiExO3c8bSYmKG09dyxyLmNvcHkoYykpfX1mb3IobGV0IGk9MDtpIT09di51bmlxdWVFZGdlcy5sZW5ndGg7aSsrKXtzLnZtdWx0KHYudW5pcXVlRWRnZXNbaV0sZCk7Zm9yKGxldCBpPTA7aSE9PXQudW5pcXVlRWRnZXMubGVuZ3RoO2krKylpZihuLnZtdWx0KHQudW5pcXVlRWRnZXNbaV0scCksZC5jcm9zcyhwLHkpLCF5LmFsbW9zdFplcm8oKSl7eS5ub3JtYWxpemUoKTtjb25zdCBpPXYudGVzdFNlcEF4aXMoeSx0LGUscyxvLG4pO2lmKCExPT09aSlyZXR1cm4hMTtpPG0mJihtPWksci5jb3B5KHkpKX19cmV0dXJuIG8udnN1YihlLHUpLHUuZG90KHIpPjAmJnIubmVnYXRlKHIpLCEwfXRlc3RTZXBBeGlzKHQsZSxzLGksbyxuKXtmLnByb2plY3QodGhpcyx0LHMsaSx3KSxmLnByb2plY3QoZSx0LG8sbix4KTtjb25zdCByPXdbMF0sYT13WzFdLGw9eFswXSxoPXhbMV07aWYocjxofHxsPGEpcmV0dXJuITE7Y29uc3QgYz1yLWgsdT1sLWE7cmV0dXJuIGM8dT9jOnV9Y2FsY3VsYXRlTG9jYWxJbmVydGlhKHQsZSl7Y29uc3Qgcz1uZXcgaSxvPW5ldyBpO3RoaXMuY29tcHV0ZUxvY2FsQUFCQihvLHMpO2NvbnN0IG49cy54LW8ueCxyPXMueS1vLnksYT1zLnotby56O2UueD0xLzEyKnQqKDIqcioyKnIrMiphKjIqYSksZS55PTEvMTIqdCooMipuKjIqbisyKmEqMiphKSxlLno9MS8xMip0KigyKnIqMipyKzIqbioyKm4pfWdldFBsYW5lQ29uc3RhbnRPZkZhY2UodCl7Y29uc3QgZT10aGlzLmZhY2VzW3RdLHM9dGhpcy5mYWNlTm9ybWFsc1t0XSxpPXRoaXMudmVydGljZXNbZVswXV07cmV0dXJuLXMuZG90KGkpfWNsaXBGYWNlQWdhaW5zdEh1bGwodCxlLHMsbyxuLHIsYSl7Y29uc3QgbD1uZXcgaSxoPW5ldyBpLGM9bmV3IGksdT1uZXcgaSxkPW5ldyBpLHA9bmV3IGkseT1uZXcgaSxtPW5ldyBpLHY9dGhpcyxmPW8sdz1bXTtsZXQgeD0tMSxnPU51bWJlci5NQVhfVkFMVUU7Zm9yKGxldCBlPTA7ZTx2LmZhY2VzLmxlbmd0aDtlKyspe2wuY29weSh2LmZhY2VOb3JtYWxzW2VdKSxzLnZtdWx0KGwsbCk7Y29uc3QgaT1sLmRvdCh0KTtpPGcmJihnPWkseD1lKX1pZih4PDApcmV0dXJuO2NvbnN0IGI9di5mYWNlc1t4XTtiLmNvbm5lY3RlZEZhY2VzPVtdO2ZvcihsZXQgdD0wO3Q8di5mYWNlcy5sZW5ndGg7dCsrKWZvcihsZXQgZT0wO2U8di5mYWNlc1t0XS5sZW5ndGg7ZSsrKS0xIT09Yi5pbmRleE9mKHYuZmFjZXNbdF1bZV0pJiZ0IT09eCYmLTE9PT1iLmNvbm5lY3RlZEZhY2VzLmluZGV4T2YodCkmJmIuY29ubmVjdGVkRmFjZXMucHVzaCh0KTtjb25zdCBBPWIubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8QTt0Kyspe2NvbnN0IGk9di52ZXJ0aWNlc1tiW3RdXSxvPXYudmVydGljZXNbYlsodCsxKSVBXV07aS52c3ViKG8saCksYy5jb3B5KGgpLHMudm11bHQoYyxjKSxlLnZhZGQoYyxjKSx1LmNvcHkodGhpcy5mYWNlTm9ybWFsc1t4XSkscy52bXVsdCh1LHUpLGUudmFkZCh1LHUpLGMuY3Jvc3ModSxkKSxkLm5lZ2F0ZShkKSxwLmNvcHkoaSkscy52bXVsdChwLHApLGUudmFkZChwLHApO2xldCBuLHI9LXAuZG90KGQpLGE9Yi5jb25uZWN0ZWRGYWNlc1t0XTtpZihudWxsIT1hKXt5LmNvcHkodGhpcy5mYWNlTm9ybWFsc1thXSk7Y29uc3QgdD10aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UoYSk7bS5jb3B5KHkpLHMudm11bHQobSxtKSxlLnZhZGQobSxtKSxuPXQtbS5kb3QoZSl9ZWxzZSBtLmNvcHkoZCksbj1yO2Zvcih0aGlzLmNsaXBGYWNlQWdhaW5zdFBsYW5lKGYsdyxtLG4pO2YubGVuZ3RoOylmLnNoaWZ0KCk7Zm9yKDt3Lmxlbmd0aDspZi5wdXNoKHcuc2hpZnQoKSl9eS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbeF0pO2NvbnN0IEI9dGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKHgpO20uY29weSh5KSxzLnZtdWx0KG0sbSk7Y29uc3QgRT1CLW0uZG90KGUpO2ZvcihsZXQgdD0wO3Q8Zi5sZW5ndGg7dCsrKXtsZXQgZT1tLmRvdChmW3RdKStFO2lmKGU8PW4mJihjb25zb2xlLmxvZygiY2xhbXBlZDogZGVwdGg9IitlKyIgdG8gbWluRGlzdD0iK24pLGU9biksZTw9cil7Y29uc3Qgcz1mW3RdO2lmKGU8PTFlLTYpe2NvbnN0IHQ9e3BvaW50OnMsbm9ybWFsOm0sZGVwdGg6ZX07YS5wdXNoKHQpfX19fWNsaXBGYWNlQWdhaW5zdFBsYW5lKHQsZSxzLG8pe2xldCBuLHI7Y29uc3QgYT10Lmxlbmd0aDtpZihhPDIpcmV0dXJuIGU7bGV0IGw9dFt0Lmxlbmd0aC0xXSxoPXRbMF07bj1zLmRvdChsKStvO2ZvcihsZXQgdT0wO3U8YTt1Kyspe2lmKGg9dFt1XSxyPXMuZG90KGgpK28sbjwwKWlmKHI8MCl7KGM9bmV3IGkpLmNvcHkoaCksZS5wdXNoKGMpfWVsc2V7dmFyIGM9bmV3IGk7bC5sZXJwKGgsbi8obi1yKSxjKSxlLnB1c2goYyl9ZWxzZSBpZihyPDApe2M9bmV3IGk7bC5sZXJwKGgsbi8obi1yKSxjKSxlLnB1c2goYyksZS5wdXNoKGgpfWw9aCxuPXJ9cmV0dXJuIGV9Y29tcHV0ZVdvcmxkVmVydGljZXModCxlKXtmb3IoO3RoaXMud29ybGRWZXJ0aWNlcy5sZW5ndGg8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7KXRoaXMud29ybGRWZXJ0aWNlcy5wdXNoKG5ldyBpKTtjb25zdCBzPXRoaXMudmVydGljZXMsbz10aGlzLndvcmxkVmVydGljZXM7Zm9yKGxldCBpPTA7aSE9PXRoaXMudmVydGljZXMubGVuZ3RoO2krKyllLnZtdWx0KHNbaV0sb1tpXSksdC52YWRkKG9baV0sb1tpXSk7dGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGU9ITF9Y29tcHV0ZUxvY2FsQUFCQih0LGUpe2NvbnN0IHM9dGhpcy52ZXJ0aWNlczt0LnNldChOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSksZS5zZXQoLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUpO2ZvcihsZXQgaT0wO2k8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7aSsrKXtjb25zdCBvPXNbaV07by54PHQueD90Lng9by54Om8ueD5lLngmJihlLng9by54KSxvLnk8dC55P3QueT1vLnk6by55PmUueSYmKGUueT1vLnkpLG8uejx0Lno/dC56PW8uejpvLno+ZS56JiYoZS56PW8ueil9fWNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHQpe2NvbnN0IGU9dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7Zm9yKDt0aGlzLndvcmxkRmFjZU5vcm1hbHMubGVuZ3RoPGU7KXRoaXMud29ybGRGYWNlTm9ybWFscy5wdXNoKG5ldyBpKTtjb25zdCBzPXRoaXMuZmFjZU5vcm1hbHMsbz10aGlzLndvcmxkRmFjZU5vcm1hbHM7Zm9yKGxldCBpPTA7aSE9PWU7aSsrKXQudm11bHQoc1tpXSxvW2ldKTt0aGlzLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZT0hMX11cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpe2xldCB0PTA7Y29uc3QgZT10aGlzLnZlcnRpY2VzO2ZvcihsZXQgcz0wO3MhPT1lLmxlbmd0aDtzKyspe2NvbnN0IGk9ZVtzXS5ub3JtMigpO2k+dCYmKHQ9aSl9dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz1NYXRoLnNxcnQodCl9Y2FsY3VsYXRlV29ybGRBQUJCKHQsZSxzLG8pe2NvbnN0IG49dGhpcy52ZXJ0aWNlcztsZXQgcixhLGwsaCxjLHUsZD1uZXcgaTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7ZC5jb3B5KG5bc10pLGUudm11bHQoZCxkKSx0LnZhZGQoZCxkKTtjb25zdCBpPWQ7KGkueDxyfHx2b2lkIDA9PT1yKSYmKHI9aS54KSwoaS54Pmh8fHZvaWQgMD09PWgpJiYoaD1pLngpLChpLnk8YXx8dm9pZCAwPT09YSkmJihhPWkueSksKGkueT5jfHx2b2lkIDA9PT1jKSYmKGM9aS55KSwoaS56PGx8fHZvaWQgMD09PWwpJiYobD1pLnopLChpLno+dXx8dm9pZCAwPT09dSkmJih1PWkueil9cy5zZXQocixhLGwpLG8uc2V0KGgsYyx1KX12b2x1bWUoKXtyZXR1cm4gNCpNYXRoLlBJKnRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMvM31nZXRBdmVyYWdlUG9pbnRMb2NhbCh0PW5ldyBpKXtjb25zdCBlPXRoaXMudmVydGljZXM7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspdC52YWRkKGVbc10sdCk7cmV0dXJuIHQubXVsdCgxL2UubGVuZ3RoLHQpLHR9dHJhbnNmb3JtQWxsUG9pbnRzKHQsZSl7Y29uc3Qgcz10aGlzLnZlcnRpY2VzLmxlbmd0aCxpPXRoaXMudmVydGljZXM7aWYoZSl7Zm9yKGxldCB0PTA7dDxzO3QrKyl7dmFyIG89aVt0XTtlLnZtdWx0KG8sbyl9Zm9yKGxldCB0PTA7dDx0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDt0Kyspe289dGhpcy5mYWNlTm9ybWFsc1t0XTtlLnZtdWx0KG8sbyl9fWlmKHQpZm9yKGxldCBlPTA7ZTxzO2UrKyl7KG89aVtlXSkudmFkZCh0LG8pfX1wb2ludElzSW5zaWRlKHQpe2NvbnN0IGU9dGhpcy52ZXJ0aWNlcyxzPXRoaXMuZmFjZXMsbz10aGlzLmZhY2VOb3JtYWxzLG49bmV3IGk7dGhpcy5nZXRBdmVyYWdlUG9pbnRMb2NhbChuKTtmb3IobGV0IHI9MDtyPHRoaXMuZmFjZXMubGVuZ3RoO3IrKyl7bGV0IGE9b1tyXTtjb25zdCBsPWVbc1tyXVswXV0saD1uZXcgaTt0LnZzdWIobCxoKTtjb25zdCBjPWEuZG90KGgpLHU9bmV3IGk7bi52c3ViKGwsdSk7Y29uc3QgZD1hLmRvdCh1KTtpZihjPDAmJmQ+MHx8Yz4wJiZkPDApcmV0dXJuITF9cmV0dXJuLTF9fWYuY29tcHV0ZU5vcm1hbD0odCxlLHMsbyk9Pntjb25zdCBuPW5ldyBpLHI9bmV3IGk7ZS52c3ViKHQscikscy52c3ViKGUsbiksbi5jcm9zcyhyLG8pLG8uaXNaZXJvKCl8fG8ubm9ybWFsaXplKCl9O2NvbnN0IHc9W10seD1bXTtmLnByb2plY3Q9KHt2ZXJ0aWNlczp0fSxlLHMsbyxuKT0+e2NvbnN0IHI9dC5sZW5ndGgsYT1uZXcgaTtsZXQgbD0wLGg9MDtjb25zdCBjPW5ldyBpLHU9dDtjLnNldFplcm8oKSxtLnZlY3RvclRvTG9jYWxGcmFtZShzLG8sZSxhKSxtLnBvaW50VG9Mb2NhbEZyYW1lKHMsbyxjLGMpO2NvbnN0IGQ9Yy5kb3QoYSk7aD1sPXVbMF0uZG90KGEpO2ZvcihsZXQgdD0xO3Q8cjt0Kyspe2NvbnN0IGU9dVt0XS5kb3QoYSk7ZT5sJiYobD1lKSxlPGgmJihoPWUpfWlmKGgtPWQsbC09ZCxoPmwpe2NvbnN0IHQ9aDtoPWwsbD10fW5bMF09bCxuWzFdPWh9O2NsYXNzIGcgZXh0ZW5kcyBje2NvbnN0cnVjdG9yKHQpe3N1cGVyKHt0eXBlOmMudHlwZXMuQk9YfSksdGhpcy5oYWxmRXh0ZW50cz10LHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uPW51bGwsdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl9dXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uKCl7Y29uc3QgdD10aGlzLmhhbGZFeHRlbnRzLngsZT10aGlzLmhhbGZFeHRlbnRzLnkscz10aGlzLmhhbGZFeHRlbnRzLnosbz1pLG49W25ldyBvKC10LC1lLC1zKSxuZXcgbyh0LC1lLC1zKSxuZXcgbyh0LGUsLXMpLG5ldyBvKC10LGUsLXMpLG5ldyBvKC10LC1lLHMpLG5ldyBvKHQsLWUscyksbmV3IG8odCxlLHMpLG5ldyBvKC10LGUscyldLHI9W25ldyBvKDAsMCwxKSxuZXcgbygwLDEsMCksbmV3IG8oMSwwLDApXSxhPW5ldyBmKG4sW1szLDIsMSwwXSxbNCw1LDYsN10sWzUsNCwwLDFdLFsyLDMsNyw2XSxbMCw0LDcsM10sWzEsMiw2LDVdXSxyKTt0aGlzLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbj1hLGEubWF0ZXJpYWw9dGhpcy5tYXRlcmlhbH1jYWxjdWxhdGVMb2NhbEluZXJ0aWEodCxlPW5ldyBpKXtyZXR1cm4gZy5jYWxjdWxhdGVJbmVydGlhKHRoaXMuaGFsZkV4dGVudHMsdCxlKSxlfWdldFNpZGVOb3JtYWxzKHQsZSl7Y29uc3Qgcz10LGk9dGhpcy5oYWxmRXh0ZW50cztpZihzWzBdLnNldChpLngsMCwwKSxzWzFdLnNldCgwLGkueSwwKSxzWzJdLnNldCgwLDAsaS56KSxzWzNdLnNldCgtaS54LDAsMCksc1s0XS5zZXQoMCwtaS55LDApLHNbNV0uc2V0KDAsMCwtaS56KSx2b2lkIDAhPT1lKWZvcihsZXQgdD0wO3QhPT1zLmxlbmd0aDt0KyspZS52bXVsdChzW3RdLHNbdF0pO3JldHVybiBzfXZvbHVtZSgpe3JldHVybiA4KnRoaXMuaGFsZkV4dGVudHMueCp0aGlzLmhhbGZFeHRlbnRzLnkqdGhpcy5oYWxmRXh0ZW50cy56fXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz10aGlzLmhhbGZFeHRlbnRzLm5vcm0oKX1mb3JFYWNoV29ybGRDb3JuZXIodCxlLHMpe2NvbnN0IGk9dGhpcy5oYWxmRXh0ZW50cyxvPVtbaS54LGkueSxpLnpdLFstaS54LGkueSxpLnpdLFstaS54LC1pLnksaS56XSxbLWkueCwtaS55LC1pLnpdLFtpLngsLWkueSwtaS56XSxbaS54LGkueSwtaS56XSxbLWkueCxpLnksLWkuel0sW2kueCwtaS55LGkuel1dO2ZvcihsZXQgaT0wO2k8by5sZW5ndGg7aSsrKWIuc2V0KG9baV1bMF0sb1tpXVsxXSxvW2ldWzJdKSxlLnZtdWx0KGIsYiksdC52YWRkKGIsYikscyhiLngsYi55LGIueil9Y2FsY3VsYXRlV29ybGRBQUJCKHQsZSxzLGkpe2NvbnN0IG89dGhpcy5oYWxmRXh0ZW50cztBWzBdLnNldChvLngsby55LG8ueiksQVsxXS5zZXQoLW8ueCxvLnksby56KSxBWzJdLnNldCgtby54LC1vLnksby56KSxBWzNdLnNldCgtby54LC1vLnksLW8ueiksQVs0XS5zZXQoby54LC1vLnksLW8ueiksQVs1XS5zZXQoby54LG8ueSwtby56KSxBWzZdLnNldCgtby54LG8ueSwtby56KSxBWzddLnNldChvLngsLW8ueSxvLnopO3ZhciBuPUFbMF07ZS52bXVsdChuLG4pLHQudmFkZChuLG4pLGkuY29weShuKSxzLmNvcHkobik7Zm9yKGxldCBvPTE7bzw4O28rKyl7bj1BW29dO2Uudm11bHQobixuKSx0LnZhZGQobixuKTtjb25zdCByPW4ueCxhPW4ueSxsPW4uejtyPmkueCYmKGkueD1yKSxhPmkueSYmKGkueT1hKSxsPmkueiYmKGkuej1sKSxyPHMueCYmKHMueD1yKSxhPHMueSYmKHMueT1hKSxsPHMueiYmKHMuej1sKX19fWcuY2FsY3VsYXRlSW5lcnRpYT0odCxlLHMpPT57Y29uc3QgaT10O3MueD0xLzEyKmUqKDIqaS55KjIqaS55KzIqaS56KjIqaS56KSxzLnk9MS8xMiplKigyKmkueCoyKmkueCsyKmkueioyKmkueikscy56PTEvMTIqZSooMippLnkqMippLnkrMippLngqMippLngpfTtjb25zdCBiPW5ldyBpLEE9W25ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpLG5ldyBpXTtjbGFzcyBCIGV4dGVuZHMgaHtjb25zdHJ1Y3Rvcih0PXt9KXtzdXBlcigpLHRoaXMuaWQ9Qi5pZENvdW50ZXIrKyx0aGlzLndvcmxkPW51bGwsdGhpcy5wcmVTdGVwPW51bGwsdGhpcy5wb3N0U3RlcD1udWxsLHRoaXMudmxhbWJkYT1uZXcgaSx0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwPSJudW1iZXIiPT10eXBlb2YgdC5jb2xsaXNpb25GaWx0ZXJHcm91cD90LmNvbGxpc2lvbkZpbHRlckdyb3VwOjEsdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrPSJudW1iZXIiPT10eXBlb2YgdC5jb2xsaXNpb25GaWx0ZXJNYXNrP3QuY29sbGlzaW9uRmlsdGVyTWFzazotMSx0aGlzLmNvbGxpc2lvblJlc3BvbnNlPSEwLHRoaXMucG9zaXRpb249bmV3IGksdGhpcy5wcmV2aW91c1Bvc2l0aW9uPW5ldyBpLHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb249bmV3IGksdGhpcy5pbml0UG9zaXRpb249bmV3IGksdC5wb3NpdGlvbiYmKHRoaXMucG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uLmNvcHkodC5wb3NpdGlvbiksdGhpcy5pbml0UG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSksdGhpcy52ZWxvY2l0eT1uZXcgaSx0LnZlbG9jaXR5JiZ0aGlzLnZlbG9jaXR5LmNvcHkodC52ZWxvY2l0eSksdGhpcy5pbml0VmVsb2NpdHk9bmV3IGksdGhpcy5mb3JjZT1uZXcgaTtjb25zdCBlPSJudW1iZXIiPT10eXBlb2YgdC5tYXNzP3QubWFzczowO3RoaXMubWFzcz1lLHRoaXMuaW52TWFzcz1lPjA/MS9lOjAsdGhpcy5tYXRlcmlhbD10Lm1hdGVyaWFsfHxudWxsLHRoaXMubGluZWFyRGFtcGluZz0ibnVtYmVyIj09dHlwZW9mIHQubGluZWFyRGFtcGluZz90LmxpbmVhckRhbXBpbmc6LjAxLHRoaXMudHlwZT1lPD0wP0IuU1RBVElDOkIuRFlOQU1JQyx0eXBlb2YgdC50eXBlPT10eXBlb2YgQi5TVEFUSUMmJih0aGlzLnR5cGU9dC50eXBlKSx0aGlzLmFsbG93U2xlZXA9dm9pZCAwPT09dC5hbGxvd1NsZWVwfHx0LmFsbG93U2xlZXAsdGhpcy5zbGVlcFN0YXRlPTAsdGhpcy5zbGVlcFNwZWVkTGltaXQ9dm9pZCAwIT09dC5zbGVlcFNwZWVkTGltaXQ/dC5zbGVlcFNwZWVkTGltaXQ6LjEsdGhpcy5zbGVlcFRpbWVMaW1pdD12b2lkIDAhPT10LnNsZWVwVGltZUxpbWl0P3Quc2xlZXBUaW1lTGltaXQ6MSx0aGlzLnRpbWVMYXN0U2xlZXB5PTAsdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZT0hMSx0aGlzLnRvcnF1ZT1uZXcgaSx0aGlzLnF1YXRlcm5pb249bmV3IHUsdGhpcy5pbml0UXVhdGVybmlvbj1uZXcgdSx0aGlzLnByZXZpb3VzUXVhdGVybmlvbj1uZXcgdSx0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb249bmV3IHUsdC5xdWF0ZXJuaW9uJiYodGhpcy5xdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKSx0aGlzLmluaXRRdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKSx0aGlzLnByZXZpb3VzUXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbiksdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uLmNvcHkodC5xdWF0ZXJuaW9uKSksdGhpcy5hbmd1bGFyVmVsb2NpdHk9bmV3IGksdC5hbmd1bGFyVmVsb2NpdHkmJnRoaXMuYW5ndWxhclZlbG9jaXR5LmNvcHkodC5hbmd1bGFyVmVsb2NpdHkpLHRoaXMuaW5pdEFuZ3VsYXJWZWxvY2l0eT1uZXcgaSx0aGlzLnNoYXBlcz1bXSx0aGlzLnNoYXBlT2Zmc2V0cz1bXSx0aGlzLnNoYXBlT3JpZW50YXRpb25zPVtdLHRoaXMuaW5lcnRpYT1uZXcgaSx0aGlzLmludkluZXJ0aWE9bmV3IGksdGhpcy5pbnZJbmVydGlhV29ybGQ9bmV3IHMsdGhpcy5pbnZNYXNzU29sdmU9MCx0aGlzLmludkluZXJ0aWFTb2x2ZT1uZXcgaSx0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlPW5ldyBzLHRoaXMuZml4ZWRSb3RhdGlvbj12b2lkIDAhPT10LmZpeGVkUm90YXRpb24mJnQuZml4ZWRSb3RhdGlvbix0aGlzLmFuZ3VsYXJEYW1waW5nPXZvaWQgMCE9PXQuYW5ndWxhckRhbXBpbmc/dC5hbmd1bGFyRGFtcGluZzouMDEsdGhpcy5saW5lYXJGYWN0b3I9bmV3IGkoMSwxLDEpLHQubGluZWFyRmFjdG9yJiZ0aGlzLmxpbmVhckZhY3Rvci5jb3B5KHQubGluZWFyRmFjdG9yKSx0aGlzLmFuZ3VsYXJGYWN0b3I9bmV3IGkoMSwxLDEpLHQuYW5ndWxhckZhY3RvciYmdGhpcy5hbmd1bGFyRmFjdG9yLmNvcHkodC5hbmd1bGFyRmFjdG9yKSx0aGlzLmFhYmI9bmV3IG4sdGhpcy5hYWJiTmVlZHNVcGRhdGU9ITAsdGhpcy5ib3VuZGluZ1JhZGl1cz0wLHRoaXMud2xhbWJkYT1uZXcgaSx0LnNoYXBlJiZ0aGlzLmFkZFNoYXBlKHQuc2hhcGUpLHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKX13YWtlVXAoKXtjb25zdCB0PXRoaXMuc2xlZXBTdGF0ZTt0aGlzLnNsZWVwU3RhdGU9MCx0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlPSExLHQ9PT1CLlNMRUVQSU5HJiZ0aGlzLmRpc3BhdGNoRXZlbnQoQi53YWtldXBFdmVudCl9c2xlZXAoKXt0aGlzLnNsZWVwU3RhdGU9Qi5TTEVFUElORyx0aGlzLnZlbG9jaXR5LnNldCgwLDAsMCksdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKSx0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlPSExfXNsZWVwVGljayh0KXtpZih0aGlzLmFsbG93U2xlZXApe2NvbnN0IGU9dGhpcy5zbGVlcFN0YXRlLHM9dGhpcy52ZWxvY2l0eS5ub3JtMigpK3RoaXMuYW5ndWxhclZlbG9jaXR5Lm5vcm0yKCksaT10aGlzLnNsZWVwU3BlZWRMaW1pdCoqMjtlPT09Qi5BV0FLRSYmczxpPyh0aGlzLnNsZWVwU3RhdGU9Qi5TTEVFUFksdGhpcy50aW1lTGFzdFNsZWVweT10LHRoaXMuZGlzcGF0Y2hFdmVudChCLnNsZWVweUV2ZW50KSk6ZT09PUIuU0xFRVBZJiZzPmk/dGhpcy53YWtlVXAoKTplPT09Qi5TTEVFUFkmJnQtdGhpcy50aW1lTGFzdFNsZWVweT50aGlzLnNsZWVwVGltZUxpbWl0JiYodGhpcy5zbGVlcCgpLHRoaXMuZGlzcGF0Y2hFdmVudChCLnNsZWVwRXZlbnQpKX19dXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpe3RoaXMuc2xlZXBTdGF0ZT09PUIuU0xFRVBJTkd8fHRoaXMudHlwZT09PUIuS0lORU1BVElDPyh0aGlzLmludk1hc3NTb2x2ZT0wLHRoaXMuaW52SW5lcnRpYVNvbHZlLnNldFplcm8oKSx0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLnNldFplcm8oKSk6KHRoaXMuaW52TWFzc1NvbHZlPXRoaXMuaW52TWFzcyx0aGlzLmludkluZXJ0aWFTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYSksdGhpcy5pbnZJbmVydGlhV29ybGRTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYVdvcmxkKSl9cG9pbnRUb0xvY2FsRnJhbWUodCxlKXtlPWV8fG5ldyBpO3JldHVybiB0LnZzdWIodGhpcy5wb3NpdGlvbixlKSx0aGlzLnF1YXRlcm5pb24uY29uanVnYXRlKCkudm11bHQoZSxlKSxlfXZlY3RvclRvTG9jYWxGcmFtZSh0LGUpe2U9ZXx8bmV3IGk7cmV0dXJuIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh0LGUpLGV9cG9pbnRUb1dvcmxkRnJhbWUodCxlKXtlPWV8fG5ldyBpO3JldHVybiB0aGlzLnF1YXRlcm5pb24udm11bHQodCxlKSxlLnZhZGQodGhpcy5wb3NpdGlvbixlKSxlfXZlY3RvclRvV29ybGRGcmFtZSh0LGUpe2U9ZXx8bmV3IGk7cmV0dXJuIHRoaXMucXVhdGVybmlvbi52bXVsdCh0LGUpLGV9YWRkU2hhcGUodCxlLHMpe2NvbnN0IG89bmV3IGksbj1uZXcgdTtyZXR1cm4gZSYmby5jb3B5KGUpLHMmJm4uY29weShzKSx0aGlzLnNoYXBlcy5wdXNoKHQpLHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gobyksdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKG4pLHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKSx0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCksdGhpcy5hYWJiTmVlZHNVcGRhdGU9ITAsdC5ib2R5PXRoaXMsdGhpc311cGRhdGVCb3VuZGluZ1JhZGl1cygpe2NvbnN0IHQ9dGhpcy5zaGFwZXMsZT10aGlzLnNoYXBlT2Zmc2V0cyxzPXQubGVuZ3RoO2xldCBpPTA7Zm9yKGxldCBvPTA7byE9PXM7bysrKXtjb25zdCBzPXRbb107cy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO2NvbnN0IG49ZVtvXS5ub3JtKCkscj1zLmJvdW5kaW5nU3BoZXJlUmFkaXVzO24rcj5pJiYoaT1uK3IpfXRoaXMuYm91bmRpbmdSYWRpdXM9aX1jb21wdXRlQUFCQigpe2NvbnN0IHQ9dGhpcy5zaGFwZXMsZT10aGlzLnNoYXBlT2Zmc2V0cyxzPXRoaXMuc2hhcGVPcmllbnRhdGlvbnMsaT10Lmxlbmd0aCxvPUUsbj16LHI9dGhpcy5xdWF0ZXJuaW9uLGE9dGhpcy5hYWJiLGw9Uztmb3IobGV0IGg9MDtoIT09aTtoKyspe2NvbnN0IGk9dFtoXTtyLnZtdWx0KGVbaF0sbyksby52YWRkKHRoaXMucG9zaXRpb24sbyksci5tdWx0KHNbaF0sbiksaS5jYWxjdWxhdGVXb3JsZEFBQkIobyxuLGwubG93ZXJCb3VuZCxsLnVwcGVyQm91bmQpLDA9PT1oP2EuY29weShsKTphLmV4dGVuZChsKX10aGlzLmFhYmJOZWVkc1VwZGF0ZT0hMX11cGRhdGVJbmVydGlhV29ybGQodCl7Y29uc3QgZT10aGlzLmludkluZXJ0aWE7aWYoZS54IT09ZS55fHxlLnkhPT1lLnp8fHQpe2NvbnN0IHQ9RixzPU07dC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbiksdC50cmFuc3Bvc2UocyksdC5zY2FsZShlLHQpLHQubW11bHQocyx0aGlzLmludkluZXJ0aWFXb3JsZCl9ZWxzZTt9YXBwbHlGb3JjZSh0LGUpe2lmKHRoaXMudHlwZSE9PUIuRFlOQU1JQylyZXR1cm47Y29uc3Qgcz1DO2UuY3Jvc3ModCxzKSx0aGlzLmZvcmNlLnZhZGQodCx0aGlzLmZvcmNlKSx0aGlzLnRvcnF1ZS52YWRkKHMsdGhpcy50b3JxdWUpfWFwcGx5TG9jYWxGb3JjZSh0LGUpe2lmKHRoaXMudHlwZSE9PUIuRFlOQU1JQylyZXR1cm47Y29uc3Qgcz1xLGk9VDt0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh0LHMpLHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGUsaSksdGhpcy5hcHBseUZvcmNlKHMsaSl9YXBwbHlJbXB1bHNlKHQsZSl7aWYodGhpcy50eXBlIT09Qi5EWU5BTUlDKXJldHVybjtjb25zdCBzPWUsaT1OO2kuY29weSh0KSxpLm11bHQodGhpcy5pbnZNYXNzLGkpLHRoaXMudmVsb2NpdHkudmFkZChpLHRoaXMudmVsb2NpdHkpO2NvbnN0IG89UDtzLmNyb3NzKHQsbyksdGhpcy5pbnZJbmVydGlhV29ybGQudm11bHQobyxvKSx0aGlzLmFuZ3VsYXJWZWxvY2l0eS52YWRkKG8sdGhpcy5hbmd1bGFyVmVsb2NpdHkpfWFwcGx5TG9jYWxJbXB1bHNlKHQsZSl7aWYodGhpcy50eXBlIT09Qi5EWU5BTUlDKXJldHVybjtjb25zdCBzPVIsaT1JO3RoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHQscyksdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUoZSxpKSx0aGlzLmFwcGx5SW1wdWxzZShzLGkpfXVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCl7Y29uc3QgdD1MO3RoaXMuaW52TWFzcz10aGlzLm1hc3M+MD8xL3RoaXMubWFzczowO2NvbnN0IGU9dGhpcy5pbmVydGlhLHM9dGhpcy5maXhlZFJvdGF0aW9uO3RoaXMuY29tcHV0ZUFBQkIoKSx0LnNldCgodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KS8yLCh0aGlzLmFhYmIudXBwZXJCb3VuZC55LXRoaXMuYWFiYi5sb3dlckJvdW5kLnkpLzIsKHRoaXMuYWFiYi51cHBlckJvdW5kLnotdGhpcy5hYWJiLmxvd2VyQm91bmQueikvMiksZy5jYWxjdWxhdGVJbmVydGlhKHQsdGhpcy5tYXNzLGUpLHRoaXMuaW52SW5lcnRpYS5zZXQoZS54PjAmJiFzPzEvZS54OjAsZS55PjAmJiFzPzEvZS55OjAsZS56PjAmJiFzPzEvZS56OjApLHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCEwKX1nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh0LGUpe2NvbnN0IHM9bmV3IGk7cmV0dXJuIHQudnN1Yih0aGlzLnBvc2l0aW9uLHMpLHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHMsZSksdGhpcy52ZWxvY2l0eS52YWRkKGUsZSksZX1pbnRlZ3JhdGUodCxlLHMpe2lmKHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24pLHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKSx0aGlzLnR5cGUhPT1CLkRZTkFNSUMmJnRoaXMudHlwZSE9PUIuS0lORU1BVElDfHx0aGlzLnNsZWVwU3RhdGU9PT1CLlNMRUVQSU5HKXJldHVybjtjb25zdCBpPXRoaXMudmVsb2NpdHksbz10aGlzLmFuZ3VsYXJWZWxvY2l0eSxuPXRoaXMucG9zaXRpb24scj10aGlzLmZvcmNlLGE9dGhpcy50b3JxdWUsbD10aGlzLnF1YXRlcm5pb24saD10aGlzLmludk1hc3MsYz10aGlzLmludkluZXJ0aWFXb3JsZCx1PXRoaXMubGluZWFyRmFjdG9yLGQ9aCp0O2kueCs9ci54KmQqdS54LGkueSs9ci55KmQqdS55LGkueis9ci56KmQqdS56O2NvbnN0IHA9Yy5lbGVtZW50cyx5PXRoaXMuYW5ndWxhckZhY3RvcixtPWEueCp5Lngsdj1hLnkqeS55LGY9YS56KnkuejtvLngrPXQqKHBbMF0qbStwWzFdKnYrcFsyXSpmKSxvLnkrPXQqKHBbM10qbStwWzRdKnYrcFs1XSpmKSxvLnorPXQqKHBbNl0qbStwWzddKnYrcFs4XSpmKSxuLngrPWkueCp0LG4ueSs9aS55KnQsbi56Kz1pLnoqdCxsLmludGVncmF0ZSh0aGlzLmFuZ3VsYXJWZWxvY2l0eSx0LHRoaXMuYW5ndWxhckZhY3RvcixsKSxlJiYocz9sLm5vcm1hbGl6ZUZhc3QoKTpsLm5vcm1hbGl6ZSgpKSx0aGlzLmFhYmJOZWVkc1VwZGF0ZT0hMCx0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCgpfX1CLkNPTExJREVfRVZFTlRfTkFNRT0iY29sbGlkZSIsQi5EWU5BTUlDPTEsQi5TVEFUSUM9MixCLktJTkVNQVRJQz00LEIuQVdBS0U9MCxCLlNMRUVQWT0xLEIuU0xFRVBJTkc9MixCLmlkQ291bnRlcj0wLEIud2FrZXVwRXZlbnQ9e3R5cGU6Indha2V1cCJ9LEIuc2xlZXB5RXZlbnQ9e3R5cGU6InNsZWVweSJ9LEIuc2xlZXBFdmVudD17dHlwZToic2xlZXAifTtjb25zdCBFPW5ldyBpLHo9bmV3IHUsUz1uZXcgbixGPW5ldyBzLE09bmV3IHMsQz1uZXcgaSxxPW5ldyBpLFQ9bmV3IGksTj1uZXcgaSxQPW5ldyBpLFI9bmV3IGksST1uZXcgaSxMPW5ldyBpO2NsYXNzIGogZXh0ZW5kcyBje2NvbnN0cnVjdG9yKCl7c3VwZXIoe3R5cGU6Yy50eXBlcy5QTEFORX0pLHRoaXMud29ybGROb3JtYWw9bmV3IGksdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlPSEwLHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9TnVtYmVyLk1BWF9WQUxVRX1jb21wdXRlV29ybGROb3JtYWwodCl7Y29uc3QgZT10aGlzLndvcmxkTm9ybWFsO2Uuc2V0KDAsMCwxKSx0LnZtdWx0KGUsZSksdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlPSExfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGU9bmV3IGkpe3JldHVybiBlfXZvbHVtZSgpe3JldHVybiBOdW1iZXIuTUFYX1ZBTFVFfWNhbGN1bGF0ZVdvcmxkQUFCQih7eDp0LHk6ZSx6OnN9LGksbyxuKXtWLnNldCgwLDAsMSksaS52bXVsdChWLFYpO2NvbnN0IHI9TnVtYmVyLk1BWF9WQUxVRTtvLnNldCgtciwtciwtciksbi5zZXQocixyLHIpLDE9PT1WLngmJihuLng9dCksMT09PVYueSYmKG4ueT1lKSwxPT09Vi56JiYobi56PXMpLC0xPT09Vi54JiYoby54PXQpLC0xPT09Vi55JiYoby55PWUpLC0xPT09Vi56JiYoby56PXMpfXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz1OdW1iZXIuTUFYX1ZBTFVFfX1jb25zdCBWPW5ldyBpO2NsYXNzIGt7Y29uc3RydWN0b3IoKXt0aGlzLndvcmxkPW51bGwsdGhpcy51c2VCb3VuZGluZ0JveGVzPSExLHRoaXMuZGlydHk9ITB9Y29sbGlzaW9uUGFpcnModCxlLHMpe3Rocm93IG5ldyBFcnJvcigiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhIil9bmVlZEJyb2FkcGhhc2VDb2xsaXNpb24odCxlKXtyZXR1cm4gMCE9KHQuY29sbGlzaW9uRmlsdGVyR3JvdXAmZS5jb2xsaXNpb25GaWx0ZXJNYXNrKSYmMCE9KGUuY29sbGlzaW9uRmlsdGVyR3JvdXAmdC5jb2xsaXNpb25GaWx0ZXJNYXNrKSYmKDA9PSh0LnR5cGUmQi5TVEFUSUMpJiZ0LnNsZWVwU3RhdGUhPT1CLlNMRUVQSU5HfHwwPT0oZS50eXBlJkIuU1RBVElDKSYmZS5zbGVlcFN0YXRlIT09Qi5TTEVFUElORyl9aW50ZXJzZWN0aW9uVGVzdCh0LGUscyxpKXt0aGlzLnVzZUJvdW5kaW5nQm94ZXM/dGhpcy5kb0JvdW5kaW5nQm94QnJvYWRwaGFzZSh0LGUscyxpKTp0aGlzLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKHQsZSxzLGkpfWRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKHQsZSxzLGkpe2NvbnN0IG89VztlLnBvc2l0aW9uLnZzdWIodC5wb3NpdGlvbixvKTtjb25zdCBuPSh0LmJvdW5kaW5nUmFkaXVzK2UuYm91bmRpbmdSYWRpdXMpKioyO28ubm9ybTIoKTxuJiYocy5wdXNoKHQpLGkucHVzaChlKSl9ZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UodCxlLHMsaSl7dC5hYWJiTmVlZHNVcGRhdGUmJnQuY29tcHV0ZUFBQkIoKSxlLmFhYmJOZWVkc1VwZGF0ZSYmZS5jb21wdXRlQUFCQigpLHQuYWFiYi5vdmVybGFwcyhlLmFhYmIpJiYocy5wdXNoKHQpLGkucHVzaChlKSl9bWFrZVBhaXJzVW5pcXVlKHQsZSl7Y29uc3Qgcz1PLGk9XyxvPUgsbj10Lmxlbmd0aDtmb3IodmFyIHI9MDtyIT09bjtyKyspaVtyXT10W3JdLG9bcl09ZVtyXTt0Lmxlbmd0aD0wLGUubGVuZ3RoPTA7Zm9yKHI9MDtyIT09bjtyKyspe2NvbnN0IHQ9aVtyXS5pZCxlPW9bcl0uaWQ7c1thPXQ8ZT90KyIsIitlOmUrIiwiK3RdPXIscy5rZXlzLnB1c2goYSl9Zm9yKHI9MDtyIT09cy5rZXlzLmxlbmd0aDtyKyspe3ZhciBhPXMua2V5cy5wb3AoKTtjb25zdCBuPXNbYV07dC5wdXNoKGlbbl0pLGUucHVzaChvW25dKSxkZWxldGUgc1thXX19c2V0V29ybGQodCl7fWFhYmJRdWVyeSh0LGUscyl7cmV0dXJuIGNvbnNvbGUud2FybigiLmFhYmJRdWVyeSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBCcm9hZHBoYXNlIHN1YmNsYXNzLiIpLFtdfX1jb25zdCBXPW5ldyBpLE89e2tleXM6W119LF89W10sSD1bXTtrLmJvdW5kaW5nU3BoZXJlQ2hlY2s9KHQsZSk9Pntjb25zdCBzPW5ldyBpO3QucG9zaXRpb24udnN1YihlLnBvc2l0aW9uLHMpO2NvbnN0IG89dC5zaGFwZXNbMF0sbj1lLnNoYXBlc1swXTtyZXR1cm4gTWF0aC5wb3coby5ib3VuZGluZ1NwaGVyZVJhZGl1cytuLmJvdW5kaW5nU3BoZXJlUmFkaXVzLDIpPnMubm9ybTIoKX07Y2xhc3MgVSBleHRlbmRzIGt7Y29uc3RydWN0b3IoKXtzdXBlcigpfWNvbGxpc2lvblBhaXJzKHQsZSxzKXtjb25zdCBpPXQuYm9kaWVzLG89aS5sZW5ndGg7bGV0IG4scixhLGw7Zm9yKG49MDtuIT09bztuKyspZm9yKHI9MDtyIT09bjtyKyspYT1pW25dLGw9aVtyXSx0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGEsbCkmJnRoaXMuaW50ZXJzZWN0aW9uVGVzdChhLGwsZSxzKX1hYWJiUXVlcnkoe2JvZGllczp0fSxlLHM9W10pe2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCBvPXRbaV07by5hYWJiTmVlZHNVcGRhdGUmJm8uY29tcHV0ZUFBQkIoKSxvLmFhYmIub3ZlcmxhcHMoZSkmJnMucHVzaChvKX1yZXR1cm4gc319Y2xhc3MgRHtjb25zdHJ1Y3Rvcigpe3RoaXMucmF5RnJvbVdvcmxkPW5ldyBpLHRoaXMucmF5VG9Xb3JsZD1uZXcgaSx0aGlzLmhpdE5vcm1hbFdvcmxkPW5ldyBpLHRoaXMuaGl0UG9pbnRXb3JsZD1uZXcgaSx0aGlzLmhhc0hpdD0hMSx0aGlzLnNoYXBlPW51bGwsdGhpcy5ib2R5PW51bGwsdGhpcy5oaXRGYWNlSW5kZXg9LTEsdGhpcy5kaXN0YW5jZT0tMSx0aGlzLl9zaG91bGRTdG9wPSExfXJlc2V0KCl7dGhpcy5yYXlGcm9tV29ybGQuc2V0WmVybygpLHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCksdGhpcy5oaXROb3JtYWxXb3JsZC5zZXRaZXJvKCksdGhpcy5oaXRQb2ludFdvcmxkLnNldFplcm8oKSx0aGlzLmhhc0hpdD0hMSx0aGlzLnNoYXBlPW51bGwsdGhpcy5ib2R5PW51bGwsdGhpcy5oaXRGYWNlSW5kZXg9LTEsdGhpcy5kaXN0YW5jZT0tMSx0aGlzLl9zaG91bGRTdG9wPSExfWFib3J0KCl7dGhpcy5fc2hvdWxkU3RvcD0hMH1zZXQodCxlLHMsaSxvLG4scil7dGhpcy5yYXlGcm9tV29ybGQuY29weSh0KSx0aGlzLnJheVRvV29ybGQuY29weShlKSx0aGlzLmhpdE5vcm1hbFdvcmxkLmNvcHkocyksdGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaSksdGhpcy5zaGFwZT1vLHRoaXMuYm9keT1uLHRoaXMuZGlzdGFuY2U9cn19Y2xhc3MgR3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZnJvbT10P3QuY2xvbmUoKTpuZXcgaSx0aGlzLnRvPWU/ZS5jbG9uZSgpOm5ldyBpLHRoaXMuX2RpcmVjdGlvbj1uZXcgaSx0aGlzLnByZWNpc2lvbj0xZS00LHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT0hMCx0aGlzLnNraXBCYWNrZmFjZXM9ITEsdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xLHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTEsdGhpcy5tb2RlPUcuQU5ZLHRoaXMucmVzdWx0PW5ldyBELHRoaXMuaGFzSGl0PSExLHRoaXMuY2FsbGJhY2s9dD0+e319aW50ZXJzZWN0V29ybGQodCxlKXtyZXR1cm4gdGhpcy5tb2RlPWUubW9kZXx8Ry5BTlksdGhpcy5yZXN1bHQ9ZS5yZXN1bHR8fG5ldyBELHRoaXMuc2tpcEJhY2tmYWNlcz0hIWUuc2tpcEJhY2tmYWNlcyx0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2s9dm9pZCAwIT09ZS5jb2xsaXNpb25GaWx0ZXJNYXNrP2UuY29sbGlzaW9uRmlsdGVyTWFzazotMSx0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwPXZvaWQgMCE9PWUuY29sbGlzaW9uRmlsdGVyR3JvdXA/ZS5jb2xsaXNpb25GaWx0ZXJHcm91cDotMSx0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dm9pZCAwPT09ZS5jaGVja0NvbGxpc2lvblJlc3BvbnNlfHxlLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UsZS5mcm9tJiZ0aGlzLmZyb20uY29weShlLmZyb20pLGUudG8mJnRoaXMudG8uY29weShlLnRvKSx0aGlzLmNhbGxiYWNrPWUuY2FsbGJhY2t8fCgoKT0+e30pLHRoaXMuaGFzSGl0PSExLHRoaXMucmVzdWx0LnJlc2V0KCksdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCksdGhpcy5nZXRBQUJCKFgpLFkubGVuZ3RoPTAsdC5icm9hZHBoYXNlLmFhYmJRdWVyeSh0LFgsWSksdGhpcy5pbnRlcnNlY3RCb2RpZXMoWSksdGhpcy5oYXNIaXR9aW50ZXJzZWN0Qm9keSh0LGUpe2UmJih0aGlzLnJlc3VsdD1lLHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpKTtjb25zdCBzPXRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtpZihzJiYhdC5jb2xsaXNpb25SZXNwb25zZSlyZXR1cm47aWYoMD09KHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAmdC5jb2xsaXNpb25GaWx0ZXJNYXNrKXx8MD09KHQuY29sbGlzaW9uRmlsdGVyR3JvdXAmdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrKSlyZXR1cm47Y29uc3QgaT1KLG89JDtmb3IobGV0IGU9MCxuPXQuc2hhcGVzLmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXQuc2hhcGVzW2VdO2lmKCghc3x8bi5jb2xsaXNpb25SZXNwb25zZSkmJih0LnF1YXRlcm5pb24ubXVsdCh0LnNoYXBlT3JpZW50YXRpb25zW2VdLG8pLHQucXVhdGVybmlvbi52bXVsdCh0LnNoYXBlT2Zmc2V0c1tlXSxpKSxpLnZhZGQodC5wb3NpdGlvbixpKSx0aGlzLmludGVyc2VjdFNoYXBlKG4sbyxpLHQpLHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKSlicmVha319aW50ZXJzZWN0Qm9kaWVzKHQsZSl7ZSYmKHRoaXMucmVzdWx0PWUsdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCkpO2ZvcihsZXQgZT0wLHM9dC5sZW5ndGg7IXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wJiZlPHM7ZSsrKXRoaXMuaW50ZXJzZWN0Qm9keSh0W2VdKX1fdXBkYXRlRGlyZWN0aW9uKCl7dGhpcy50by52c3ViKHRoaXMuZnJvbSx0aGlzLl9kaXJlY3Rpb24pLHRoaXMuX2RpcmVjdGlvbi5ub3JtYWxpemUoKX1pbnRlcnNlY3RTaGFwZSh0LGUscyxpKXtpZihmdW5jdGlvbih0LGUscyl7cy52c3ViKHQsZ3QpO2NvbnN0IGk9Z3QuZG90KGUpO3JldHVybiBlLm11bHQoaSxidCksYnQudmFkZCh0LGJ0KSxzLmRpc3RhbmNlVG8oYnQpfSh0aGlzLmZyb20sdGhpcy5fZGlyZWN0aW9uLHMpPnQuYm91bmRpbmdTcGhlcmVSYWRpdXMpcmV0dXJuO2NvbnN0IG89dGhpc1t0LnR5cGVdO28mJm8uY2FsbCh0aGlzLHQsZSxzLGksdCl9aW50ZXJzZWN0Qm94KHtjb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb246dH0sZSxzLGksbyl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0Q29udmV4KHQsZSxzLGksbyl9aW50ZXJzZWN0UGxhbmUodCxlLHMsbyxuKXtjb25zdCByPXRoaXMuZnJvbSxhPXRoaXMudG8sbD10aGlzLl9kaXJlY3Rpb24saD1uZXcgaSgwLDAsMSk7ZS52bXVsdChoLGgpO2NvbnN0IGM9bmV3IGk7ci52c3ViKHMsYyk7Y29uc3QgdT1jLmRvdChoKTtpZihhLnZzdWIocyxjKSx1KmMuZG90KGgpPjApcmV0dXJuO2lmKHIuZGlzdGFuY2VUbyhhKTx1KXJldHVybjtjb25zdCBkPWguZG90KGwpO2lmKE1hdGguYWJzKGQpPHRoaXMucHJlY2lzaW9uKXJldHVybjtjb25zdCBwPW5ldyBpLHk9bmV3IGksbT1uZXcgaTtyLnZzdWIocyxwKTtjb25zdCB2PS1oLmRvdChwKS9kO2wuc2NhbGUodix5KSxyLnZhZGQoeSxtKSx0aGlzLnJlcG9ydEludGVyc2VjdGlvbihoLG0sbixvLC0xKX1nZXRBQUJCKHtsb3dlckJvdW5kOnQsdXBwZXJCb3VuZDplfSl7Y29uc3Qgcz10aGlzLnRvLGk9dGhpcy5mcm9tO3QueD1NYXRoLm1pbihzLngsaS54KSx0Lnk9TWF0aC5taW4ocy55LGkueSksdC56PU1hdGgubWluKHMueixpLnopLGUueD1NYXRoLm1heChzLngsaS54KSxlLnk9TWF0aC5tYXgocy55LGkueSksZS56PU1hdGgubWF4KHMueixpLnopfWludGVyc2VjdEhlaWdodGZpZWxkKHQsZSxzLGksbyl7dC5kYXRhLHQuZWxlbWVudFNpemU7Y29uc3Qgcj1ydDtyLmZyb20uY29weSh0aGlzLmZyb20pLHIudG8uY29weSh0aGlzLnRvKSxtLnBvaW50VG9Mb2NhbEZyYW1lKHMsZSxyLmZyb20sci5mcm9tKSxtLnBvaW50VG9Mb2NhbEZyYW1lKHMsZSxyLnRvLHIudG8pLHIuX3VwZGF0ZURpcmVjdGlvbigpO2NvbnN0IGE9YXQ7bGV0IGwsaCxjLHU7bD1oPTAsYz11PXQuZGF0YS5sZW5ndGgtMTtjb25zdCBkPW5ldyBuO3IuZ2V0QUFCQihkKSx0LmdldEluZGV4T2ZQb3NpdGlvbihkLmxvd2VyQm91bmQueCxkLmxvd2VyQm91bmQueSxhLCEwKSxsPU1hdGgubWF4KGwsYVswXSksaD1NYXRoLm1heChoLGFbMV0pLHQuZ2V0SW5kZXhPZlBvc2l0aW9uKGQudXBwZXJCb3VuZC54LGQudXBwZXJCb3VuZC55LGEsITApLGM9TWF0aC5taW4oYyxhWzBdKzEpLHU9TWF0aC5taW4odSxhWzFdKzEpO2ZvcihsZXQgbj1sO248YztuKyspZm9yKGxldCBhPWg7YTx1O2ErKyl7aWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3ApcmV0dXJuO2lmKHQuZ2V0QWFiYkF0SW5kZXgobixhLGQpLGQub3ZlcmxhcHNSYXkocikpe2lmKHQuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIobixhLCExKSxtLnBvaW50VG9Xb3JsZEZyYW1lKHMsZSx0LnBpbGxhck9mZnNldCxudCksdGhpcy5pbnRlcnNlY3RDb252ZXgodC5waWxsYXJDb252ZXgsZSxudCxpLG8sb3QpLHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXJldHVybjt0LmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKG4sYSwhMCksbS5wb2ludFRvV29ybGRGcmFtZShzLGUsdC5waWxsYXJPZmZzZXQsbnQpLHRoaXMuaW50ZXJzZWN0Q29udmV4KHQucGlsbGFyQ29udmV4LGUsbnQsaSxvLG90KX19fWludGVyc2VjdFNwaGVyZSh7cmFkaXVzOnR9LGUscyxpLG8pe2NvbnN0IG49dGhpcy5mcm9tLHI9dGhpcy50byxhPXQsbD0oci54LW4ueCkqKjIrKHIueS1uLnkpKioyKyhyLnotbi56KSoqMixoPTIqKChyLngtbi54KSoobi54LXMueCkrKHIueS1uLnkpKihuLnktcy55KSsoci56LW4ueikqKG4uei1zLnopKSxjPWgqKjItNCpsKigobi54LXMueCkqKjIrKG4ueS1zLnkpKioyKyhuLnotcy56KSoqMi1hKioyKSx1PWx0LGQ9aHQ7aWYoIShjPDApKWlmKDA9PT1jKW4ubGVycChyLGMsdSksdS52c3ViKHMsZCksZC5ub3JtYWxpemUoKSx0aGlzLnJlcG9ydEludGVyc2VjdGlvbihkLHUsbyxpLC0xKTtlbHNle2NvbnN0IHQ9KC1oLU1hdGguc3FydChjKSkvKDIqbCksZT0oLWgrTWF0aC5zcXJ0KGMpKS8oMipsKTtpZih0Pj0wJiZ0PD0xJiYobi5sZXJwKHIsdCx1KSx1LnZzdWIocyxkKSxkLm5vcm1hbGl6ZSgpLHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKGQsdSxvLGksLTEpKSx0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcClyZXR1cm47ZT49MCYmZTw9MSYmKG4ubGVycChyLGUsdSksdS52c3ViKHMsZCksZC5ub3JtYWxpemUoKSx0aGlzLnJlcG9ydEludGVyc2VjdGlvbihkLHUsbyxpLC0xKSl9fWludGVyc2VjdENvbnZleCh0LGUscyxpLG8sbil7Y29uc3Qgcj1jdCxhPXV0LGw9biYmbi5mYWNlTGlzdHx8bnVsbCxoPXQuZmFjZXMsYz10LnZlcnRpY2VzLHU9dC5mYWNlTm9ybWFscyxkPXRoaXMuX2RpcmVjdGlvbixwPXRoaXMuZnJvbSx5PXRoaXMudG8sbT1wLmRpc3RhbmNlVG8oeSksdj1sP2wubGVuZ3RoOmgubGVuZ3RoLGY9dGhpcy5yZXN1bHQ7Zm9yKGxldCB0PTA7IWYuX3Nob3VsZFN0b3AmJnQ8djt0Kyspe2NvbnN0IG49bD9sW3RdOnQseT1oW25dLHY9dVtuXSx3PWUseD1zO2EuY29weShjW3lbMF1dKSx3LnZtdWx0KGEsYSksYS52YWRkKHgsYSksYS52c3ViKHAsYSksdy52bXVsdCh2LHIpO2NvbnN0IGc9ZC5kb3Qocik7aWYoTWF0aC5hYnMoZyk8dGhpcy5wcmVjaXNpb24pY29udGludWU7Y29uc3QgYj1yLmRvdChhKS9nO2lmKCEoYjwwKSl7ZC5tdWx0KGIsdHQpLHR0LnZhZGQocCx0dCksZXQuY29weShjW3lbMF1dKSx3LnZtdWx0KGV0LGV0KSx4LnZhZGQoZXQsZXQpO2ZvcihsZXQgdD0xOyFmLl9zaG91bGRTdG9wJiZ0PHkubGVuZ3RoLTE7dCsrKXtzdC5jb3B5KGNbeVt0XV0pLGl0LmNvcHkoY1t5W3QrMV1dKSx3LnZtdWx0KHN0LHN0KSx3LnZtdWx0KGl0LGl0KSx4LnZhZGQoc3Qsc3QpLHgudmFkZChpdCxpdCk7Y29uc3QgZT10dC5kaXN0YW5jZVRvKHApOyFRKHR0LGV0LHN0LGl0KSYmIVEodHQsc3QsZXQsaXQpfHxlPm18fHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHIsdHQsbyxpLG4pfX19fWludGVyc2VjdFRyaW1lc2godCxlLHMsaSxvLG4pe2NvbnN0IHI9ZHQsYT13dCxsPXh0LGg9dXQsYz1wdCx1PXl0LGQ9bXQscD1mdCx5PXZ0LHY9KG4mJm4uZmFjZUxpc3QsdC5pbmRpY2VzKSxmPSh0LnZlcnRpY2VzLHQuZmFjZU5vcm1hbHMsdGhpcy5mcm9tKSx3PXRoaXMudG8seD10aGlzLl9kaXJlY3Rpb247bC5wb3NpdGlvbi5jb3B5KHMpLGwucXVhdGVybmlvbi5jb3B5KGUpLG0udmVjdG9yVG9Mb2NhbEZyYW1lKHMsZSx4LGMpLG0ucG9pbnRUb0xvY2FsRnJhbWUocyxlLGYsdSksbS5wb2ludFRvTG9jYWxGcmFtZShzLGUsdyxkKSxkLngqPXQuc2NhbGUueCxkLnkqPXQuc2NhbGUueSxkLnoqPXQuc2NhbGUueix1LngqPXQuc2NhbGUueCx1LnkqPXQuc2NhbGUueSx1LnoqPXQuc2NhbGUueixkLnZzdWIodSxjKSxjLm5vcm1hbGl6ZSgpO2NvbnN0IGc9dS5kaXN0YW5jZVNxdWFyZWQoZCk7dC50cmVlLnJheVF1ZXJ5KHRoaXMsbCxhKTtmb3IobGV0IG49MCxsPWEubGVuZ3RoOyF0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCYmbiE9PWw7bisrKXtjb25zdCBsPWFbbl07dC5nZXROb3JtYWwobCxyKSx0LmdldFZlcnRleCh2WzMqbF0sZXQpLGV0LnZzdWIodSxoKTtjb25zdCBkPWMuZG90KHIpLGY9ci5kb3QoaCkvZDtpZihmPDApY29udGludWU7Yy5zY2FsZShmLHR0KSx0dC52YWRkKHUsdHQpLHQuZ2V0VmVydGV4KHZbMypsKzFdLHN0KSx0LmdldFZlcnRleCh2WzMqbCsyXSxpdCk7Y29uc3Qgdz10dC5kaXN0YW5jZVNxdWFyZWQodSk7IVEodHQsc3QsZXQsaXQpJiYhUSh0dCxldCxzdCxpdCl8fHc+Z3x8KG0udmVjdG9yVG9Xb3JsZEZyYW1lKGUscix5KSxtLnBvaW50VG9Xb3JsZEZyYW1lKHMsZSx0dCxwKSx0aGlzLnJlcG9ydEludGVyc2VjdGlvbih5LHAsbyxpLGwpKX1hLmxlbmd0aD0wfXJlcG9ydEludGVyc2VjdGlvbih0LGUscyxpLG8pe2NvbnN0IG49dGhpcy5mcm9tLHI9dGhpcy50byxhPW4uZGlzdGFuY2VUbyhlKSxsPXRoaXMucmVzdWx0O2lmKCEodGhpcy5za2lwQmFja2ZhY2VzJiZ0LmRvdCh0aGlzLl9kaXJlY3Rpb24pPjApKXN3aXRjaChsLmhpdEZhY2VJbmRleD12b2lkIDAhPT1vP286LTEsdGhpcy5tb2RlKXtjYXNlIEcuQUxMOnRoaXMuaGFzSGl0PSEwLGwuc2V0KG4scix0LGUscyxpLGEpLGwuaGFzSGl0PSEwLHRoaXMuY2FsbGJhY2sobCk7YnJlYWs7Y2FzZSBHLkNMT1NFU1Q6KGE8bC5kaXN0YW5jZXx8IWwuaGFzSGl0KSYmKHRoaXMuaGFzSGl0PSEwLGwuaGFzSGl0PSEwLGwuc2V0KG4scix0LGUscyxpLGEpKTticmVhaztjYXNlIEcuQU5ZOnRoaXMuaGFzSGl0PSEwLGwuaGFzSGl0PSEwLGwuc2V0KG4scix0LGUscyxpLGEpLGwuX3Nob3VsZFN0b3A9ITB9fX1HLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1HLEcuQ0xPU0VTVD0xLEcuQU5ZPTIsRy5BTEw9NDtjb25zdCBYPW5ldyBuLFk9W10sWj1uZXcgaSxLPW5ldyBpO2Z1bmN0aW9uIFEodCxlLHMsaSl7aS52c3ViKGUsZ3QpLHMudnN1YihlLFopLHQudnN1YihlLEspO2NvbnN0IG89Z3QuZG90KGd0KSxuPWd0LmRvdChaKSxyPWd0LmRvdChLKSxhPVouZG90KFopLGw9Wi5kb3QoSyk7bGV0IGgsYztyZXR1cm4oaD1hKnItbipsKT49MCYmKGM9bypsLW4qcik+PTAmJmgrYzxvKmEtbipufUcucG9pbnRJblRyaWFuZ2xlPVE7Y29uc3QgSj1uZXcgaSwkPW5ldyB1LHR0PW5ldyBpLGV0PW5ldyBpLHN0PW5ldyBpLGl0PW5ldyBpO0cucHJvdG90eXBlW2MudHlwZXMuQk9YXT1HLnByb3RvdHlwZS5pbnRlcnNlY3RCb3gsRy5wcm90b3R5cGVbYy50eXBlcy5QTEFORV09Ry5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmU7Y29uc3Qgb3Q9e2ZhY2VMaXN0OlswXX0sbnQ9bmV3IGkscnQ9bmV3IEcsYXQ9W107Ry5wcm90b3R5cGVbYy50eXBlcy5IRUlHSFRGSUVMRF09Ry5wcm90b3R5cGUuaW50ZXJzZWN0SGVpZ2h0ZmllbGQ7Y29uc3QgbHQ9bmV3IGksaHQ9bmV3IGk7Ry5wcm90b3R5cGVbYy50eXBlcy5TUEhFUkVdPUcucHJvdG90eXBlLmludGVyc2VjdFNwaGVyZTtjb25zdCBjdD1uZXcgaSx1dD1uZXcgaTtHLnByb3RvdHlwZVtjLnR5cGVzLkNPTlZFWFBPTFlIRURST05dPUcucHJvdG90eXBlLmludGVyc2VjdENvbnZleDtjb25zdCBkdD1uZXcgaSxwdD1uZXcgaSx5dD1uZXcgaSxtdD1uZXcgaSx2dD1uZXcgaSxmdD1uZXcgaSx3dD0obmV3IG4sW10pLHh0PW5ldyBtO0cucHJvdG90eXBlW2MudHlwZXMuVFJJTUVTSF09Ry5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaDt2YXIgZ3Q9bmV3IGk7Y29uc3QgYnQ9bmV3IGk7Y2xhc3MgQXQgZXh0ZW5kcyBre2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5heGlzTGlzdD1bXSx0aGlzLndvcmxkPW51bGwsdGhpcy5heGlzSW5kZXg9MDtjb25zdCBlPXRoaXMuYXhpc0xpc3Q7dGhpcy5fYWRkQm9keUhhbmRsZXI9KHtib2R5OnR9KT0+e2UucHVzaCh0KX0sdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXI9KHtib2R5OnR9KT0+e2NvbnN0IHM9ZS5pbmRleE9mKHQpOy0xIT09cyYmZS5zcGxpY2UocywxKX0sdCYmdGhpcy5zZXRXb3JsZCh0KX1zZXRXb3JsZCh0KXt0aGlzLmF4aXNMaXN0Lmxlbmd0aD0wO2ZvcihsZXQgZT0wO2U8dC5ib2RpZXMubGVuZ3RoO2UrKyl0aGlzLmF4aXNMaXN0LnB1c2godC5ib2RpZXNbZV0pO3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigiYWRkQm9keSIsdGhpcy5fYWRkQm9keUhhbmRsZXIpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVtb3ZlQm9keSIsdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpLHQuYWRkRXZlbnRMaXN0ZW5lcigiYWRkQm9keSIsdGhpcy5fYWRkQm9keUhhbmRsZXIpLHQuYWRkRXZlbnRMaXN0ZW5lcigicmVtb3ZlQm9keSIsdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpLHRoaXMud29ybGQ9dCx0aGlzLmRpcnR5PSEwfWNvbGxpc2lvblBhaXJzKHQsZSxzKXtjb25zdCBpPXRoaXMuYXhpc0xpc3Qsbz1pLmxlbmd0aCxuPXRoaXMuYXhpc0luZGV4O2xldCByLGE7Zm9yKHRoaXMuZGlydHkmJih0aGlzLnNvcnRMaXN0KCksdGhpcy5kaXJ0eT0hMSkscj0wO3IhPT1vO3IrKyl7Y29uc3QgdD1pW3JdO2ZvcihhPXIrMTthPG87YSsrKXtjb25zdCBvPWlbYV07aWYodGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbih0LG8pKXtpZighQXQuY2hlY2tCb3VuZHModCxvLG4pKWJyZWFrO3RoaXMuaW50ZXJzZWN0aW9uVGVzdCh0LG8sZSxzKX19fX1zb3J0TGlzdCgpe2NvbnN0IHQ9dGhpcy5heGlzTGlzdCxlPXRoaXMuYXhpc0luZGV4LHM9dC5sZW5ndGg7Zm9yKGxldCBlPTA7ZSE9PXM7ZSsrKXtjb25zdCBzPXRbZV07cy5hYWJiTmVlZHNVcGRhdGUmJnMuY29tcHV0ZUFBQkIoKX0wPT09ZT9BdC5pbnNlcnRpb25Tb3J0WCh0KToxPT09ZT9BdC5pbnNlcnRpb25Tb3J0WSh0KToyPT09ZSYmQXQuaW5zZXJ0aW9uU29ydFoodCl9YXV0b0RldGVjdEF4aXMoKXtsZXQgdD0wLGU9MCxzPTAsaT0wLG89MCxuPTA7Y29uc3Qgcj10aGlzLmF4aXNMaXN0LGE9ci5sZW5ndGgsbD0xL2E7Zm9yKGxldCBsPTA7bCE9PWE7bCsrKXtjb25zdCBhPXJbbF0saD1hLnBvc2l0aW9uLng7dCs9aCxlKz1oKmg7Y29uc3QgYz1hLnBvc2l0aW9uLnk7cys9YyxpKz1jKmM7Y29uc3QgdT1hLnBvc2l0aW9uLno7bys9dSxuKz11KnV9Y29uc3QgaD1lLXQqdCpsLGM9aS1zKnMqbCx1PW4tbypvKmw7dGhpcy5heGlzSW5kZXg9aD5jP2g+dT8wOjI6Yz51PzE6Mn1hYWJiUXVlcnkodCxlLHM9W10pe3RoaXMuZGlydHkmJih0aGlzLnNvcnRMaXN0KCksdGhpcy5kaXJ0eT0hMSk7Y29uc3QgaT10aGlzLmF4aXNJbmRleDtsZXQgbz0ieCI7MT09PWkmJihvPSJ5IiksMj09PWkmJihvPSJ6Iik7Y29uc3Qgbj10aGlzLmF4aXNMaXN0O2UubG93ZXJCb3VuZFtvXSxlLnVwcGVyQm91bmRbb107Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IGk9blt0XTtpLmFhYmJOZWVkc1VwZGF0ZSYmaS5jb21wdXRlQUFCQigpLGkuYWFiYi5vdmVybGFwcyhlKSYmcy5wdXNoKGkpfXJldHVybiBzfX1BdC5pbnNlcnRpb25Tb3J0WD10PT57Zm9yKGxldCBzPTEsaT10Lmxlbmd0aDtzPGk7cysrKXtjb25zdCBpPXRbc107Zm9yKHZhciBlPXMtMTtlPj0wJiYhKHRbZV0uYWFiYi5sb3dlckJvdW5kLng8PWkuYWFiYi5sb3dlckJvdW5kLngpO2UtLSl0W2UrMV09dFtlXTt0W2UrMV09aX1yZXR1cm4gdH0sQXQuaW5zZXJ0aW9uU29ydFk9dD0+e2ZvcihsZXQgcz0xLGk9dC5sZW5ndGg7czxpO3MrKyl7Y29uc3QgaT10W3NdO2Zvcih2YXIgZT1zLTE7ZT49MCYmISh0W2VdLmFhYmIubG93ZXJCb3VuZC55PD1pLmFhYmIubG93ZXJCb3VuZC55KTtlLS0pdFtlKzFdPXRbZV07dFtlKzFdPWl9cmV0dXJuIHR9LEF0Lmluc2VydGlvblNvcnRaPXQ9Pntmb3IobGV0IHM9MSxpPXQubGVuZ3RoO3M8aTtzKyspe2NvbnN0IGk9dFtzXTtmb3IodmFyIGU9cy0xO2U+PTAmJiEodFtlXS5hYWJiLmxvd2VyQm91bmQuejw9aS5hYWJiLmxvd2VyQm91bmQueik7ZS0tKXRbZSsxXT10W2VdO3RbZSsxXT1pfXJldHVybiB0fSxBdC5jaGVja0JvdW5kcz0odCxlLHMpPT57bGV0IGksbzswPT09cz8oaT10LnBvc2l0aW9uLngsbz1lLnBvc2l0aW9uLngpOjE9PT1zPyhpPXQucG9zaXRpb24ueSxvPWUucG9zaXRpb24ueSk6Mj09PXMmJihpPXQucG9zaXRpb24ueixvPWUucG9zaXRpb24ueik7Y29uc3Qgbj10LmJvdW5kaW5nUmFkaXVzO3JldHVybiBvLWUuYm91bmRpbmdSYWRpdXM8aStufTtjbGFzcyBCdHtjb25zdHJ1Y3Rvcih0LGUscyl7cz1vLmRlZmF1bHRzKHMse2NvbGxpZGVDb25uZWN0ZWQ6ITAsd2FrZVVwQm9kaWVzOiEwfSksdGhpcy5lcXVhdGlvbnM9W10sdGhpcy5ib2R5QT10LHRoaXMuYm9keUI9ZSx0aGlzLmlkPUJ0LmlkQ291bnRlcisrLHRoaXMuY29sbGlkZUNvbm5lY3RlZD1zLmNvbGxpZGVDb25uZWN0ZWQscy53YWtlVXBCb2RpZXMmJih0JiZ0Lndha2VVcCgpLGUmJmUud2FrZVVwKCkpfXVwZGF0ZSgpe3Rocm93IG5ldyBFcnJvcigibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzISIpfWVuYWJsZSgpe2NvbnN0IHQ9dGhpcy5lcXVhdGlvbnM7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXS5lbmFibGVkPSEwfWRpc2FibGUoKXtjb25zdCB0PXRoaXMuZXF1YXRpb25zO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0uZW5hYmxlZD0hMX19QnQuaWRDb3VudGVyPTA7Y2xhc3MgRXR7Y29uc3RydWN0b3IoKXt0aGlzLnNwYXRpYWw9bmV3IGksdGhpcy5yb3RhdGlvbmFsPW5ldyBpfW11bHRpcGx5RWxlbWVudCh7c3BhdGlhbDp0LHJvdGF0aW9uYWw6ZX0pe3JldHVybiB0LmRvdCh0aGlzLnNwYXRpYWwpK2UuZG90KHRoaXMucm90YXRpb25hbCl9bXVsdGlwbHlWZWN0b3JzKHQsZSl7cmV0dXJuIHQuZG90KHRoaXMuc3BhdGlhbCkrZS5kb3QodGhpcy5yb3RhdGlvbmFsKX19Y2xhc3MgenR7Y29uc3RydWN0b3IodCxlLHMsaSl7dGhpcy5pZD16dC5pZCsrLHRoaXMubWluRm9yY2U9dm9pZCAwPT09cz8tMWU2OnMsdGhpcy5tYXhGb3JjZT12b2lkIDA9PT1pPzFlNjppLHRoaXMuYmk9dCx0aGlzLmJqPWUsdGhpcy5hPTAsdGhpcy5iPTAsdGhpcy5lcHM9MCx0aGlzLmphY29iaWFuRWxlbWVudEE9bmV3IEV0LHRoaXMuamFjb2JpYW5FbGVtZW50Qj1uZXcgRXQsdGhpcy5lbmFibGVkPSEwLHRoaXMubXVsdGlwbGllcj0wLHRoaXMuc2V0U3Bvb2tQYXJhbXMoMWU3LDQsMS82MCl9c2V0U3Bvb2tQYXJhbXModCxlLHMpe2NvbnN0IGk9ZSxvPXQsbj1zO3RoaXMuYT00LyhuKigxKzQqaSkpLHRoaXMuYj00KmkvKDErNCppKSx0aGlzLmVwcz00LyhuKm4qbyooMSs0KmkpKX1jb21wdXRlQih0LGUscyl7Y29uc3QgaT10aGlzLmNvbXB1dGVHVygpO3JldHVybi10aGlzLmNvbXB1dGVHcSgpKnQtaSplLXRoaXMuY29tcHV0ZUdpTWYoKSpzfWNvbXB1dGVHcSgpe2NvbnN0IHQ9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLHM9dGhpcy5iaSxpPXRoaXMuYmosbz1zLnBvc2l0aW9uLG49aS5wb3NpdGlvbjtyZXR1cm4gdC5zcGF0aWFsLmRvdChvKStlLnNwYXRpYWwuZG90KG4pfWNvbXB1dGVHVygpe2NvbnN0IHQ9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLHM9dGhpcy5iaSxpPXRoaXMuYmosbz1zLnZlbG9jaXR5LG49aS52ZWxvY2l0eSxyPXMuYW5ndWxhclZlbG9jaXR5LGE9aS5hbmd1bGFyVmVsb2NpdHk7cmV0dXJuIHQubXVsdGlwbHlWZWN0b3JzKG8scikrZS5tdWx0aXBseVZlY3RvcnMobixhKX1jb21wdXRlR1dsYW1iZGEoKXtjb25zdCB0PXRoaXMuamFjb2JpYW5FbGVtZW50QSxlPXRoaXMuamFjb2JpYW5FbGVtZW50QixzPXRoaXMuYmksaT10aGlzLmJqLG89cy52bGFtYmRhLG49aS52bGFtYmRhLHI9cy53bGFtYmRhLGE9aS53bGFtYmRhO3JldHVybiB0Lm11bHRpcGx5VmVjdG9ycyhvLHIpK2UubXVsdGlwbHlWZWN0b3JzKG4sYSl9Y29tcHV0ZUdpTWYoKXtjb25zdCB0PXRoaXMuamFjb2JpYW5FbGVtZW50QSxlPXRoaXMuamFjb2JpYW5FbGVtZW50QixzPXRoaXMuYmksaT10aGlzLmJqLG89cy5mb3JjZSxuPXMudG9ycXVlLHI9aS5mb3JjZSxhPWkudG9ycXVlLGw9cy5pbnZNYXNzU29sdmUsaD1pLmludk1hc3NTb2x2ZTtyZXR1cm4gby5zY2FsZShsLFN0KSxyLnNjYWxlKGgsRnQpLHMuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQobixNdCksaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChhLEN0KSx0Lm11bHRpcGx5VmVjdG9ycyhTdCxNdCkrZS5tdWx0aXBseVZlY3RvcnMoRnQsQ3QpfWNvbXB1dGVHaU1HdCgpe2NvbnN0IHQ9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLHM9dGhpcy5iaSxpPXRoaXMuYmosbz1zLmludk1hc3NTb2x2ZSxuPWkuaW52TWFzc1NvbHZlLHI9cy5pbnZJbmVydGlhV29ybGRTb2x2ZSxhPWkuaW52SW5lcnRpYVdvcmxkU29sdmU7bGV0IGw9bytuO3JldHVybiByLnZtdWx0KHQucm90YXRpb25hbCxxdCksbCs9cXQuZG90KHQucm90YXRpb25hbCksYS52bXVsdChlLnJvdGF0aW9uYWwscXQpLGwrPXF0LmRvdChlLnJvdGF0aW9uYWwpLGx9YWRkVG9XbGFtYmRhKHQpe2NvbnN0IGU9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLHM9dGhpcy5qYWNvYmlhbkVsZW1lbnRCLGk9dGhpcy5iaSxvPXRoaXMuYmosbj1UdDtpLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGkuaW52TWFzc1NvbHZlKnQsZS5zcGF0aWFsLGkudmxhbWJkYSksby52bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihvLmludk1hc3NTb2x2ZSp0LHMuc3BhdGlhbCxvLnZsYW1iZGEpLGkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoZS5yb3RhdGlvbmFsLG4pLGkud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IodCxuLGkud2xhbWJkYSksby5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChzLnJvdGF0aW9uYWwsbiksby53bGFtYmRhLmFkZFNjYWxlZFZlY3Rvcih0LG4sby53bGFtYmRhKX1jb21wdXRlQygpe3JldHVybiB0aGlzLmNvbXB1dGVHaU1HdCgpK3RoaXMuZXBzfX16dC5pZD0wO2NvbnN0IFN0PW5ldyBpLEZ0PW5ldyBpLE10PW5ldyBpLEN0PW5ldyBpLHF0PW5ldyBpLFR0PW5ldyBpO2NsYXNzIE50IGV4dGVuZHMgenR7Y29uc3RydWN0b3IodCxlLHM9MWU2KXtzdXBlcih0LGUsMCxzKSx0aGlzLnJlc3RpdHV0aW9uPTAsdGhpcy5yaT1uZXcgaSx0aGlzLnJqPW5ldyBpLHRoaXMubmk9bmV3IGl9Y29tcHV0ZUIodCl7Y29uc3QgZT10aGlzLmEscz10aGlzLmIsaT10aGlzLmJpLG89dGhpcy5iaixuPXRoaXMucmkscj10aGlzLnJqLGE9UHQsbD1SdCxoPWkudmVsb2NpdHksYz1pLmFuZ3VsYXJWZWxvY2l0eSx1PShpLmZvcmNlLGkudG9ycXVlLG8udmVsb2NpdHkpLGQ9by5hbmd1bGFyVmVsb2NpdHkscD0oby5mb3JjZSxvLnRvcnF1ZSxJdCkseT10aGlzLmphY29iaWFuRWxlbWVudEEsbT10aGlzLmphY29iaWFuRWxlbWVudEIsdj10aGlzLm5pO24uY3Jvc3ModixhKSxyLmNyb3NzKHYsbCksdi5uZWdhdGUoeS5zcGF0aWFsKSxhLm5lZ2F0ZSh5LnJvdGF0aW9uYWwpLG0uc3BhdGlhbC5jb3B5KHYpLG0ucm90YXRpb25hbC5jb3B5KGwpLHAuY29weShvLnBvc2l0aW9uKSxwLnZhZGQocixwKSxwLnZzdWIoaS5wb3NpdGlvbixwKSxwLnZzdWIobixwKTtjb25zdCBmPXYuZG90KHApLHc9dGhpcy5yZXN0aXR1dGlvbisxO3JldHVybi1mKmUtKHcqdS5kb3QodiktdypoLmRvdCh2KStkLmRvdChsKS1jLmRvdChhKSkqcy10KnRoaXMuY29tcHV0ZUdpTWYoKX1nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsKCl7Y29uc3QgdD1MdCxlPWp0LHM9VnQsaT1rdCxvPVd0O3JldHVybiB0aGlzLmJpLnBvc2l0aW9uLnZhZGQodGhpcy5yaSxzKSx0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaixpKSx0aGlzLmJpLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHMsdCksdGhpcy5iai5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChpLGUpLHQudnN1YihlLG8pLHRoaXMubmkuZG90KG8pfX1jb25zdCBQdD1uZXcgaSxSdD1uZXcgaSxJdD1uZXcgaSxMdD1uZXcgaSxqdD1uZXcgaSxWdD1uZXcgaSxrdD1uZXcgaSxXdD1uZXcgaTtjbGFzcyBPdCBleHRlbmRzIEJ0e2NvbnN0cnVjdG9yKHQsZSxzLG8sbil7c3VwZXIodCxzKSxuPXZvaWQgMCE9PW4/bjoxZTYsdGhpcy5waXZvdEE9ZT9lLmNsb25lKCk6bmV3IGksdGhpcy5waXZvdEI9bz9vLmNsb25lKCk6bmV3IGk7Y29uc3Qgcj10aGlzLmVxdWF0aW9uWD1uZXcgTnQodCxzKSxhPXRoaXMuZXF1YXRpb25ZPW5ldyBOdCh0LHMpLGw9dGhpcy5lcXVhdGlvblo9bmV3IE50KHQscyk7dGhpcy5lcXVhdGlvbnMucHVzaChyLGEsbCksci5taW5Gb3JjZT1hLm1pbkZvcmNlPWwubWluRm9yY2U9LW4sci5tYXhGb3JjZT1hLm1heEZvcmNlPWwubWF4Rm9yY2U9bixyLm5pLnNldCgxLDAsMCksYS5uaS5zZXQoMCwxLDApLGwubmkuc2V0KDAsMCwxKX11cGRhdGUoKXtjb25zdCB0PXRoaXMuYm9keUEsZT10aGlzLmJvZHlCLHM9dGhpcy5lcXVhdGlvblgsaT10aGlzLmVxdWF0aW9uWSxvPXRoaXMuZXF1YXRpb25aO3QucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QSxzLnJpKSxlLnF1YXRlcm5pb24udm11bHQodGhpcy5waXZvdEIscy5yaiksaS5yaS5jb3B5KHMucmkpLGkucmouY29weShzLnJqKSxvLnJpLmNvcHkocy5yaSksby5yai5jb3B5KHMucmopfX1jbGFzcyBfdCBleHRlbmRzIHp0e2NvbnN0cnVjdG9yKHQsZSxzPXt9KXtjb25zdCBvPXZvaWQgMCE9PXMubWF4Rm9yY2U/cy5tYXhGb3JjZToxZTY7c3VwZXIodCxlLC1vLG8pLHRoaXMuYXhpc0E9cy5heGlzQT9zLmF4aXNBLmNsb25lKCk6bmV3IGkoMSwwLDApLHRoaXMuYXhpc0I9cy5heGlzQj9zLmF4aXNCLmNsb25lKCk6bmV3IGkoMCwxLDApLHRoaXMuYW5nbGU9dm9pZCAwIT09cy5hbmdsZT9zLmFuZ2xlOjB9Y29tcHV0ZUIodCl7Y29uc3QgZT10aGlzLmEscz10aGlzLmIsaT10aGlzLmF4aXNBLG89dGhpcy5heGlzQixuPUh0LHI9VXQsYT10aGlzLmphY29iaWFuRWxlbWVudEEsbD10aGlzLmphY29iaWFuRWxlbWVudEI7cmV0dXJuIGkuY3Jvc3MobyxuKSxvLmNyb3NzKGksciksYS5yb3RhdGlvbmFsLmNvcHkociksbC5yb3RhdGlvbmFsLmNvcHkobiksLShNYXRoLmNvcyh0aGlzLmFuZ2xlKS1pLmRvdChvKSkqZS10aGlzLmNvbXB1dGVHVygpKnMtdCp0aGlzLmNvbXB1dGVHaU1mKCl9fWNvbnN0IEh0PW5ldyBpLFV0PW5ldyBpO2NsYXNzIER0IGV4dGVuZHMgenR7Y29uc3RydWN0b3IodCxlLHM9e30pe2NvbnN0IG89dm9pZCAwIT09cy5tYXhGb3JjZT9zLm1heEZvcmNlOjFlNjtzdXBlcih0LGUsLW8sbyksdGhpcy5heGlzQT1zLmF4aXNBP3MuYXhpc0EuY2xvbmUoKTpuZXcgaSgxLDAsMCksdGhpcy5heGlzQj1zLmF4aXNCP3MuYXhpc0IuY2xvbmUoKTpuZXcgaSgwLDEsMCksdGhpcy5tYXhBbmdsZT1NYXRoLlBJLzJ9Y29tcHV0ZUIodCl7Y29uc3QgZT10aGlzLmEscz10aGlzLmIsaT10aGlzLmF4aXNBLG89dGhpcy5heGlzQixuPUd0LHI9WHQsYT10aGlzLmphY29iaWFuRWxlbWVudEEsbD10aGlzLmphY29iaWFuRWxlbWVudEI7cmV0dXJuIGkuY3Jvc3MobyxuKSxvLmNyb3NzKGksciksYS5yb3RhdGlvbmFsLmNvcHkociksbC5yb3RhdGlvbmFsLmNvcHkobiksLShNYXRoLmNvcyh0aGlzLm1heEFuZ2xlKS1pLmRvdChvKSkqZS10aGlzLmNvbXB1dGVHVygpKnMtdCp0aGlzLmNvbXB1dGVHaU1mKCl9fWNvbnN0IEd0PW5ldyBpLFh0PW5ldyBpO2NsYXNzIFl0IGV4dGVuZHMgT3R7Y29uc3RydWN0b3IodCxlLHM9e30pe2NvbnN0IG89dm9pZCAwIT09cy5tYXhGb3JjZT9zLm1heEZvcmNlOjFlNjtzdXBlcih0LHMucGl2b3RBP3MucGl2b3RBLmNsb25lKCk6bmV3IGksZSxzLnBpdm90Qj9zLnBpdm90Qi5jbG9uZSgpOm5ldyBpLG8pLHRoaXMuYXhpc0E9cy5heGlzQT9zLmF4aXNBLmNsb25lKCk6bmV3IGksdGhpcy5heGlzQj1zLmF4aXNCP3MuYXhpc0IuY2xvbmUoKTpuZXcgaSx0aGlzLmNvbGxpZGVDb25uZWN0ZWQ9ISFzLmNvbGxpZGVDb25uZWN0ZWQsdGhpcy5hbmdsZT12b2lkIDAhPT1zLmFuZ2xlP3MuYW5nbGU6MDtjb25zdCBuPXRoaXMuY29uZUVxdWF0aW9uPW5ldyBfdCh0LGUscykscj10aGlzLnR3aXN0RXF1YXRpb249bmV3IER0KHQsZSxzKTt0aGlzLnR3aXN0QW5nbGU9dm9pZCAwIT09cy50d2lzdEFuZ2xlP3MudHdpc3RBbmdsZTowLG4ubWF4Rm9yY2U9MCxuLm1pbkZvcmNlPS1vLHIubWF4Rm9yY2U9MCxyLm1pbkZvcmNlPS1vLHRoaXMuZXF1YXRpb25zLnB1c2gobixyKX11cGRhdGUoKXtjb25zdCB0PXRoaXMuYm9keUEsZT10aGlzLmJvZHlCLHM9dGhpcy5jb25lRXF1YXRpb24saT10aGlzLnR3aXN0RXF1YXRpb247c3VwZXIudXBkYXRlKCksdC52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQSxzLmF4aXNBKSxlLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNCLHMuYXhpc0IpLHRoaXMuYXhpc0EudGFuZ2VudHMoaS5heGlzQSxpLmF4aXNBKSx0LnZlY3RvclRvV29ybGRGcmFtZShpLmF4aXNBLGkuYXhpc0EpLHRoaXMuYXhpc0IudGFuZ2VudHMoaS5heGlzQixpLmF4aXNCKSxlLnZlY3RvclRvV29ybGRGcmFtZShpLmF4aXNCLGkuYXhpc0IpLHMuYW5nbGU9dGhpcy5hbmdsZSxpLm1heEFuZ2xlPXRoaXMudHdpc3RBbmdsZX19Y2xhc3MgWnQgZXh0ZW5kcyBCdHtjb25zdHJ1Y3Rvcih0LGUscyxpKXtzdXBlcih0LGUpLHZvaWQgMD09PXMmJihzPXQucG9zaXRpb24uZGlzdGFuY2VUbyhlLnBvc2l0aW9uKSksdm9pZCAwPT09aSYmKGk9MWU2KSx0aGlzLmRpc3RhbmNlPXM7Y29uc3Qgbz10aGlzLmRpc3RhbmNlRXF1YXRpb249bmV3IE50KHQsZSk7dGhpcy5lcXVhdGlvbnMucHVzaChvKSxvLm1pbkZvcmNlPS1pLG8ubWF4Rm9yY2U9aX11cGRhdGUoKXtjb25zdCB0PXRoaXMuYm9keUEsZT10aGlzLmJvZHlCLHM9dGhpcy5kaXN0YW5jZUVxdWF0aW9uLGk9LjUqdGhpcy5kaXN0YW5jZSxvPXMubmk7ZS5wb3NpdGlvbi52c3ViKHQucG9zaXRpb24sbyksby5ub3JtYWxpemUoKSxvLm11bHQoaSxzLnJpKSxvLm11bHQoLWkscy5yail9fWNsYXNzIEt0IGV4dGVuZHMgT3R7Y29uc3RydWN0b3IodCxlLHM9e30pe2NvbnN0IG89dm9pZCAwIT09cy5tYXhGb3JjZT9zLm1heEZvcmNlOjFlNixuPW5ldyBpLHI9bmV3IGksYT1uZXcgaTt0LnBvc2l0aW9uLnZhZGQoZS5wb3NpdGlvbixhKSxhLnNjYWxlKC41LGEpLGUucG9pbnRUb0xvY2FsRnJhbWUoYSxyKSx0LnBvaW50VG9Mb2NhbEZyYW1lKGEsbiksc3VwZXIodCxuLGUscixvKSx0aGlzLnhBPXQudmVjdG9yVG9Mb2NhbEZyYW1lKGkuVU5JVF9YKSx0aGlzLnhCPWUudmVjdG9yVG9Mb2NhbEZyYW1lKGkuVU5JVF9YKSx0aGlzLnlBPXQudmVjdG9yVG9Mb2NhbEZyYW1lKGkuVU5JVF9ZKSx0aGlzLnlCPWUudmVjdG9yVG9Mb2NhbEZyYW1lKGkuVU5JVF9ZKSx0aGlzLnpBPXQudmVjdG9yVG9Mb2NhbEZyYW1lKGkuVU5JVF9aKSx0aGlzLnpCPWUudmVjdG9yVG9Mb2NhbEZyYW1lKGkuVU5JVF9aKTtjb25zdCBsPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMT1uZXcgRHQodCxlLHMpLGg9dGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yPW5ldyBEdCh0LGUscyksYz10aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjM9bmV3IER0KHQsZSxzKTt0aGlzLmVxdWF0aW9ucy5wdXNoKGwsaCxjKX11cGRhdGUoKXtjb25zdCB0PXRoaXMuYm9keUEsZT10aGlzLmJvZHlCLHM9KHRoaXMubW90b3JFcXVhdGlvbix0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEpLGk9dGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLG89dGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zO3N1cGVyLnVwZGF0ZSgpLHQudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMueEEscy5heGlzQSksZS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QixzLmF4aXNCKSx0LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnlBLGkuYXhpc0EpLGUudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuekIsaS5heGlzQiksdC52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QSxvLmF4aXNBKSxlLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhCLG8uYXhpc0IpfX1jbGFzcyBRdCBleHRlbmRzIHp0e2NvbnN0cnVjdG9yKHQsZSxzPTFlNil7c3VwZXIodCxlLC1zLHMpLHRoaXMuYXhpc0E9bmV3IGksdGhpcy5heGlzQj1uZXcgaSx0aGlzLnRhcmdldFZlbG9jaXR5PTB9Y29tcHV0ZUIodCl7dGhpcy5hO2NvbnN0IGU9dGhpcy5iLHM9KHRoaXMuYmksdGhpcy5iaix0aGlzLmF4aXNBKSxpPXRoaXMuYXhpc0Isbz10aGlzLmphY29iaWFuRWxlbWVudEEsbj10aGlzLmphY29iaWFuRWxlbWVudEI7cmV0dXJuIG8ucm90YXRpb25hbC5jb3B5KHMpLGkubmVnYXRlKG4ucm90YXRpb25hbCksLSh0aGlzLmNvbXB1dGVHVygpLXRoaXMudGFyZ2V0VmVsb2NpdHkpKmUtdCp0aGlzLmNvbXB1dGVHaU1mKCl9fWNsYXNzIEp0IGV4dGVuZHMgT3R7Y29uc3RydWN0b3IodCxlLHM9e30pe2NvbnN0IG89dm9pZCAwIT09cy5tYXhGb3JjZT9zLm1heEZvcmNlOjFlNjtzdXBlcih0LHMucGl2b3RBP3MucGl2b3RBLmNsb25lKCk6bmV3IGksZSxzLnBpdm90Qj9zLnBpdm90Qi5jbG9uZSgpOm5ldyBpLG8pLCh0aGlzLmF4aXNBPXMuYXhpc0E/cy5heGlzQS5jbG9uZSgpOm5ldyBpKDEsMCwwKSkubm9ybWFsaXplKCksKHRoaXMuYXhpc0I9cy5heGlzQj9zLmF4aXNCLmNsb25lKCk6bmV3IGkoMSwwLDApKS5ub3JtYWxpemUoKTtjb25zdCBuPXRoaXMucm90YXRpb25hbEVxdWF0aW9uMT1uZXcgRHQodCxlLHMpLHI9dGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yPW5ldyBEdCh0LGUscyksYT10aGlzLm1vdG9yRXF1YXRpb249bmV3IFF0KHQsZSxvKTthLmVuYWJsZWQ9ITEsdGhpcy5lcXVhdGlvbnMucHVzaChuLHIsYSl9ZW5hYmxlTW90b3IoKXt0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZD0hMH1kaXNhYmxlTW90b3IoKXt0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZD0hMX1zZXRNb3RvclNwZWVkKHQpe3RoaXMubW90b3JFcXVhdGlvbi50YXJnZXRWZWxvY2l0eT10fXNldE1vdG9yTWF4Rm9yY2UodCl7dGhpcy5tb3RvckVxdWF0aW9uLm1heEZvcmNlPXQsdGhpcy5tb3RvckVxdWF0aW9uLm1pbkZvcmNlPS10fXVwZGF0ZSgpe2NvbnN0IHQ9dGhpcy5ib2R5QSxlPXRoaXMuYm9keUIscz10aGlzLm1vdG9yRXF1YXRpb24saT10aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsbz10aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIsbj0kdCxyPXRlLGE9dGhpcy5heGlzQSxsPXRoaXMuYXhpc0I7c3VwZXIudXBkYXRlKCksdC5xdWF0ZXJuaW9uLnZtdWx0KGEsbiksZS5xdWF0ZXJuaW9uLnZtdWx0KGwsciksbi50YW5nZW50cyhpLmF4aXNBLG8uYXhpc0EpLGkuYXhpc0IuY29weShyKSxvLmF4aXNCLmNvcHkociksdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQmJih0LnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSxzLmF4aXNBKSxlLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQixzLmF4aXNCKSl9fWNvbnN0ICR0PW5ldyBpLHRlPW5ldyBpO2NsYXNzIGVlIGV4dGVuZHMgenR7Y29uc3RydWN0b3IodCxlLHMpe3N1cGVyKHQsZSwtcyxzKSx0aGlzLnJpPW5ldyBpLHRoaXMucmo9bmV3IGksdGhpcy50PW5ldyBpfWNvbXB1dGVCKHQpe3RoaXMuYTtjb25zdCBlPXRoaXMuYixzPSh0aGlzLmJpLHRoaXMuYmosdGhpcy5yaSksaT10aGlzLnJqLG89c2Usbj1pZSxyPXRoaXMudDtzLmNyb3NzKHIsbyksaS5jcm9zcyhyLG4pO2NvbnN0IGE9dGhpcy5qYWNvYmlhbkVsZW1lbnRBLGw9dGhpcy5qYWNvYmlhbkVsZW1lbnRCO3JldHVybiByLm5lZ2F0ZShhLnNwYXRpYWwpLG8ubmVnYXRlKGEucm90YXRpb25hbCksbC5zcGF0aWFsLmNvcHkociksbC5yb3RhdGlvbmFsLmNvcHkobiksLXRoaXMuY29tcHV0ZUdXKCkqZS10KnRoaXMuY29tcHV0ZUdpTWYoKX19Y29uc3Qgc2U9bmV3IGksaWU9bmV3IGk7Y2xhc3Mgb2V7Y29uc3RydWN0b3IodCxlLHMpe3M9by5kZWZhdWx0cyhzLHtmcmljdGlvbjouMyxyZXN0aXR1dGlvbjouMyxjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6MWU3LGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246MyxmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOjFlNyxmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjozfSksdGhpcy5pZD1vZS5pZENvdW50ZXIrKyx0aGlzLm1hdGVyaWFscz1bdCxlXSx0aGlzLmZyaWN0aW9uPXMuZnJpY3Rpb24sdGhpcy5yZXN0aXR1dGlvbj1zLnJlc3RpdHV0aW9uLHRoaXMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPXMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLHRoaXMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbj1zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sdGhpcy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzPXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyx0aGlzLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uPXMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb259fW9lLmlkQ291bnRlcj0wO2NsYXNzIG5le2NvbnN0cnVjdG9yKHQsZSxzPXt9KXt0aGlzLnJlc3RMZW5ndGg9Im51bWJlciI9PXR5cGVvZiBzLnJlc3RMZW5ndGg/cy5yZXN0TGVuZ3RoOjEsdGhpcy5zdGlmZm5lc3M9cy5zdGlmZm5lc3N8fDEwMCx0aGlzLmRhbXBpbmc9cy5kYW1waW5nfHwxLHRoaXMuYm9keUE9dCx0aGlzLmJvZHlCPWUsdGhpcy5sb2NhbEFuY2hvckE9bmV3IGksdGhpcy5sb2NhbEFuY2hvckI9bmV3IGkscy5sb2NhbEFuY2hvckEmJnRoaXMubG9jYWxBbmNob3JBLmNvcHkocy5sb2NhbEFuY2hvckEpLHMubG9jYWxBbmNob3JCJiZ0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KHMubG9jYWxBbmNob3JCKSxzLndvcmxkQW5jaG9yQSYmdGhpcy5zZXRXb3JsZEFuY2hvckEocy53b3JsZEFuY2hvckEpLHMud29ybGRBbmNob3JCJiZ0aGlzLnNldFdvcmxkQW5jaG9yQihzLndvcmxkQW5jaG9yQil9c2V0V29ybGRBbmNob3JBKHQpe3RoaXMuYm9keUEucG9pbnRUb0xvY2FsRnJhbWUodCx0aGlzLmxvY2FsQW5jaG9yQSl9c2V0V29ybGRBbmNob3JCKHQpe3RoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUodCx0aGlzLmxvY2FsQW5jaG9yQil9Z2V0V29ybGRBbmNob3JBKHQpe3RoaXMuYm9keUEucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsdCl9Z2V0V29ybGRBbmNob3JCKHQpe3RoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsdCl9YXBwbHlGb3JjZSgpe2NvbnN0IHQ9dGhpcy5zdGlmZm5lc3MsZT10aGlzLmRhbXBpbmcscz10aGlzLnJlc3RMZW5ndGgsaT10aGlzLmJvZHlBLG89dGhpcy5ib2R5QixuPXJlLHI9YWUsYT1sZSxsPWhlLGg9dmUsYz1jZSx1PXVlLGQ9ZGUscD1wZSx5PXllLG09bWU7dGhpcy5nZXRXb3JsZEFuY2hvckEoYyksdGhpcy5nZXRXb3JsZEFuY2hvckIodSksYy52c3ViKGkucG9zaXRpb24sZCksdS52c3ViKG8ucG9zaXRpb24scCksdS52c3ViKGMsbik7Y29uc3Qgdj1uLm5vcm0oKTtyLmNvcHkobiksci5ub3JtYWxpemUoKSxvLnZlbG9jaXR5LnZzdWIoaS52ZWxvY2l0eSxhKSxvLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhwLGgpLGEudmFkZChoLGEpLGkuYW5ndWxhclZlbG9jaXR5LmNyb3NzKGQsaCksYS52c3ViKGgsYSksci5tdWx0KC10Kih2LXMpLWUqYS5kb3QociksbCksaS5mb3JjZS52c3ViKGwsaS5mb3JjZSksby5mb3JjZS52YWRkKGwsby5mb3JjZSksZC5jcm9zcyhsLHkpLHAuY3Jvc3MobCxtKSxpLnRvcnF1ZS52c3ViKHksaS50b3JxdWUpLG8udG9ycXVlLnZhZGQobSxvLnRvcnF1ZSl9fWNvbnN0IHJlPW5ldyBpLGFlPW5ldyBpLGxlPW5ldyBpLGhlPW5ldyBpLGNlPW5ldyBpLHVlPW5ldyBpLGRlPW5ldyBpLHBlPW5ldyBpLHllPW5ldyBpLG1lPW5ldyBpLHZlPW5ldyBpO25ldyBHO2NsYXNzIGZlIGV4dGVuZHMgY3tjb25zdHJ1Y3Rvcih0KXtpZihzdXBlcih7dHlwZTpjLnR5cGVzLlNQSEVSRX0pLHRoaXMucmFkaXVzPXZvaWQgMCE9PXQ/dDoxLHRoaXMucmFkaXVzPDApdGhyb3cgbmV3IEVycm9yKCJUaGUgc3BoZXJlIHJhZGl1cyBjYW5ub3QgYmUgbmVnYXRpdmUuIik7dGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGU9bmV3IGkpe2NvbnN0IHM9Mip0KnRoaXMucmFkaXVzKnRoaXMucmFkaXVzLzU7cmV0dXJuIGUueD1zLGUueT1zLGUuej1zLGV9dm9sdW1lKCl7cmV0dXJuIDQqTWF0aC5QSSpNYXRoLnBvdyh0aGlzLnJhZGl1cywzKS8zfXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz10aGlzLnJhZGl1c31jYWxjdWxhdGVXb3JsZEFBQkIodCxlLHMsaSl7Y29uc3Qgbz10aGlzLnJhZGl1cyxuPVsieCIsInkiLCJ6Il07Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspe2NvbnN0IHI9bltlXTtzW3JdPXRbcl0tbyxpW3JdPXRbcl0rb319fWNsYXNzIHdlIGV4dGVuZHMgZntjb25zdHJ1Y3Rvcih0LGUscyxvKXtjb25zdCBuPW8scj1bXSxhPVtdLGw9W10saD1bXSxjPVtdLHU9TWF0aC5jb3MsZD1NYXRoLnNpbjtyLnB1c2gobmV3IGkoZSp1KDApLGUqZCgwKSwuNSotcykpLGgucHVzaCgwKSxyLnB1c2gobmV3IGkodCp1KDApLHQqZCgwKSwuNSpzKSksYy5wdXNoKDEpO2Zvcih2YXIgcD0wO3A8bjtwKyspe2NvbnN0IG89MipNYXRoLlBJL24qKHArMSkseT0yKk1hdGguUEkvbioocCsuNSk7cDxuLTE/KHIucHVzaChuZXcgaShlKnUobyksZSpkKG8pLC41Ki1zKSksaC5wdXNoKDIqcCsyKSxyLnB1c2gobmV3IGkodCp1KG8pLHQqZChvKSwuNSpzKSksYy5wdXNoKDIqcCszKSxsLnB1c2goWzIqcCsyLDIqcCszLDIqcCsxLDIqcF0pKTpsLnB1c2goWzAsMSwyKnArMSwyKnBdKSwobiUyPT0xfHxwPG4vMikmJmEucHVzaChuZXcgaSh1KHkpLGQoeSksMCkpfWwucHVzaChjKSxhLnB1c2gobmV3IGkoMCwwLDEpKTtjb25zdCB5PVtdO2ZvcihwPTA7cDxoLmxlbmd0aDtwKyspeS5wdXNoKGhbaC5sZW5ndGgtcC0xXSk7bC5wdXNoKHkpLHN1cGVyKHIsbCxhKX19Y2xhc3MgeGUgZXh0ZW5kcyBje2NvbnN0cnVjdG9yKCl7c3VwZXIoe3R5cGU6Yy50eXBlcy5QQVJUSUNMRX0pfWNhbGN1bGF0ZUxvY2FsSW5lcnRpYSh0LGU9bmV3IGkpe3JldHVybiBlLnNldCgwLDAsMCksZX12b2x1bWUoKXtyZXR1cm4gMH11cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpe3RoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9MH1jYWxjdWxhdGVXb3JsZEFBQkIodCxlLHMsaSl7cy5jb3B5KHQpLGkuY29weSh0KX19Y2xhc3MgZ2UgZXh0ZW5kcyBje2NvbnN0cnVjdG9yKHQsZSl7ZT1vLmRlZmF1bHRzKGUse21heFZhbHVlOm51bGwsbWluVmFsdWU6bnVsbCxlbGVtZW50U2l6ZToxfSksdGhpcy5kYXRhPXQsdGhpcy5tYXhWYWx1ZT1lLm1heFZhbHVlLHRoaXMubWluVmFsdWU9ZS5taW5WYWx1ZSx0aGlzLmVsZW1lbnRTaXplPWUuZWxlbWVudFNpemUsbnVsbD09PWUubWluVmFsdWUmJnRoaXMudXBkYXRlTWluVmFsdWUoKSxudWxsPT09ZS5tYXhWYWx1ZSYmdGhpcy51cGRhdGVNYXhWYWx1ZSgpLHRoaXMuY2FjaGVFbmFibGVkPSEwLHN1cGVyKHt0eXBlOmMudHlwZXMuSEVJR0hURklFTER9KSx0aGlzLnBpbGxhckNvbnZleD1uZXcgZix0aGlzLnBpbGxhck9mZnNldD1uZXcgaSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCksdGhpcy5fY2FjaGVkUGlsbGFycz17fX11cGRhdGUoKXt0aGlzLl9jYWNoZWRQaWxsYXJzPXt9fXVwZGF0ZU1pblZhbHVlKCl7Y29uc3QgdD10aGlzLmRhdGE7bGV0IGU9dFswXVswXTtmb3IobGV0IHM9MDtzIT09dC5sZW5ndGg7cysrKWZvcihsZXQgaT0wO2khPT10W3NdLmxlbmd0aDtpKyspe2NvbnN0IG89dFtzXVtpXTtvPGUmJihlPW8pfXRoaXMubWluVmFsdWU9ZX11cGRhdGVNYXhWYWx1ZSgpe2NvbnN0IHQ9dGhpcy5kYXRhO2xldCBlPXRbMF1bMF07Zm9yKGxldCBzPTA7cyE9PXQubGVuZ3RoO3MrKylmb3IobGV0IGk9MDtpIT09dFtzXS5sZW5ndGg7aSsrKXtjb25zdCBvPXRbc11baV07bz5lJiYoZT1vKX10aGlzLm1heFZhbHVlPWV9c2V0SGVpZ2h0VmFsdWVBdEluZGV4KHQsZSxzKXt0aGlzLmRhdGFbdF1bZV09cyx0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodCxlLCExKSx0PjAmJih0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodC0xLGUsITApLHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LTEsZSwhMSkpLGU+MCYmKHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUtMSwhMCksdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHQsZS0xLCExKSksZT4wJiZ0PjAmJnRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LTEsZS0xLCEwKX1nZXRSZWN0TWluTWF4KHQsZSxzLGksbz1bXSl7Y29uc3Qgbj10aGlzLmRhdGE7bGV0IHI9dGhpcy5taW5WYWx1ZTtmb3IobGV0IG89dDtvPD1zO28rKylmb3IobGV0IHQ9ZTt0PD1pO3QrKyl7Y29uc3QgZT1uW29dW3RdO2U+ciYmKHI9ZSl9b1swXT10aGlzLm1pblZhbHVlLG9bMV09cn1nZXRJbmRleE9mUG9zaXRpb24odCxlLHMsaSl7Y29uc3Qgbz10aGlzLmVsZW1lbnRTaXplLG49dGhpcy5kYXRhO2xldCByPU1hdGguZmxvb3IodC9vKSxhPU1hdGguZmxvb3IoZS9vKTtyZXR1cm4gc1swXT1yLHNbMV09YSxpJiYocjwwJiYocj0wKSxhPDAmJihhPTApLHI+PW4ubGVuZ3RoLTEmJihyPW4ubGVuZ3RoLTEpLGE+PW5bMF0ubGVuZ3RoLTEmJihhPW5bMF0ubGVuZ3RoLTEpKSwhKHI8MHx8YTwwfHxyPj1uLmxlbmd0aC0xfHxhPj1uWzBdLmxlbmd0aC0xKX1nZXRUcmlhbmdsZUF0KHQsZSxzLGksbyxuKXtjb25zdCByPWJlO3RoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHQsZSxyLHMpO2xldCBhPXJbMF0sbD1yWzFdO2NvbnN0IGg9dGhpcy5kYXRhO3MmJihhPU1hdGgubWluKGgubGVuZ3RoLTIsTWF0aC5tYXgoMCxhKSksbD1NYXRoLm1pbihoWzBdLmxlbmd0aC0yLE1hdGgubWF4KDAsbCkpKTtjb25zdCBjPXRoaXMuZWxlbWVudFNpemUsdT0odC9jLWEpKioyKyhlL2MtbCkqKjI+KHQvYy0oYSsxKSkqKjIrKGUvYy0obCsxKSkqKjI7cmV0dXJuIHRoaXMuZ2V0VHJpYW5nbGUoYSxsLHUsaSxvLG4pLHV9Z2V0Tm9ybWFsQXQodCxlLHMsaSl7Y29uc3Qgbz1TZSxuPUZlLHI9TWUsYT1DZSxsPXFlO3RoaXMuZ2V0VHJpYW5nbGVBdCh0LGUscyxvLG4sciksbi52c3ViKG8sYSksci52c3ViKG8sbCksYS5jcm9zcyhsLGkpLGkubm9ybWFsaXplKCl9Z2V0QWFiYkF0SW5kZXgodCxlLHtsb3dlckJvdW5kOnMsdXBwZXJCb3VuZDppfSl7Y29uc3Qgbz10aGlzLmRhdGEsbj10aGlzLmVsZW1lbnRTaXplO3Muc2V0KHQqbixlKm4sb1t0XVtlXSksaS5zZXQoKHQrMSkqbiwoZSsxKSpuLG9bdCsxXVtlKzFdKX1nZXRIZWlnaHRBdCh0LGUscyl7Y29uc3QgaT10aGlzLmRhdGEsbz1CZSxuPUVlLHI9emUsYT1iZTt0aGlzLmdldEluZGV4T2ZQb3NpdGlvbih0LGUsYSxzKTtsZXQgbD1hWzBdLGg9YVsxXTtzJiYobD1NYXRoLm1pbihpLmxlbmd0aC0yLE1hdGgubWF4KDAsbCkpLGg9TWF0aC5taW4oaVswXS5sZW5ndGgtMixNYXRoLm1heCgwLGgpKSk7Y29uc3QgYz10aGlzLmdldFRyaWFuZ2xlQXQodCxlLHMsbyxuLHIpOyFmdW5jdGlvbih0LGUscyxpLG8sbixyLGEsbCl7bC54PSgobi1hKSoodC1yKSsoci1vKSooZS1hKSkvKChuLWEpKihzLXIpKyhyLW8pKihpLWEpKSxsLnk9KChhLWkpKih0LXIpKyhzLXIpKihlLWEpKS8oKG4tYSkqKHMtcikrKHItbykqKGktYSkpLGwuej0xLWwueC1sLnl9KHQsZSxvLngsby55LG4ueCxuLnksci54LHIueSxBZSk7Y29uc3QgdT1BZTtyZXR1cm4gYz9pW2wrMV1baCsxXSp1LngraVtsXVtoKzFdKnUueStpW2wrMV1baF0qdS56OmlbbF1baF0qdS54K2lbbCsxXVtoXSp1LnkraVtsXVtoKzFdKnUuen1nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHQsZSxzKXtyZXR1cm4gdCsiXyIrZSsiXyIrKHM/MTowKX1nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUscyl7cmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHQsZSxzKV19c2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIodCxlLHMsaSxvKXt0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh0LGUscyldPXtjb252ZXg6aSxvZmZzZXQ6b319Y2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUscyl7ZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHQsZSxzKV19Z2V0VHJpYW5nbGUodCxlLHMsaSxvLG4pe2NvbnN0IHI9dGhpcy5kYXRhLGE9dGhpcy5lbGVtZW50U2l6ZTtzPyhpLnNldCgodCsxKSphLChlKzEpKmEsclt0KzFdW2UrMV0pLG8uc2V0KHQqYSwoZSsxKSphLHJbdF1bZSsxXSksbi5zZXQoKHQrMSkqYSxlKmEsclt0KzFdW2VdKSk6KGkuc2V0KHQqYSxlKmEsclt0XVtlXSksby5zZXQoKHQrMSkqYSxlKmEsclt0KzFdW2VdKSxuLnNldCh0KmEsKGUrMSkqYSxyW3RdW2UrMV0pKX1nZXRDb252ZXhUcmlhbmdsZVBpbGxhcih0LGUscyl7bGV0IG89dGhpcy5waWxsYXJDb252ZXgsbj10aGlzLnBpbGxhck9mZnNldDtpZih0aGlzLmNhY2hlRW5hYmxlZCl7aWYocj10aGlzLmdldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHQsZSxzKSlyZXR1cm4gdGhpcy5waWxsYXJDb252ZXg9ci5jb252ZXgsdm9pZCh0aGlzLnBpbGxhck9mZnNldD1yLm9mZnNldCk7bz1uZXcgZixuPW5ldyBpLHRoaXMucGlsbGFyQ29udmV4PW8sdGhpcy5waWxsYXJPZmZzZXQ9bn12YXIgcj10aGlzLmRhdGE7Y29uc3QgYT10aGlzLmVsZW1lbnRTaXplLGw9by5mYWNlcztvLnZlcnRpY2VzLmxlbmd0aD02O2Zvcih2YXIgaD0wO2g8NjtoKyspby52ZXJ0aWNlc1toXXx8KG8udmVydGljZXNbaF09bmV3IGkpO2wubGVuZ3RoPTU7Zm9yKGg9MDtoPDU7aCsrKWxbaF18fChsW2hdPVtdKTtjb25zdCBjPW8udmVydGljZXMsdT0oTWF0aC5taW4oclt0XVtlXSxyW3QrMV1bZV0sclt0XVtlKzFdLHJbdCsxXVtlKzFdKS10aGlzLm1pblZhbHVlKS8yK3RoaXMubWluVmFsdWU7cz8obi5zZXQoKHQrLjc1KSphLChlKy43NSkqYSx1KSxjWzBdLnNldCguMjUqYSwuMjUqYSxyW3QrMV1bZSsxXS11KSxjWzFdLnNldCgtLjc1KmEsLjI1KmEsclt0XVtlKzFdLXUpLGNbMl0uc2V0KC4yNSphLC0uNzUqYSxyW3QrMV1bZV0tdSksY1szXS5zZXQoLjI1KmEsLjI1KmEsLXUtMSksY1s0XS5zZXQoLS43NSphLC4yNSphLC11LTEpLGNbNV0uc2V0KC4yNSphLC0uNzUqYSwtdS0xKSxsWzBdWzBdPTAsbFswXVsxXT0xLGxbMF1bMl09MixsWzFdWzBdPTUsbFsxXVsxXT00LGxbMV1bMl09MyxsWzJdWzBdPTIsbFsyXVsxXT01LGxbMl1bMl09MyxsWzJdWzNdPTAsbFszXVswXT0zLGxbM11bMV09NCxsWzNdWzJdPTEsbFszXVszXT0wLGxbNF1bMF09MSxsWzRdWzFdPTQsbFs0XVsyXT01LGxbNF1bM109Mik6KG4uc2V0KCh0Ky4yNSkqYSwoZSsuMjUpKmEsdSksY1swXS5zZXQoLS4yNSphLC0uMjUqYSxyW3RdW2VdLXUpLGNbMV0uc2V0KC43NSphLC0uMjUqYSxyW3QrMV1bZV0tdSksY1syXS5zZXQoLS4yNSphLC43NSphLHJbdF1bZSsxXS11KSxjWzNdLnNldCgtLjI1KmEsLS4yNSphLC11LTEpLGNbNF0uc2V0KC43NSphLC0uMjUqYSwtdS0xKSxjWzVdLnNldCgtLjI1KmEsLjc1KmEsLXUtMSksbFswXVswXT0wLGxbMF1bMV09MSxsWzBdWzJdPTIsbFsxXVswXT01LGxbMV1bMV09NCxsWzFdWzJdPTMsbFsyXVswXT0wLGxbMl1bMV09MixsWzJdWzJdPTUsbFsyXVszXT0zLGxbM11bMF09MSxsWzNdWzFdPTAsbFszXVsyXT0zLGxbM11bM109NCxsWzRdWzBdPTQsbFs0XVsxXT01LGxbNF1bMl09MixsWzRdWzNdPTEpLG8uY29tcHV0ZU5vcm1hbHMoKSxvLmNvbXB1dGVFZGdlcygpLG8udXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSx0aGlzLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHQsZSxzLG8sbil9Y2FsY3VsYXRlTG9jYWxJbmVydGlhKHQsZT1uZXcgaSl7cmV0dXJuIGUuc2V0KDAsMCwwKSxlfXZvbHVtZSgpe3JldHVybiBOdW1iZXIuTUFYX1ZBTFVFfWNhbGN1bGF0ZVdvcmxkQUFCQih0LGUscyxpKXtzLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSksaS5zZXQoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpfXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7Y29uc3QgdD10aGlzLmRhdGEsZT10aGlzLmVsZW1lbnRTaXplO3RoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXM9bmV3IGkodC5sZW5ndGgqZSx0WzBdLmxlbmd0aCplLE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLE1hdGguYWJzKHRoaXMubWluVmFsdWUpKSkubm9ybSgpfXNldEhlaWdodHNGcm9tSW1hZ2UodCx7eDplLHo6cyx5Oml9KXtjb25zdCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO28ud2lkdGg9dC53aWR0aCxvLmhlaWdodD10LmhlaWdodDtjb25zdCBuPW8uZ2V0Q29udGV4dCgiMmQiKTtuLmRyYXdJbWFnZSh0LDAsMCk7Y29uc3Qgcj1uLmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCksYT10aGlzLmRhdGE7YS5sZW5ndGg9MCx0aGlzLmVsZW1lbnRTaXplPU1hdGguYWJzKGUpL3Iud2lkdGg7Zm9yKGxldCB0PTA7dDxyLmhlaWdodDt0Kyspe2NvbnN0IG89W107Zm9yKGxldCBpPTA7aTxyLndpZHRoO2krKyl7Y29uc3Qgbj0oci5kYXRhWzQqKHQqci5oZWlnaHQraSldK3IuZGF0YVs0Kih0KnIuaGVpZ2h0K2kpKzFdK3IuZGF0YVs0Kih0KnIuaGVpZ2h0K2kpKzJdKS80LzI1NSpzO2U8MD9vLnB1c2gobik6by51bnNoaWZ0KG4pfWk8MD9hLnVuc2hpZnQobyk6YS5wdXNoKG8pfXRoaXMudXBkYXRlTWF4VmFsdWUoKSx0aGlzLnVwZGF0ZU1pblZhbHVlKCksdGhpcy51cGRhdGUoKX19Y29uc3QgYmU9W10sQWU9bmV3IGksQmU9bmV3IGksRWU9bmV3IGksemU9bmV3IGksU2U9bmV3IGksRmU9bmV3IGksTWU9bmV3IGksQ2U9bmV3IGkscWU9bmV3IGk7Y2xhc3MgVGV7Y29uc3RydWN0b3IodD17fSl7dGhpcy5yb290PXQucm9vdHx8bnVsbCx0aGlzLmFhYmI9dC5hYWJiP3QuYWFiYi5jbG9uZSgpOm5ldyBuLHRoaXMuZGF0YT1bXSx0aGlzLmNoaWxkcmVuPVtdfXJlc2V0KHQsZSl7dGhpcy5jaGlsZHJlbi5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aD0wfWluc2VydCh0LGUscyl7Y29uc3QgaT10aGlzLmRhdGE7aWYocz1zfHwwLCF0aGlzLmFhYmIuY29udGFpbnModCkpcmV0dXJuITE7Y29uc3Qgbz10aGlzLmNoaWxkcmVuO2lmKHM8KHRoaXMubWF4RGVwdGh8fHRoaXMucm9vdC5tYXhEZXB0aCkpe2xldCBpPSExO28ubGVuZ3RofHwodGhpcy5zdWJkaXZpZGUoKSxpPSEwKTtmb3IobGV0IGk9MDs4IT09aTtpKyspaWYob1tpXS5pbnNlcnQodCxlLHMrMSkpcmV0dXJuITA7aSYmKG8ubGVuZ3RoPTApfXJldHVybiBpLnB1c2goZSksITB9c3ViZGl2aWRlKCl7Y29uc3QgdD10aGlzLmFhYmIsZT10Lmxvd2VyQm91bmQscz10LnVwcGVyQm91bmQsbz10aGlzLmNoaWxkcmVuO28ucHVzaChuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMCwwLDApfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMSwwLDApfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMSwxLDApfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMSwxLDEpfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMCwxLDEpfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMCwwLDEpfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMSwwLDEpfSl9KSxuZXcgVGUoe2FhYmI6bmV3IG4oe2xvd2VyQm91bmQ6bmV3IGkoMCwxLDApfSl9KSkscy52c3ViKGUsUGUpLFBlLnNjYWxlKC41LFBlKTtjb25zdCByPXRoaXMucm9vdHx8dGhpcztmb3IobGV0IHQ9MDs4IT09dDt0Kyspe2NvbnN0IHM9b1t0XTtzLnJvb3Q9cjtjb25zdCBpPXMuYWFiYi5sb3dlckJvdW5kO2kueCo9UGUueCxpLnkqPVBlLnksaS56Kj1QZS56LGkudmFkZChlLGkpLGkudmFkZChQZSxzLmFhYmIudXBwZXJCb3VuZCl9fWFhYmJRdWVyeSh0LGUpe3RoaXMuZGF0YSx0aGlzLmNoaWxkcmVuO2NvbnN0IHM9W3RoaXNdO2Zvcig7cy5sZW5ndGg7KXtjb25zdCBpPXMucG9wKCk7aS5hYWJiLm92ZXJsYXBzKHQpJiZBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlLGkuZGF0YSksQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocyxpLmNoaWxkcmVuKX1yZXR1cm4gZX1yYXlRdWVyeSh0LGUscyl7cmV0dXJuIHQuZ2V0QUFCQihSZSksUmUudG9Mb2NhbEZyYW1lKGUsUmUpLHRoaXMuYWFiYlF1ZXJ5KFJlLHMpLHN9cmVtb3ZlRW1wdHlOb2Rlcygpe2ZvcihsZXQgdD10aGlzLmNoaWxkcmVuLmxlbmd0aC0xO3Q+PTA7dC0tKXRoaXMuY2hpbGRyZW5bdF0ucmVtb3ZlRW1wdHlOb2RlcygpLHRoaXMuY2hpbGRyZW5bdF0uY2hpbGRyZW4ubGVuZ3RofHx0aGlzLmNoaWxkcmVuW3RdLmRhdGEubGVuZ3RofHx0aGlzLmNoaWxkcmVuLnNwbGljZSh0LDEpfX1jbGFzcyBOZSBleHRlbmRzIFRle2NvbnN0cnVjdG9yKHQsZT17fSl7c3VwZXIoZSksZS5yb290PW51bGwsZS5hYWJiPXQsdGhpcy5tYXhEZXB0aD12b2lkIDAhPT1lLm1heERlcHRoP2UubWF4RGVwdGg6OH19Y29uc3QgUGU9bmV3IGksUmU9bmV3IG47Y2xhc3MgSWUgZXh0ZW5kcyBje2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIoe3R5cGU6Yy50eXBlcy5UUklNRVNIfSksdGhpcy52ZXJ0aWNlcz1uZXcgRmxvYXQzMkFycmF5KHQpLHRoaXMuaW5kaWNlcz1uZXcgSW50MTZBcnJheShlKSx0aGlzLm5vcm1hbHM9bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCksdGhpcy5hYWJiPW5ldyBuLHRoaXMuZWRnZXM9bnVsbCx0aGlzLnNjYWxlPW5ldyBpKDEsMSwxKSx0aGlzLnRyZWU9bmV3IE5lLHRoaXMudXBkYXRlRWRnZXMoKSx0aGlzLnVwZGF0ZU5vcm1hbHMoKSx0aGlzLnVwZGF0ZUFBQkIoKSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCksdGhpcy51cGRhdGVUcmVlKCl9dXBkYXRlVHJlZSgpe2NvbnN0IHQ9dGhpcy50cmVlO3QucmVzZXQoKSx0LmFhYmIuY29weSh0aGlzLmFhYmIpO2NvbnN0IGU9dGhpcy5zY2FsZTt0LmFhYmIubG93ZXJCb3VuZC54Kj0xL2UueCx0LmFhYmIubG93ZXJCb3VuZC55Kj0xL2UueSx0LmFhYmIubG93ZXJCb3VuZC56Kj0xL2Uueix0LmFhYmIudXBwZXJCb3VuZC54Kj0xL2UueCx0LmFhYmIudXBwZXJCb3VuZC55Kj0xL2UueSx0LmFhYmIudXBwZXJCb3VuZC56Kj0xL2Uuejtjb25zdCBzPW5ldyBuLG89bmV3IGkscj1uZXcgaSxhPW5ldyBpLGw9W28scixhXTtmb3IobGV0IGU9MDtlPHRoaXMuaW5kaWNlcy5sZW5ndGgvMztlKyspe2NvbnN0IGk9MyplO3RoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpXSxvKSx0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaSsxXSxyKSx0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaSsyXSxhKSxzLnNldEZyb21Qb2ludHMobCksdC5pbnNlcnQocyxlKX10LnJlbW92ZUVtcHR5Tm9kZXMoKX1nZXRUcmlhbmdsZXNJbkFBQkIodCxlKXtqZS5jb3B5KHQpO2NvbnN0IHM9dGhpcy5zY2FsZSxpPXMueCxvPXMueSxuPXMueixyPWplLmxvd2VyQm91bmQsYT1qZS51cHBlckJvdW5kO3JldHVybiByLngvPWksci55Lz1vLHIuei89bixhLngvPWksYS55Lz1vLGEuei89bix0aGlzLnRyZWUuYWFiYlF1ZXJ5KGplLGUpfXNldFNjYWxlKHQpe2NvbnN0IGU9dGhpcy5zY2FsZS54PT09dGhpcy5zY2FsZS55PT09dGhpcy5zY2FsZS56LHM9dC54PT09dC55PT09dC56O2UmJnN8fHRoaXMudXBkYXRlTm9ybWFscygpLHRoaXMuc2NhbGUuY29weSh0KSx0aGlzLnVwZGF0ZUFBQkIoKSx0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl9dXBkYXRlTm9ybWFscygpe2NvbnN0IHQ9TGUsZT10aGlzLm5vcm1hbHM7Zm9yKGxldCBzPTA7czx0aGlzLmluZGljZXMubGVuZ3RoLzM7cysrKXtjb25zdCBpPTMqcyxvPXRoaXMuaW5kaWNlc1tpXSxuPXRoaXMuaW5kaWNlc1tpKzFdLHI9dGhpcy5pbmRpY2VzW2krMl07dGhpcy5nZXRWZXJ0ZXgobyxfZSksdGhpcy5nZXRWZXJ0ZXgobixIZSksdGhpcy5nZXRWZXJ0ZXgocixVZSksSWUuY29tcHV0ZU5vcm1hbChIZSxfZSxVZSx0KSxlW2ldPXQueCxlW2krMV09dC55LGVbaSsyXT10Lnp9fXVwZGF0ZUVkZ2VzKCl7Y29uc3QgdD17fSxlPShlLHMpPT57dFtpPG8/aSsiXyIrbzpvKyJfIitpXT0hMH07Zm9yKHZhciBzPTA7czx0aGlzLmluZGljZXMubGVuZ3RoLzM7cysrKXtjb25zdCB0PTMqczt2YXIgaT10aGlzLmluZGljZXNbdF0sbz10aGlzLmluZGljZXNbdCsxXTt0aGlzLmluZGljZXNbdCsyXTtlKCksZSgpLGUoKX1jb25zdCBuPU9iamVjdC5rZXlzKHQpO3RoaXMuZWRnZXM9bmV3IEludDE2QXJyYXkoMipuLmxlbmd0aCk7Zm9yKHM9MDtzPG4ubGVuZ3RoO3MrKyl7Y29uc3QgdD1uW3NdLnNwbGl0KCJfIik7dGhpcy5lZGdlc1syKnNdPXBhcnNlSW50KHRbMF0sMTApLHRoaXMuZWRnZXNbMipzKzFdPXBhcnNlSW50KHRbMV0sMTApfX1nZXRFZGdlVmVydGV4KHQsZSxzKXtjb25zdCBpPXRoaXMuZWRnZXNbMip0KyhlPzE6MCldO3RoaXMuZ2V0VmVydGV4KGkscyl9Z2V0RWRnZVZlY3Rvcih0LGUpe2NvbnN0IHM9VmUsaT1rZTt0aGlzLmdldEVkZ2VWZXJ0ZXgodCwwLHMpLHRoaXMuZ2V0RWRnZVZlcnRleCh0LDEsaSksaS52c3ViKHMsZSl9Z2V0VmVydGV4KHQsZSl7Y29uc3Qgcz10aGlzLnNjYWxlO3JldHVybiB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0LGUpLGUueCo9cy54LGUueSo9cy55LGUueio9cy56LGV9X2dldFVuc2NhbGVkVmVydGV4KHQsZSl7Y29uc3Qgcz0zKnQsaT10aGlzLnZlcnRpY2VzO3JldHVybiBlLnNldChpW3NdLGlbcysxXSxpW3MrMl0pfWdldFdvcmxkVmVydGV4KHQsZSxzLGkpe3JldHVybiB0aGlzLmdldFZlcnRleCh0LGkpLG0ucG9pbnRUb1dvcmxkRnJhbWUoZSxzLGksaSksaX1nZXRUcmlhbmdsZVZlcnRpY2VzKHQsZSxzLGkpe2NvbnN0IG89Myp0O3RoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tvXSxlKSx0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbbysxXSxzKSx0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbbysyXSxpKX1nZXROb3JtYWwodCxlKXtjb25zdCBzPTMqdDtyZXR1cm4gZS5zZXQodGhpcy5ub3JtYWxzW3NdLHRoaXMubm9ybWFsc1tzKzFdLHRoaXMubm9ybWFsc1tzKzJdKX1jYWxjdWxhdGVMb2NhbEluZXJ0aWEodCxlKXt0aGlzLmNvbXB1dGVMb2NhbEFBQkIoRGUpO2NvbnN0IHM9RGUudXBwZXJCb3VuZC54LURlLmxvd2VyQm91bmQueCxpPURlLnVwcGVyQm91bmQueS1EZS5sb3dlckJvdW5kLnksbz1EZS51cHBlckJvdW5kLnotRGUubG93ZXJCb3VuZC56O3JldHVybiBlLnNldCgxLzEyKnQqKDIqaSoyKmkrMipvKjIqbyksMS8xMip0KigyKnMqMipzKzIqbyoyKm8pLDEvMTIqdCooMippKjIqaSsyKnMqMipzKSl9Y29tcHV0ZUxvY2FsQUFCQih7bG93ZXJCb3VuZDp0LHVwcGVyQm91bmQ6ZX0pe2NvbnN0IHM9dCxpPWUsbz10aGlzLnZlcnRpY2VzLmxlbmd0aCxuPSh0aGlzLnZlcnRpY2VzLEdlKTt0aGlzLmdldFZlcnRleCgwLG4pLHMuY29weShuKSxpLmNvcHkobik7Zm9yKGxldCB0PTA7dCE9PW87dCsrKXRoaXMuZ2V0VmVydGV4KHQsbiksbi54PHMueD9zLng9bi54Om4ueD5pLngmJihpLng9bi54KSxuLnk8cy55P3MueT1uLnk6bi55PmkueSYmKGkueT1uLnkpLG4uejxzLno/cy56PW4uejpuLno+aS56JiYoaS56PW4ueil9dXBkYXRlQUFCQigpe3RoaXMuY29tcHV0ZUxvY2FsQUFCQih0aGlzLmFhYmIpfXVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCl7bGV0IHQ9MDtjb25zdCBlPXRoaXMudmVydGljZXMscz1uZXcgaTtmb3IobGV0IGk9MCxvPWUubGVuZ3RoLzM7aSE9PW87aSsrKXt0aGlzLmdldFZlcnRleChpLHMpO2NvbnN0IGU9cy5ub3JtMigpO2U+dCYmKHQ9ZSl9dGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cz1NYXRoLnNxcnQodCl9Y2FsY3VsYXRlV29ybGRBQUJCKHQsZSxzLGkpe2NvbnN0IG89WGUsbj1ZZTtvLnBvc2l0aW9uPXQsby5xdWF0ZXJuaW9uPWUsdGhpcy5hYWJiLnRvV29ybGRGcmFtZShvLG4pLHMuY29weShuLmxvd2VyQm91bmQpLGkuY29weShuLnVwcGVyQm91bmQpfXZvbHVtZSgpe3JldHVybiA0Kk1hdGguUEkqdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cy8zfX1jb25zdCBMZT1uZXcgaSxqZT1uZXcgbixWZT1uZXcgaSxrZT1uZXcgaSxXZT1uZXcgaSxPZT1uZXcgaTtJZS5jb21wdXRlTm9ybWFsPSh0LGUscyxpKT0+e2UudnN1Yih0LE9lKSxzLnZzdWIoZSxXZSksV2UuY3Jvc3MoT2UsaSksaS5pc1plcm8oKXx8aS5ub3JtYWxpemUoKX07dmFyIF9lPW5ldyBpLEhlPW5ldyBpLFVlPW5ldyBpO2NvbnN0IERlPW5ldyBuLEdlPW5ldyBpLFhlPW5ldyBtLFllPW5ldyBuO0llLmNyZWF0ZVRvcnVzPSh0PTEsZT0uNSxzPTgsaT02LG89MipNYXRoLlBJKT0+e2NvbnN0IG49W10scj1bXTtmb3IodmFyIGE9MDthPD1zO2ErKylmb3IodmFyIGw9MDtsPD1pO2wrKyl7Y29uc3Qgcj1sL2kqbyxoPWEvcypNYXRoLlBJKjIsYz0odCtlKk1hdGguY29zKGgpKSpNYXRoLmNvcyhyKSx1PSh0K2UqTWF0aC5jb3MoaCkpKk1hdGguc2luKHIpLGQ9ZSpNYXRoLnNpbihoKTtuLnB1c2goYyx1LGQpfWZvcihhPTE7YTw9czthKyspZm9yKGw9MTtsPD1pO2wrKyl7Y29uc3QgdD0oaSsxKSphK2wtMSxlPShpKzEpKihhLTEpK2wtMSxzPShpKzEpKihhLTEpK2wsbz0oaSsxKSphK2w7ci5wdXNoKHQsZSxvKSxyLnB1c2goZSxzLG8pfXJldHVybiBuZXcgSWUobixyKX07Y2xhc3MgWmUgZXh0ZW5kcyBjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuZXF1YXRpb25zPVtdfXNvbHZlKHQsZSl7cmV0dXJuIDB9YWRkRXF1YXRpb24odCl7dC5lbmFibGVkJiZ0aGlzLmVxdWF0aW9ucy5wdXNoKHQpfXJlbW92ZUVxdWF0aW9uKHQpe2NvbnN0IGU9dGhpcy5lcXVhdGlvbnMscz1lLmluZGV4T2YodCk7LTEhPT1zJiZlLnNwbGljZShzLDEpfXJlbW92ZUFsbEVxdWF0aW9ucygpe3RoaXMuZXF1YXRpb25zLmxlbmd0aD0wfX17Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuaXRlcmF0aW9ucz0xMCx0aGlzLnRvbGVyYW5jZT0xZS03fXNvbHZlKHQsZSl7bGV0IHM9MDtjb25zdCBpPXRoaXMuaXRlcmF0aW9ucyxvPXRoaXMudG9sZXJhbmNlKnRoaXMudG9sZXJhbmNlLG49dGhpcy5lcXVhdGlvbnMscj1uLmxlbmd0aCxhPWUuYm9kaWVzLGw9YS5sZW5ndGgsaD10O2xldCBjLHUsZCxwLHksbTtpZigwIT09cilmb3IodmFyIHY9MDt2IT09bDt2KyspYVt2XS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7Y29uc3QgZj1RZSx3PUplLHg9S2U7Zi5sZW5ndGg9cix3Lmxlbmd0aD1yLHgubGVuZ3RoPXI7Zm9yKHY9MDt2IT09cjt2Kyspe3ZhciBnPW5bdl07eFt2XT0wLHdbdl09Zy5jb21wdXRlQihoKSxmW3ZdPTEvZy5jb21wdXRlQygpfWlmKDAhPT1yKXtmb3Iodj0wO3YhPT1sO3YrKyl7Y29uc3QgdD0oYj1hW3ZdKS52bGFtYmRhLGU9Yi53bGFtYmRhO3Quc2V0KDAsMCwwKSxlLnNldCgwLDAsMCl9Zm9yKHM9MDtzIT09aTtzKyspe3A9MDtmb3IobGV0IHQ9MDt0IT09cjt0Kyspe2c9blt0XTtjPXdbdF0sdT1mW3RdLG09eFt0XSx5PWcuY29tcHV0ZUdXbGFtYmRhKCksZD11KihjLXktZy5lcHMqbSksbStkPGcubWluRm9yY2U/ZD1nLm1pbkZvcmNlLW06bStkPmcubWF4Rm9yY2UmJihkPWcubWF4Rm9yY2UtbSkseFt0XSs9ZCxwKz1kPjA/ZDotZCxnLmFkZFRvV2xhbWJkYShkKX1pZihwKnA8bylicmVha31mb3Iodj0wO3YhPT1sO3YrKyl7dmFyIGI7Y29uc3QgdD0oYj1hW3ZdKS52ZWxvY2l0eSxlPWIuYW5ndWxhclZlbG9jaXR5O2IudmxhbWJkYS52bXVsKGIubGluZWFyRmFjdG9yLGIudmxhbWJkYSksdC52YWRkKGIudmxhbWJkYSx0KSxiLndsYW1iZGEudm11bChiLmFuZ3VsYXJGYWN0b3IsYi53bGFtYmRhKSxlLnZhZGQoYi53bGFtYmRhLGUpfWxldCB0PW4ubGVuZ3RoO2NvbnN0IGU9MS9oO2Zvcig7dC0tOyluW3RdLm11bHRpcGxpZXI9eFt0XSplfXJldHVybiBzfX1jb25zdCBLZT1bXSxRZT1bXSxKZT1bXTtjbGFzcyAkZSBleHRlbmRzIGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5vYmplY3RzPVtdLHRoaXMudHlwZT1PYmplY3R9cmVsZWFzZSguLi50KXtjb25zdCBlPXQubGVuZ3RoO2ZvcihsZXQgcz0wO3MhPT1lO3MrKyl0aGlzLm9iamVjdHMucHVzaCh0W3NdKTtyZXR1cm4gdGhpc31nZXQoKXtyZXR1cm4gMD09PXRoaXMub2JqZWN0cy5sZW5ndGg/dGhpcy5jb25zdHJ1Y3RPYmplY3QoKTp0aGlzLm9iamVjdHMucG9wKCl9Y29uc3RydWN0T2JqZWN0KCl7dGhyb3cgbmV3IEVycm9yKCJjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCEiKX1yZXNpemUodCl7Y29uc3QgZT10aGlzLm9iamVjdHM7Zm9yKDtlLmxlbmd0aD50OyllLnBvcCgpO2Zvcig7ZS5sZW5ndGg8dDspZS5wdXNoKHRoaXMuY29uc3RydWN0T2JqZWN0KCkpO3JldHVybiB0aGlzfX17Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMudHlwZT1pfWNvbnN0cnVjdE9iamVjdCgpe3JldHVybiBuZXcgaX19Y2xhc3MgdHN7Y29uc3RydWN0b3IodCl7dGhpcy5jb250YWN0UG9pbnRQb29sPVtdLHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w9W10sdGhpcy5yZXN1bHQ9W10sdGhpcy5mcmljdGlvblJlc3VsdD1bXSx0aGlzLnYzcG9vbD1uZXcgJGUsdGhpcy53b3JsZD10LHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbD1udWxsLHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb249ITF9Y3JlYXRlQ29udGFjdEVxdWF0aW9uKHQsZSxzLGksbyxuKXtsZXQgcjt0aGlzLmNvbnRhY3RQb2ludFBvb2wubGVuZ3RoPyhyPXRoaXMuY29udGFjdFBvaW50UG9vbC5wb3AoKSxyLmJpPXQsci5iaj1lKTpyPW5ldyBOdCh0LGUpLHIuZW5hYmxlZD10LmNvbGxpc2lvblJlc3BvbnNlJiZlLmNvbGxpc2lvblJlc3BvbnNlJiZzLmNvbGxpc2lvblJlc3BvbnNlJiZpLmNvbGxpc2lvblJlc3BvbnNlO2NvbnN0IGE9dGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO3IucmVzdGl0dXRpb249YS5yZXN0aXR1dGlvbixyLnNldFNwb29rUGFyYW1zKGEuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLGEuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbix0aGlzLndvcmxkLmR0KTtjb25zdCBsPXMubWF0ZXJpYWx8fHQubWF0ZXJpYWwsaD1pLm1hdGVyaWFsfHxlLm1hdGVyaWFsO3JldHVybiBsJiZoJiZsLnJlc3RpdHV0aW9uPj0wJiZoLnJlc3RpdHV0aW9uPj0wJiYoci5yZXN0aXR1dGlvbj1sLnJlc3RpdHV0aW9uKmgucmVzdGl0dXRpb24pLHIuc2k9b3x8cyxyLnNqPW58fGkscn1jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHQsZSl7Y29uc3Qgcz10LmJpLGk9dC5iaixvPXQuc2ksbj10LnNqLHI9dGhpcy53b3JsZCxhPXRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtsZXQgbD1hLmZyaWN0aW9uO2NvbnN0IGg9by5tYXRlcmlhbHx8cy5tYXRlcmlhbCxjPW4ubWF0ZXJpYWx8fGkubWF0ZXJpYWw7aWYoaCYmYyYmaC5mcmljdGlvbj49MCYmYy5mcmljdGlvbj49MCYmKGw9aC5mcmljdGlvbipjLmZyaWN0aW9uKSxsPjApe2NvbnN0IG89bCpyLmdyYXZpdHkubGVuZ3RoKCk7bGV0IG49cy5pbnZNYXNzK2kuaW52TWFzcztuPjAmJihuPTEvbik7Y29uc3QgaD10aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sLGM9aC5sZW5ndGg/aC5wb3AoKTpuZXcgZWUocyxpLG8qbiksdT1oLmxlbmd0aD9oLnBvcCgpOm5ldyBlZShzLGksbypuKTtyZXR1cm4gYy5iaT11LmJpPXMsYy5iaj11LmJqPWksYy5taW5Gb3JjZT11Lm1pbkZvcmNlPS1vKm4sYy5tYXhGb3JjZT11Lm1heEZvcmNlPW8qbixjLnJpLmNvcHkodC5yaSksYy5yai5jb3B5KHQucmopLHUucmkuY29weSh0LnJpKSx1LnJqLmNvcHkodC5yaiksdC5uaS50YW5nZW50cyhjLnQsdS50KSxjLnNldFNwb29rUGFyYW1zKGEuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyxhLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLHIuZHQpLHUuc2V0U3Bvb2tQYXJhbXMoYS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLGEuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sci5kdCksYy5lbmFibGVkPXUuZW5hYmxlZD10LmVuYWJsZWQsZS5wdXNoKGMsdSksITB9cmV0dXJuITF9Y3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSh0KXtsZXQgZT10aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGgtMV07aWYoIXRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChlLHRoaXMuZnJpY3Rpb25SZXN1bHQpfHwxPT09dClyZXR1cm47Y29uc3Qgcz10aGlzLmZyaWN0aW9uUmVzdWx0W3RoaXMuZnJpY3Rpb25SZXN1bHQubGVuZ3RoLTJdLGk9dGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aC0xXTtlcy5zZXRaZXJvKCksc3Muc2V0WmVybygpLGlzLnNldFplcm8oKTtjb25zdCBvPWUuYmk7ZS5iajtmb3IobGV0IHM9MDtzIT09dDtzKyspZT10aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGgtMS1zXSxlLmJvZHlBIT09bz8oZXMudmFkZChlLm5pLGVzKSxzcy52YWRkKGUucmksc3MpLGlzLnZhZGQoZS5yaixpcykpOihlcy52c3ViKGUubmksZXMpLHNzLnZhZGQoZS5yaixzcyksaXMudmFkZChlLnJpLGlzKSk7Y29uc3Qgbj0xL3Q7c3Muc2NhbGUobixzLnJpKSxpcy5zY2FsZShuLHMucmopLGkucmkuY29weShzLnJpKSxpLnJqLmNvcHkocy5yaiksZXMubm9ybWFsaXplKCksZXMudGFuZ2VudHMocy50LGkudCl9Z2V0Q29udGFjdHModCxlLHMsaSxvLG4scil7dGhpcy5jb250YWN0UG9pbnRQb29sPW8sdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbD1yLHRoaXMucmVzdWx0PWksdGhpcy5mcmljdGlvblJlc3VsdD1uO2NvbnN0IGE9cnMsbD1hcyxoPW9zLGM9bnM7Zm9yKGxldCBpPTAsbz10Lmxlbmd0aDtpIT09bztpKyspe2NvbnN0IG89dFtpXSxuPWVbaV07bGV0IHI9bnVsbDtvLm1hdGVyaWFsJiZuLm1hdGVyaWFsJiYocj1zLmdldENvbnRhY3RNYXRlcmlhbChvLm1hdGVyaWFsLG4ubWF0ZXJpYWwpfHxudWxsKTtjb25zdCB1PW8udHlwZSZCLktJTkVNQVRJQyYmbi50eXBlJkIuU1RBVElDfHxvLnR5cGUmQi5TVEFUSUMmJm4udHlwZSZCLktJTkVNQVRJQ3x8by50eXBlJkIuS0lORU1BVElDJiZuLnR5cGUmQi5LSU5FTUFUSUM7Zm9yKGxldCB0PTA7dDxvLnNoYXBlcy5sZW5ndGg7dCsrKXtvLnF1YXRlcm5pb24ubXVsdChvLnNoYXBlT3JpZW50YXRpb25zW3RdLGEpLG8ucXVhdGVybmlvbi52bXVsdChvLnNoYXBlT2Zmc2V0c1t0XSxoKSxoLnZhZGQoby5wb3NpdGlvbixoKTtjb25zdCBlPW8uc2hhcGVzW3RdO2ZvcihsZXQgdD0wO3Q8bi5zaGFwZXMubGVuZ3RoO3QrKyl7bi5xdWF0ZXJuaW9uLm11bHQobi5zaGFwZU9yaWVudGF0aW9uc1t0XSxsKSxuLnF1YXRlcm5pb24udm11bHQobi5zaGFwZU9mZnNldHNbdF0sYyksYy52YWRkKG4ucG9zaXRpb24sYyk7Y29uc3QgaT1uLnNoYXBlc1t0XTtpZighKGUuY29sbGlzaW9uRmlsdGVyTWFzayZpLmNvbGxpc2lvbkZpbHRlckdyb3VwJiZpLmNvbGxpc2lvbkZpbHRlck1hc2smZS5jb2xsaXNpb25GaWx0ZXJHcm91cCkpY29udGludWU7aWYoaC5kaXN0YW5jZVRvKGMpPmUuYm91bmRpbmdTcGhlcmVSYWRpdXMraS5ib3VuZGluZ1NwaGVyZVJhZGl1cyljb250aW51ZTtsZXQgZD1udWxsO2UubWF0ZXJpYWwmJmkubWF0ZXJpYWwmJihkPXMuZ2V0Q29udGFjdE1hdGVyaWFsKGUubWF0ZXJpYWwsaS5tYXRlcmlhbCl8fG51bGwpLHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbD1kfHxyfHxzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7Y29uc3QgcD10aGlzW2UudHlwZXxpLnR5cGVdO2lmKHApe2xldCB0PSExO3Q9ZS50eXBlPGkudHlwZT9wLmNhbGwodGhpcyxlLGksaCxjLGEsbCxvLG4sZSxpLHUpOnAuY2FsbCh0aGlzLGksZSxjLGgsbCxhLG4sbyxlLGksdSksdCYmdSYmKHMuc2hhcGVPdmVybGFwS2VlcGVyLnNldChlLmlkLGkuaWQpLHMuYm9keU92ZXJsYXBLZWVwZXIuc2V0KG8uaWQsbi5pZCkpfX19fX19Y29uc3QgZXM9bmV3IGksc3M9bmV3IGksaXM9bmV3IGksb3M9bmV3IGksbnM9bmV3IGkscnM9bmV3IHUsYXM9bmV3IHU7dHMucHJvdG90eXBlW2MudHlwZXMuQk9YfGMudHlwZXMuQk9YXT10cy5wcm90b3R5cGUuYm94Qm94PWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7cmV0dXJuIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsPXQubWF0ZXJpYWwsZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWw9ZS5tYXRlcmlhbCx0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZT10LmNvbGxpc2lvblJlc3BvbnNlLGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlPWUuY29sbGlzaW9uUmVzcG9uc2UsdGhpcy5jb252ZXhDb252ZXgodC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24scyxpLG8sbixyLGEsdCxlLGMpfSx0cy5wcm90b3R5cGVbYy50eXBlcy5CT1h8Yy50eXBlcy5DT05WRVhQT0xZSEVEUk9OXT10cy5wcm90b3R5cGUuYm94Q29udmV4PWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7cmV0dXJuIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsPXQubWF0ZXJpYWwsdC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2U9dC5jb2xsaXNpb25SZXNwb25zZSx0aGlzLmNvbnZleENvbnZleCh0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixlLHMsaSxvLG4scixhLHQsZSxjKX0sdHMucHJvdG90eXBlW2MudHlwZXMuQk9YfGMudHlwZXMuUEFSVElDTEVdPXRzLnByb3RvdHlwZS5ib3hQYXJ0aWNsZT1mdW5jdGlvbih0LGUscyxpLG8sbixyLGEsbCxoLGMpe3JldHVybiB0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbD10Lm1hdGVyaWFsLHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlPXQuY29sbGlzaW9uUmVzcG9uc2UsdGhpcy5jb252ZXhQYXJ0aWNsZSh0LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixlLHMsaSxvLG4scixhLHQsZSxjKX0sdHMucHJvdG90eXBlW2MudHlwZXMuU1BIRVJFXT10cy5wcm90b3R5cGUuc3BoZXJlU3BoZXJlPWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7aWYoYylyZXR1cm4gcy5kaXN0YW5jZVNxdWFyZWQoaSk8KHQucmFkaXVzK2UucmFkaXVzKSoqMjtjb25zdCB1PXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTtpLnZzdWIocyx1Lm5pKSx1Lm5pLm5vcm1hbGl6ZSgpLHUucmkuY29weSh1Lm5pKSx1LnJqLmNvcHkodS5uaSksdS5yaS5tdWx0KHQucmFkaXVzLHUucmkpLHUucmoubXVsdCgtZS5yYWRpdXMsdS5yaiksdS5yaS52YWRkKHMsdS5yaSksdS5yaS52c3ViKHIucG9zaXRpb24sdS5yaSksdS5yai52YWRkKGksdS5yaiksdS5yai52c3ViKGEucG9zaXRpb24sdS5yaiksdGhpcy5yZXN1bHQucHVzaCh1KSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QodSx0aGlzLmZyaWN0aW9uUmVzdWx0KX07Y29uc3QgbHM9bmV3IGksaHM9bmV3IGksY3M9bmV3IGk7dHMucHJvdG90eXBlW2MudHlwZXMuUExBTkV8Yy50eXBlcy5UUklNRVNIXT10cy5wcm90b3R5cGUucGxhbmVUcmltZXNoPWZ1bmN0aW9uKHQsZSxzLG8sbixyLGEsbCxoLGMsdSl7Y29uc3QgZD1uZXcgaSxwPWxzO3Auc2V0KDAsMCwxKSxuLnZtdWx0KHAscCk7Zm9yKGxldCBuPTA7bjxlLnZlcnRpY2VzLmxlbmd0aC8zO24rKyl7ZS5nZXRWZXJ0ZXgobixkKTtjb25zdCB5PW5ldyBpO3kuY29weShkKSxtLnBvaW50VG9Xb3JsZEZyYW1lKG8scix5LGQpO2NvbnN0IHY9aHM7aWYoZC52c3ViKHMsdikscC5kb3Qodik8PTApe2lmKHUpcmV0dXJuITA7Y29uc3Qgcz10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihhLGwsdCxlLGgsYyk7cy5uaS5jb3B5KHApO2NvbnN0IGk9Y3M7cC5zY2FsZSh2LmRvdChwKSxpKSxkLnZzdWIoaSxpKSxzLnJpLmNvcHkoaSkscy5yaS52c3ViKGEucG9zaXRpb24scy5yaSkscy5yai5jb3B5KGQpLHMucmoudnN1YihsLnBvc2l0aW9uLHMucmopLHRoaXMucmVzdWx0LnB1c2gocyksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHMsdGhpcy5mcmljdGlvblJlc3VsdCl9fX07Y29uc3QgdXM9bmV3IGksZHM9bmV3IGkscHM9bmV3IGkseXM9bmV3IGksbXM9bmV3IGksdnM9bmV3IGksZnM9bmV3IGksd3M9bmV3IGkseHM9bmV3IGksZ3M9bmV3IGksYnM9bmV3IGksQXM9bmV3IGksQnM9bmV3IGksRXM9bmV3IG4senM9W107dHMucHJvdG90eXBlW2MudHlwZXMuU1BIRVJFfGMudHlwZXMuVFJJTUVTSF09dHMucHJvdG90eXBlLnNwaGVyZVRyaW1lc2g9ZnVuY3Rpb24odCxlLHMsaSxvLG4scixhLGwsaCxjKXtjb25zdCB1PW1zLGQ9dnMscD1mcyx5PXdzLHY9eHMsZj1ncyx3PUVzLHg9eXMsZz1kcyxiPXpzO20ucG9pbnRUb0xvY2FsRnJhbWUoaSxuLHMsdik7Y29uc3QgQT10LnJhZGl1czt3Lmxvd2VyQm91bmQuc2V0KHYueC1BLHYueS1BLHYuei1BKSx3LnVwcGVyQm91bmQuc2V0KHYueCtBLHYueStBLHYueitBKSxlLmdldFRyaWFuZ2xlc0luQUFCQih3LGIpO2NvbnN0IEI9cHMsRT10LnJhZGl1cyp0LnJhZGl1cztmb3IobGV0IG89MDtvPGIubGVuZ3RoO28rKylmb3IobGV0IHU9MDt1PDM7dSsrKWlmKGUuZ2V0VmVydGV4KGUuaW5kaWNlc1szKmJbb10rdV0sQiksQi52c3ViKHYsZyksZy5ub3JtMigpPD1FKXtpZih4LmNvcHkoQiksbS5wb2ludFRvV29ybGRGcmFtZShpLG4seCxCKSxCLnZzdWIocyxnKSxjKXJldHVybiEwO2xldCBvPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTtvLm5pLmNvcHkoZyksby5uaS5ub3JtYWxpemUoKSxvLnJpLmNvcHkoby5uaSksby5yaS5zY2FsZSh0LnJhZGl1cyxvLnJpKSxvLnJpLnZhZGQocyxvLnJpKSxvLnJpLnZzdWIoci5wb3NpdGlvbixvLnJpKSxvLnJqLmNvcHkoQiksby5yai52c3ViKGEucG9zaXRpb24sby5yaiksdGhpcy5yZXN1bHQucHVzaChvKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qobyx0aGlzLmZyaWN0aW9uUmVzdWx0KX1mb3IobGV0IG89MDtvPGIubGVuZ3RoO28rKylmb3IobGV0IHc9MDt3PDM7dysrKXtlLmdldFZlcnRleChlLmluZGljZXNbMypiW29dK3ddLHUpLGUuZ2V0VmVydGV4KGUuaW5kaWNlc1szKmJbb10rKHcrMSklM10sZCksZC52c3ViKHUscCksdi52c3ViKGQsZik7Y29uc3QgeD1mLmRvdChwKTt2LnZzdWIodSxmKTtsZXQgZz1mLmRvdChwKTtpZihnPjAmJng8MClpZih2LnZzdWIodSxmKSx5LmNvcHkocCkseS5ub3JtYWxpemUoKSxnPWYuZG90KHkpLHkuc2NhbGUoZyxmKSxmLnZhZGQodSxmKSwocT1mLmRpc3RhbmNlVG8odikpPHQucmFkaXVzKXtpZihjKXJldHVybiEwO3ZhciB6PXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTtmLnZzdWIodix6Lm5pKSx6Lm5pLm5vcm1hbGl6ZSgpLHoubmkuc2NhbGUodC5yYWRpdXMsei5yaSksei5yaS52YWRkKHMsei5yaSksei5yaS52c3ViKHIucG9zaXRpb24sei5yaSksbS5wb2ludFRvV29ybGRGcmFtZShpLG4sZixmKSxmLnZzdWIoYS5wb3NpdGlvbix6LnJqKSxtLnZlY3RvclRvV29ybGRGcmFtZShuLHoubmksei5uaSksbS52ZWN0b3JUb1dvcmxkRnJhbWUobix6LnJpLHoucmkpLHRoaXMucmVzdWx0LnB1c2goeiksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHosdGhpcy5mcmljdGlvblJlc3VsdCl9fWNvbnN0IFM9YnMsRj1BcyxNPUJzLEM9dXM7Zm9yKGxldCBvPTAsdT1iLmxlbmd0aDtvIT09dTtvKyspe2UuZ2V0VHJpYW5nbGVWZXJ0aWNlcyhiW29dLFMsRixNKSxlLmdldE5vcm1hbChiW29dLEMpLHYudnN1YihTLGYpO3ZhciBxPWYuZG90KEMpO2lmKEMuc2NhbGUocSxmKSx2LnZzdWIoZixmKSxxPWYuZGlzdGFuY2VUbyh2KSxHLnBvaW50SW5UcmlhbmdsZShmLFMsRixNKSYmcTx0LnJhZGl1cyl7aWYoYylyZXR1cm4hMDtsZXQgbz10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7Zi52c3ViKHYsby5uaSksby5uaS5ub3JtYWxpemUoKSxvLm5pLnNjYWxlKHQucmFkaXVzLG8ucmkpLG8ucmkudmFkZChzLG8ucmkpLG8ucmkudnN1YihyLnBvc2l0aW9uLG8ucmkpLG0ucG9pbnRUb1dvcmxkRnJhbWUoaSxuLGYsZiksZi52c3ViKGEucG9zaXRpb24sby5yaiksbS52ZWN0b3JUb1dvcmxkRnJhbWUobixvLm5pLG8ubmkpLG0udmVjdG9yVG9Xb3JsZEZyYW1lKG4sby5yaSxvLnJpKSx0aGlzLnJlc3VsdC5wdXNoKG8pLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChvLHRoaXMuZnJpY3Rpb25SZXN1bHQpfX1iLmxlbmd0aD0wfTtjb25zdCBTcz1uZXcgaSxGcz1uZXcgaTt0cy5wcm90b3R5cGVbYy50eXBlcy5TUEhFUkV8Yy50eXBlcy5QTEFORV09dHMucHJvdG90eXBlLnNwaGVyZVBsYW5lPWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7aWYodS5uaS5zZXQoMCwwLDEpLG4udm11bHQodS5uaSx1Lm5pKSx1Lm5pLm5lZ2F0ZSh1Lm5pKSx1Lm5pLm5vcm1hbGl6ZSgpLHUubmkubXVsdCh0LnJhZGl1cyx1LnJpKSxzLnZzdWIoaSxTcyksdS5uaS5tdWx0KHUubmkuZG90KFNzKSxGcyksU3MudnN1YihGcyx1LnJqKSwtU3MuZG90KHUubmkpPD10LnJhZGl1cyl7aWYoYylyZXR1cm4hMDtjb25zdCB0PXUucmksZT11LnJqO3QudmFkZChzLHQpLHQudnN1YihyLnBvc2l0aW9uLHQpLGUudmFkZChpLGUpLGUudnN1YihhLnBvc2l0aW9uLGUpLHRoaXMucmVzdWx0LnB1c2godSksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHUsdGhpcy5mcmljdGlvblJlc3VsdCl9fTtjb25zdCBNcz1uZXcgaSxDcz1uZXcgaSxxcz1uZXcgaTtmdW5jdGlvbiBUcyh0LGUscyl7bGV0IGk9bnVsbDtjb25zdCBvPXQubGVuZ3RoO2ZvcihsZXQgbj0wO24hPT1vO24rKyl7Y29uc3Qgcj10W25dLGE9TXM7dFsobisxKSVvXS52c3ViKHIsYSk7Y29uc3QgbD1DczthLmNyb3NzKGUsbCk7Y29uc3QgaD1xcztzLnZzdWIocixoKTtjb25zdCBjPWwuZG90KGgpO2lmKCEobnVsbD09PWl8fGM+MCYmITA9PT1pfHxjPD0wJiYhMT09PWkpKXJldHVybiExO251bGw9PT1pJiYoaT1jPjApfXJldHVybiEwfWNvbnN0IE5zPW5ldyBpLFBzPW5ldyBpLFJzPW5ldyBpLElzPW5ldyBpLExzPVtuZXcgaSxuZXcgaSxuZXcgaSxuZXcgaSxuZXcgaSxuZXcgaV0sanM9bmV3IGksVnM9bmV3IGksa3M9bmV3IGksV3M9bmV3IGk7dHMucHJvdG90eXBlW2MudHlwZXMuU1BIRVJFfGMudHlwZXMuQk9YXT10cy5wcm90b3R5cGUuc3BoZXJlQm94PWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT10aGlzLnYzcG9vbCxkPUxzO3MudnN1YihpLE5zKSxlLmdldFNpZGVOb3JtYWxzKGQsbik7Y29uc3QgcD10LnJhZGl1cztsZXQgeT0hMTtjb25zdCBtPVZzLHY9a3MsZj1XcztsZXQgdz1udWxsLHg9MCxnPTAsYj0wLEE9bnVsbDtmb3IobGV0IHQ9MCxlPWQubGVuZ3RoO3QhPT1lJiYhMT09PXk7dCsrKXtjb25zdCBlPVBzO2UuY29weShkW3RdKTtjb25zdCBzPWUubm9ybSgpO2Uubm9ybWFsaXplKCk7Y29uc3QgaT1Ocy5kb3QoZSk7aWYoaTxzK3AmJmk+MCl7Y29uc3Qgbz1ScyxuPUlzO28uY29weShkWyh0KzEpJTNdKSxuLmNvcHkoZFsodCsyKSUzXSk7Y29uc3Qgcj1vLm5vcm0oKSxhPW4ubm9ybSgpO28ubm9ybWFsaXplKCksbi5ub3JtYWxpemUoKTtjb25zdCBsPU5zLmRvdChvKSxoPU5zLmRvdChuKTtpZihsPHImJmw+LXImJmg8YSYmaD4tYSl7dmFyIEI9TWF0aC5hYnMoaS1zLXApO2lmKChudWxsPT09QXx8QjxBKSYmKEE9QixnPWwsYj1oLHc9cyxtLmNvcHkoZSksdi5jb3B5KG8pLGYuY29weShuKSx4KyssYykpcmV0dXJuITB9fX1pZih4KXt5PSEwO3ZhciBFPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTttLm11bHQoLXAsRS5yaSksRS5uaS5jb3B5KG0pLEUubmkubmVnYXRlKEUubmkpLG0ubXVsdCh3LG0pLHYubXVsdChnLHYpLG0udmFkZCh2LG0pLGYubXVsdChiLGYpLG0udmFkZChmLEUucmopLEUucmkudmFkZChzLEUucmkpLEUucmkudnN1YihyLnBvc2l0aW9uLEUucmkpLEUucmoudmFkZChpLEUucmopLEUucmoudnN1YihhLnBvc2l0aW9uLEUucmopLHRoaXMucmVzdWx0LnB1c2goRSksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KEUsdGhpcy5mcmljdGlvblJlc3VsdCl9bGV0IHo9dS5nZXQoKTtjb25zdCBTPWpzO2ZvcihsZXQgbz0wOzIhPT1vJiYheTtvKyspZm9yKGxldCBuPTA7MiE9PW4mJiF5O24rKylmb3IobGV0IHU9MDsyIT09dSYmIXk7dSsrKWlmKHouc2V0KDAsMCwwKSxvP3oudmFkZChkWzBdLHopOnoudnN1YihkWzBdLHopLG4/ei52YWRkKGRbMV0seik6ei52c3ViKGRbMV0seiksdT96LnZhZGQoZFsyXSx6KTp6LnZzdWIoZFsyXSx6KSxpLnZhZGQoeixTKSxTLnZzdWIocyxTKSxTLm5vcm0yKCk8cCpwKXtpZihjKXJldHVybiEwO3k9ITAsKEU9dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpKS5yaS5jb3B5KFMpLEUucmkubm9ybWFsaXplKCksRS5uaS5jb3B5KEUucmkpLEUucmkubXVsdChwLEUucmkpLEUucmouY29weSh6KSxFLnJpLnZhZGQocyxFLnJpKSxFLnJpLnZzdWIoci5wb3NpdGlvbixFLnJpKSxFLnJqLnZhZGQoaSxFLnJqKSxFLnJqLnZzdWIoYS5wb3NpdGlvbixFLnJqKSx0aGlzLnJlc3VsdC5wdXNoKEUpLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChFLHRoaXMuZnJpY3Rpb25SZXN1bHQpfXUucmVsZWFzZSh6KSx6PW51bGw7Y29uc3QgRj11LmdldCgpLE09dS5nZXQoKTtFPXUuZ2V0KCk7Y29uc3QgQz11LmdldCgpO0I9dS5nZXQoKTtjb25zdCBxPWQubGVuZ3RoO2ZvcihsZXQgbz0wO28hPT1xJiYheTtvKyspZm9yKGxldCBuPTA7biE9PXEmJiF5O24rKylpZihvJTMhPW4lMyl7ZFtuXS5jcm9zcyhkW29dLEYpLEYubm9ybWFsaXplKCksZFtvXS52YWRkKGRbbl0sTSksRS5jb3B5KHMpLEUudnN1YihNLEUpLEUudnN1YihpLEUpO2NvbnN0IHU9RS5kb3QoRik7Ri5tdWx0KHUsQyk7bGV0IG09MDtmb3IoO209PT1vJTN8fG09PT1uJTM7KW0rKztCLmNvcHkocyksQi52c3ViKEMsQiksQi52c3ViKE0sQiksQi52c3ViKGksQik7Y29uc3Qgdj1NYXRoLmFicyh1KSxmPUIubm9ybSgpO2lmKHY8ZFttXS5ub3JtKCkmJmY8cCl7aWYoYylyZXR1cm4hMDt5PSEwO2NvbnN0IG89dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpO00udmFkZChDLG8ucmopLG8ucmouY29weShvLnJqKSxCLm5lZ2F0ZShvLm5pKSxvLm5pLm5vcm1hbGl6ZSgpLG8ucmkuY29weShvLnJqKSxvLnJpLnZhZGQoaSxvLnJpKSxvLnJpLnZzdWIocyxvLnJpKSxvLnJpLm5vcm1hbGl6ZSgpLG8ucmkubXVsdChwLG8ucmkpLG8ucmkudmFkZChzLG8ucmkpLG8ucmkudnN1YihyLnBvc2l0aW9uLG8ucmkpLG8ucmoudmFkZChpLG8ucmopLG8ucmoudnN1YihhLnBvc2l0aW9uLG8ucmopLHRoaXMucmVzdWx0LnB1c2gobyksdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KG8sdGhpcy5mcmljdGlvblJlc3VsdCl9fXUucmVsZWFzZShGLE0sRSxDLEIpfTtjb25zdCBPcz1uZXcgaSxfcz1uZXcgaSxIcz1uZXcgaSxVcz1uZXcgaSxEcz1uZXcgaSxHcz1uZXcgaSxYcz1uZXcgaSxZcz1uZXcgaSxacz1uZXcgaSxLcz1uZXcgaTt0cy5wcm90b3R5cGVbYy50eXBlcy5TUEhFUkV8Yy50eXBlcy5DT05WRVhQT0xZSEVEUk9OXT10cy5wcm90b3R5cGUuc3BoZXJlQ29udmV4PWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT10aGlzLnYzcG9vbDtzLnZzdWIoaSxPcyk7Y29uc3QgZD1lLmZhY2VOb3JtYWxzLHA9ZS5mYWNlcyx5PWUudmVydGljZXMsbT10LnJhZGl1cztmb3IobGV0IG89MDtvIT09eS5sZW5ndGg7bysrKXtjb25zdCB1PXlbb10sZD1EcztuLnZtdWx0KHUsZCksaS52YWRkKGQsZCk7Y29uc3QgcD1VcztpZihkLnZzdWIocyxwKSxwLm5vcm0yKCk8bSptKXJldHVybiEhY3x8KHY9ITAsKGY9dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocixhLHQsZSxsLGgpKS5yaS5jb3B5KHApLGYucmkubm9ybWFsaXplKCksZi5uaS5jb3B5KGYucmkpLGYucmkubXVsdChtLGYucmkpLGQudnN1YihpLGYucmopLGYucmkudmFkZChzLGYucmkpLGYucmkudnN1YihyLnBvc2l0aW9uLGYucmkpLGYucmoudmFkZChpLGYucmopLGYucmoudnN1YihhLnBvc2l0aW9uLGYucmopLHRoaXMucmVzdWx0LnB1c2goZiksdm9pZCB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoZix0aGlzLmZyaWN0aW9uUmVzdWx0KSl9dmFyIHY9ITE7Zm9yKGxldCBvPTAsdz1wLmxlbmd0aDtvIT09dyYmITE9PT12O28rKyl7Y29uc3Qgdz1kW29dLHg9cFtvXSxnPUdzO24udm11bHQodyxnKTtjb25zdCBiPVhzO24udm11bHQoeVt4WzBdXSxiKSxiLnZhZGQoaSxiKTtjb25zdCBBPVlzO2cubXVsdCgtbSxBKSxzLnZhZGQoQSxBKTtjb25zdCBCPVpzO0EudnN1YihiLEIpO2NvbnN0IEU9Qi5kb3QoZyksej1LcztpZihzLnZzdWIoYix6KSxFPDAmJnouZG90KGcpPjApe2NvbnN0IG89W107Zm9yKGxldCB0PTAsZT14Lmxlbmd0aDt0IT09ZTt0Kyspe2NvbnN0IGU9dS5nZXQoKTtuLnZtdWx0KHlbeFt0XV0sZSksaS52YWRkKGUsZSksby5wdXNoKGUpfWlmKFRzKG8sZyxzKSl7aWYoYylyZXR1cm4hMDt2PSEwO3ZhciBmPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKTtnLm11bHQoLW0sZi5yaSksZy5uZWdhdGUoZi5uaSk7Y29uc3Qgbj11LmdldCgpO2cubXVsdCgtRSxuKTtjb25zdCBkPXUuZ2V0KCk7Zy5tdWx0KC1tLGQpLHMudnN1YihpLGYucmopLGYucmoudmFkZChkLGYucmopLGYucmoudmFkZChuLGYucmopLGYucmoudmFkZChpLGYucmopLGYucmoudnN1YihhLnBvc2l0aW9uLGYucmopLGYucmkudmFkZChzLGYucmkpLGYucmkudnN1YihyLnBvc2l0aW9uLGYucmkpLHUucmVsZWFzZShuKSx1LnJlbGVhc2UoZCksdGhpcy5yZXN1bHQucHVzaChmKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoZix0aGlzLmZyaWN0aW9uUmVzdWx0KTtmb3IobGV0IHQ9MCxlPW8ubGVuZ3RoO3QhPT1lO3QrKyl1LnJlbGVhc2Uob1t0XSk7cmV0dXJufWZvcihsZXQgZD0wO2QhPT14Lmxlbmd0aDtkKyspe2NvbnN0IHA9dS5nZXQoKSx2PXUuZ2V0KCk7bi52bXVsdCh5W3hbKGQrMSkleC5sZW5ndGhdXSxwKSxuLnZtdWx0KHlbeFsoZCsyKSV4Lmxlbmd0aF1dLHYpLGkudmFkZChwLHApLGkudmFkZCh2LHYpO2NvbnN0IHc9X3M7di52c3ViKHAsdyk7Y29uc3QgZz1Iczt3LnVuaXQoZyk7Y29uc3QgYj11LmdldCgpLEE9dS5nZXQoKTtzLnZzdWIocCxBKTtjb25zdCBCPUEuZG90KGcpO2cubXVsdChCLGIpLGIudmFkZChwLGIpO2NvbnN0IEU9dS5nZXQoKTtpZihiLnZzdWIocyxFKSxCPjAmJkIqQjx3Lm5vcm0yKCkmJkUubm9ybTIoKTxtKm0pe2lmKGMpcmV0dXJuITA7Zj10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCk7Yi52c3ViKGksZi5yaiksYi52c3ViKHMsZi5uaSksZi5uaS5ub3JtYWxpemUoKSxmLm5pLm11bHQobSxmLnJpKSxmLnJqLnZhZGQoaSxmLnJqKSxmLnJqLnZzdWIoYS5wb3NpdGlvbixmLnJqKSxmLnJpLnZhZGQocyxmLnJpKSxmLnJpLnZzdWIoci5wb3NpdGlvbixmLnJpKSx0aGlzLnJlc3VsdC5wdXNoKGYpLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChmLHRoaXMuZnJpY3Rpb25SZXN1bHQpO2ZvcihsZXQgdD0wLGU9by5sZW5ndGg7dCE9PWU7dCsrKXUucmVsZWFzZShvW3RdKTtyZXR1cm4gdS5yZWxlYXNlKHApLHUucmVsZWFzZSh2KSx1LnJlbGVhc2UoYiksdS5yZWxlYXNlKEUpLHZvaWQgdS5yZWxlYXNlKEEpfXUucmVsZWFzZShwKSx1LnJlbGVhc2UodiksdS5yZWxlYXNlKGIpLHUucmVsZWFzZShFKSx1LnJlbGVhc2UoQSl9Zm9yKGxldCB0PTAsZT1vLmxlbmd0aDt0IT09ZTt0KyspdS5yZWxlYXNlKG9bdF0pfX19LHRzLnByb3RvdHlwZVtjLnR5cGVzLlBMQU5FfGMudHlwZXMuQk9YXT10cy5wcm90b3R5cGUucGxhbmVCb3g9ZnVuY3Rpb24odCxlLHMsaSxvLG4scixhLGwsaCxjKXtyZXR1cm4gZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWw9ZS5tYXRlcmlhbCxlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZT1lLmNvbGxpc2lvblJlc3BvbnNlLGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmlkPWUuaWQsdGhpcy5wbGFuZUNvbnZleCh0LGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHMsaSxvLG4scixhLHQsZSxjKX07Y29uc3QgUXM9bmV3IGksSnM9bmV3IGksJHM9bmV3IGksdGk9bmV3IGk7dHMucHJvdG90eXBlW2MudHlwZXMuUExBTkV8Yy50eXBlcy5DT05WRVhQT0xZSEVEUk9OXT10cy5wcm90b3R5cGUucGxhbmVDb252ZXg9ZnVuY3Rpb24odCxlLHMsaSxvLG4scixhLGwsaCxjKXtjb25zdCB1PVFzLGQ9SnM7ZC5zZXQoMCwwLDEpLG8udm11bHQoZCxkKTtsZXQgcD0wO2NvbnN0IHk9JHM7Zm9yKGxldCBvPTA7byE9PWUudmVydGljZXMubGVuZ3RoO28rKyl7aWYodS5jb3B5KGUudmVydGljZXNbb10pLG4udm11bHQodSx1KSxpLnZhZGQodSx1KSx1LnZzdWIocyx5KSxkLmRvdCh5KTw9MCl7aWYoYylyZXR1cm4hMDtjb25zdCBvPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHIsYSx0LGUsbCxoKSxuPXRpO2QubXVsdChkLmRvdCh5KSxuKSx1LnZzdWIobixuKSxuLnZzdWIocyxvLnJpKSxvLm5pLmNvcHkoZCksdS52c3ViKGksby5yaiksby5yaS52YWRkKHMsby5yaSksby5yaS52c3ViKHIucG9zaXRpb24sby5yaSksby5yai52YWRkKGksby5yaiksby5yai52c3ViKGEucG9zaXRpb24sby5yaiksdGhpcy5yZXN1bHQucHVzaChvKSxwKyssdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbnx8dGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KG8sdGhpcy5mcmljdGlvblJlc3VsdCl9fXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24mJnAmJnRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShwKX07Y29uc3QgZWk9bmV3IGksc2k9bmV3IGk7dHMucHJvdG90eXBlW2MudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl09dHMucHJvdG90eXBlLmNvbnZleENvbnZleD1mdW5jdGlvbih0LGUscyxpLG8sbixyLGEsbCxoLGMsdSxkKXtjb25zdCBwPWVpO2lmKCEocy5kaXN0YW5jZVRvKGkpPnQuYm91bmRpbmdTcGhlcmVSYWRpdXMrZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykmJnQuZmluZFNlcGFyYXRpbmdBeGlzKGUscyxvLGksbixwLHUsZCkpe2NvbnN0IHU9W10sZD1zaTt0LmNsaXBBZ2FpbnN0SHVsbChzLG8sZSxpLG4scCwtMTAwLDEwMCx1KTtsZXQgeT0wO2ZvcihsZXQgbz0wO28hPT11Lmxlbmd0aDtvKyspe2lmKGMpcmV0dXJuITA7Y29uc3Qgbj10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihyLGEsdCxlLGwsaCksbT1uLnJpLHY9bi5yajtwLm5lZ2F0ZShuLm5pKSx1W29dLm5vcm1hbC5uZWdhdGUoZCksZC5tdWx0KHVbb10uZGVwdGgsZCksdVtvXS5wb2ludC52YWRkKGQsbSksdi5jb3B5KHVbb10ucG9pbnQpLG0udnN1YihzLG0pLHYudnN1YihpLHYpLG0udmFkZChzLG0pLG0udnN1YihyLnBvc2l0aW9uLG0pLHYudmFkZChpLHYpLHYudnN1YihhLnBvc2l0aW9uLHYpLHRoaXMucmVzdWx0LnB1c2gobikseSsrLHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb258fHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChuLHRoaXMuZnJpY3Rpb25SZXN1bHQpfXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24mJnkmJnRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSh5KX19O2NvbnN0IGlpPW5ldyBpLG9pPW5ldyBpLG5pPW5ldyBpO3RzLnByb3RvdHlwZVtjLnR5cGVzLlBMQU5FfGMudHlwZXMuUEFSVElDTEVdPXRzLnByb3RvdHlwZS5wbGFuZVBhcnRpY2xlPWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7Y29uc3QgdT1paTt1LnNldCgwLDAsMSksci5xdWF0ZXJuaW9uLnZtdWx0KHUsdSk7Y29uc3QgZD1vaTtpZihpLnZzdWIoci5wb3NpdGlvbixkKSx1LmRvdChkKTw9MCl7aWYoYylyZXR1cm4hMDtjb25zdCBzPXRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGEscixlLHQsbCxoKTtzLm5pLmNvcHkodSkscy5uaS5uZWdhdGUocy5uaSkscy5yaS5zZXQoMCwwLDApO2NvbnN0IG89bmk7dS5tdWx0KHUuZG90KGkpLG8pLGkudnN1YihvLG8pLHMucmouY29weShvKSx0aGlzLnJlc3VsdC5wdXNoKHMpLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChzLHRoaXMuZnJpY3Rpb25SZXN1bHQpfX07Y29uc3Qgcmk9bmV3IGk7dHMucHJvdG90eXBlW2MudHlwZXMuUEFSVElDTEV8Yy50eXBlcy5TUEhFUkVdPXRzLnByb3RvdHlwZS5zcGhlcmVQYXJ0aWNsZT1mdW5jdGlvbih0LGUscyxpLG8sbixyLGEsbCxoLGMpe2NvbnN0IHU9cmk7aWYodS5zZXQoMCwwLDEpLGkudnN1YihzLHUpLHUubm9ybTIoKTw9dC5yYWRpdXMqdC5yYWRpdXMpe2lmKGMpcmV0dXJuITA7Y29uc3Qgcz10aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihhLHIsZSx0LGwsaCk7dS5ub3JtYWxpemUoKSxzLnJqLmNvcHkodSkscy5yai5tdWx0KHQucmFkaXVzLHMucmopLHMubmkuY29weSh1KSxzLm5pLm5lZ2F0ZShzLm5pKSxzLnJpLnNldCgwLDAsMCksdGhpcy5yZXN1bHQucHVzaChzKSx0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3Qocyx0aGlzLmZyaWN0aW9uUmVzdWx0KX19O2NvbnN0IGFpPW5ldyB1LGxpPW5ldyBpLGhpPW5ldyBpLGNpPW5ldyBpLHVpPW5ldyBpO3RzLnByb3RvdHlwZVtjLnR5cGVzLlBBUlRJQ0xFfGMudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl09dHMucHJvdG90eXBlLmNvbnZleFBhcnRpY2xlPWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7bGV0IHU9LTE7Y29uc3QgZD1oaSxwPXVpO2xldCB5PW51bGw7Y29uc3QgbT1saTtpZihtLmNvcHkoaSksbS52c3ViKHMsbSksby5jb25qdWdhdGUoYWkpLGFpLnZtdWx0KG0sbSksdC5wb2ludElzSW5zaWRlKG0pKXt0LndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSYmdC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzLG8pLHQud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlJiZ0LmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKG8pO2ZvcihsZXQgZT0wLHM9dC5mYWNlcy5sZW5ndGg7ZSE9PXM7ZSsrKXtjb25zdCBzPVt0LndvcmxkVmVydGljZXNbdC5mYWNlc1tlXVswXV1dLG89dC53b3JsZEZhY2VOb3JtYWxzW2VdO2kudnN1YihzWzBdLGNpKTtjb25zdCBuPS1vLmRvdChjaSk7aWYobnVsbD09PXl8fE1hdGguYWJzKG4pPE1hdGguYWJzKHkpKXtpZihjKXJldHVybiEwO3k9bix1PWUsZC5jb3B5KG8pfX1pZigtMSE9PXUpe2NvbnN0IG89dGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYSxyLGUsdCxsLGgpO2QubXVsdCh5LHApLHAudmFkZChpLHApLHAudnN1YihzLHApLG8ucmouY29weShwKSxkLm5lZ2F0ZShvLm5pKSxvLnJpLnNldCgwLDAsMCk7Y29uc3Qgbj1vLnJpLGM9by5yajtuLnZhZGQoaSxuKSxuLnZzdWIoYS5wb3NpdGlvbixuKSxjLnZhZGQocyxjKSxjLnZzdWIoci5wb3NpdGlvbixjKSx0aGlzLnJlc3VsdC5wdXNoKG8pLHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChvLHRoaXMuZnJpY3Rpb25SZXN1bHQpfWVsc2UgY29uc29sZS53YXJuKCJQb2ludCBmb3VuZCBpbnNpZGUgY29udmV4LCBidXQgZGlkIG5vdCBmaW5kIHBlbmV0cmF0aW5nIGZhY2UhIil9fSx0cy5wcm90b3R5cGVbYy50eXBlcy5CT1h8Yy50eXBlcy5IRUlHSFRGSUVMRF09dHMucHJvdG90eXBlLmJveEhlaWdodGZpZWxkPWZ1bmN0aW9uKHQsZSxzLGksbyxuLHIsYSxsLGgsYyl7cmV0dXJuIHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsPXQubWF0ZXJpYWwsdC5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2U9dC5jb2xsaXNpb25SZXNwb25zZSx0aGlzLmNvbnZleEhlaWdodGZpZWxkKHQuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLGUscyxpLG8sbixyLGEsdCxlLGMpfTtjb25zdCBkaT1uZXcgaSxwaT1uZXcgaSx5aT1bMF07dHMucHJvdG90eXBlW2MudHlwZXMuQ09OVkVYUE9MWUhFRFJPTnxjLnR5cGVzLkhFSUdIVEZJRUxEXT10cy5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQ9ZnVuY3Rpb24odCxlLHMsaSxvLG4scixhLGwsaCxjKXtjb25zdCB1PWUuZGF0YSxkPWUuZWxlbWVudFNpemUscD10LmJvdW5kaW5nU3BoZXJlUmFkaXVzLHk9cGksdj15aSxmPWRpO20ucG9pbnRUb0xvY2FsRnJhbWUoaSxuLHMsZik7bGV0IHc9TWF0aC5mbG9vcigoZi54LXApL2QpLTEseD1NYXRoLmNlaWwoKGYueCtwKS9kKSsxLGc9TWF0aC5mbG9vcigoZi55LXApL2QpLTEsYj1NYXRoLmNlaWwoKGYueStwKS9kKSsxO2lmKHg8MHx8YjwwfHx3PnUubGVuZ3RofHxnPnVbMF0ubGVuZ3RoKXJldHVybjt3PDAmJih3PTApLHg8MCYmKHg9MCksZzwwJiYoZz0wKSxiPDAmJihiPTApLHc+PXUubGVuZ3RoJiYodz11Lmxlbmd0aC0xKSx4Pj11Lmxlbmd0aCYmKHg9dS5sZW5ndGgtMSksYj49dVswXS5sZW5ndGgmJihiPXVbMF0ubGVuZ3RoLTEpLGc+PXVbMF0ubGVuZ3RoJiYoZz11WzBdLmxlbmd0aC0xKTtjb25zdCBBPVtdO2UuZ2V0UmVjdE1pbk1heCh3LGcseCxiLEEpO2NvbnN0IEI9QVswXSxFPUFbMV07aWYoIShmLnotcD5FfHxmLnorcDxCKSlmb3IobGV0IGw9dztsPHg7bCsrKWZvcihsZXQgaD1nO2g8YjtoKyspe2xldCB1PSExO2lmKGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIobCxoLCExKSxtLnBvaW50VG9Xb3JsZEZyYW1lKGksbixlLnBpbGxhck9mZnNldCx5KSxzLmRpc3RhbmNlVG8oeSk8ZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMrdC5ib3VuZGluZ1NwaGVyZVJhZGl1cyYmKHU9dGhpcy5jb252ZXhDb252ZXgodCxlLnBpbGxhckNvbnZleCxzLHksbyxuLHIsYSxudWxsLG51bGwsYyx2LG51bGwpKSxjJiZ1KXJldHVybiEwO2lmKGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIobCxoLCEwKSxtLnBvaW50VG9Xb3JsZEZyYW1lKGksbixlLnBpbGxhck9mZnNldCx5KSxzLmRpc3RhbmNlVG8oeSk8ZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMrdC5ib3VuZGluZ1NwaGVyZVJhZGl1cyYmKHU9dGhpcy5jb252ZXhDb252ZXgodCxlLnBpbGxhckNvbnZleCxzLHksbyxuLHIsYSxudWxsLG51bGwsYyx2LG51bGwpKSxjJiZ1KXJldHVybiEwfX07Y29uc3QgbWk9bmV3IGksdmk9bmV3IGk7dHMucHJvdG90eXBlW2MudHlwZXMuU1BIRVJFfGMudHlwZXMuSEVJR0hURklFTERdPXRzLnByb3RvdHlwZS5zcGhlcmVIZWlnaHRmaWVsZD1mdW5jdGlvbih0LGUscyxpLG8sbixyLGEsbCxoLGMpe2NvbnN0IHU9ZS5kYXRhLGQ9dC5yYWRpdXMscD1lLmVsZW1lbnRTaXplLHk9dmksdj1taTttLnBvaW50VG9Mb2NhbEZyYW1lKGksbixzLHYpO2xldCBmPU1hdGguZmxvb3IoKHYueC1kKS9wKS0xLHc9TWF0aC5jZWlsKCh2LngrZCkvcCkrMSx4PU1hdGguZmxvb3IoKHYueS1kKS9wKS0xLGc9TWF0aC5jZWlsKCh2LnkrZCkvcCkrMTtpZih3PDB8fGc8MHx8Zj51Lmxlbmd0aHx8eD51WzBdLmxlbmd0aClyZXR1cm47ZjwwJiYoZj0wKSx3PDAmJih3PTApLHg8MCYmKHg9MCksZzwwJiYoZz0wKSxmPj11Lmxlbmd0aCYmKGY9dS5sZW5ndGgtMSksdz49dS5sZW5ndGgmJih3PXUubGVuZ3RoLTEpLGc+PXVbMF0ubGVuZ3RoJiYoZz11WzBdLmxlbmd0aC0xKSx4Pj11WzBdLmxlbmd0aCYmKHg9dVswXS5sZW5ndGgtMSk7Y29uc3QgYj1bXTtlLmdldFJlY3RNaW5NYXgoZix4LHcsZyxiKTtjb25zdCBBPWJbMF0sQj1iWzFdO2lmKHYuei1kPkJ8fHYueitkPEEpcmV0dXJuO2NvbnN0IEU9dGhpcy5yZXN1bHQ7Zm9yKGxldCBsPWY7bDx3O2wrKylmb3IobGV0IGg9eDtoPGc7aCsrKXtjb25zdCB1PUUubGVuZ3RoO2xldCBkPSExO2lmKGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIobCxoLCExKSxtLnBvaW50VG9Xb3JsZEZyYW1lKGksbixlLnBpbGxhck9mZnNldCx5KSxzLmRpc3RhbmNlVG8oeSk8ZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMrdC5ib3VuZGluZ1NwaGVyZVJhZGl1cyYmKGQ9dGhpcy5zcGhlcmVDb252ZXgodCxlLnBpbGxhckNvbnZleCxzLHksbyxuLHIsYSx0LGUsYykpLGMmJmQpcmV0dXJuITA7aWYoZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihsLGgsITApLG0ucG9pbnRUb1dvcmxkRnJhbWUoaSxuLGUucGlsbGFyT2Zmc2V0LHkpLHMuZGlzdGFuY2VUbyh5KTxlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyt0LmJvdW5kaW5nU3BoZXJlUmFkaXVzJiYoZD10aGlzLnNwaGVyZUNvbnZleCh0LGUucGlsbGFyQ29udmV4LHMseSxvLG4scixhLHQsZSxjKSksYyYmZClyZXR1cm4hMDtpZihFLmxlbmd0aC11PjIpcmV0dXJufX07Y2xhc3MgZml7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnQ9W10sdGhpcy5wcmV2aW91cz1bXX1nZXRLZXkodCxlKXtpZihlPHQpe2NvbnN0IHM9ZTtlPXQsdD1zfXJldHVybiB0PDwxNnxlfXNldCh0LGUpe2NvbnN0IHM9dGhpcy5nZXRLZXkodCxlKSxpPXRoaXMuY3VycmVudDtsZXQgbz0wO2Zvcig7cz5pW29dOylvKys7aWYocyE9PWlbb10pe2ZvcihlPWkubGVuZ3RoLTE7ZT49bztlLS0paVtlKzFdPWlbZV07aVtvXT1zfX10aWNrKCl7Y29uc3QgdD10aGlzLmN1cnJlbnQ7dGhpcy5jdXJyZW50PXRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91cz10LHRoaXMuY3VycmVudC5sZW5ndGg9MH1nZXREaWZmKHQsZSl7Y29uc3Qgcz10aGlzLmN1cnJlbnQsaT10aGlzLnByZXZpb3VzLG89cy5sZW5ndGgsbj1pLmxlbmd0aDtsZXQgcj0wO2Zvcih2YXIgYT0wO2E8bzthKyspe2NvbnN0IGU9c1thXTtmb3IoO2U+aVtyXTspcisrO2U9PT1pW3JdfHx3aSh0LGUpfXI9MDtmb3IoYT0wO2E8bjthKyspe2NvbnN0IHQ9aVthXTtmb3IoO3Q+c1tyXTspcisrO3Nbcl09PT10fHx3aShlLHQpfX19ZnVuY3Rpb24gd2kodCxlKXt0LnB1c2goKDQyOTQ5MDE3NjAmZSk+PjE2LDY1NTM1JmUpfWNsYXNzIHhpe2NvbnN0cnVjdG9yKCl7dGhpcy5kYXRhPXtrZXlzOltdfX1nZXQodCxlKXtpZih0PmUpe2NvbnN0IHM9ZTtlPXQsdD1zfXJldHVybiB0aGlzLmRhdGFbdCsiLSIrZV19c2V0KHQsZSxzKXtpZih0PmUpe2NvbnN0IHM9ZTtlPXQsdD1zfWNvbnN0IGk9dCsiLSIrZTt0aGlzLmdldCh0LGUpfHx0aGlzLmRhdGEua2V5cy5wdXNoKGkpLHRoaXMuZGF0YVtpXT1zfXJlc2V0KCl7Y29uc3QgdD10aGlzLmRhdGEsZT10LmtleXM7Zm9yKDtlLmxlbmd0aD4wOyl7ZGVsZXRlIHRbZS5wb3AoKV19fX1jbGFzcyBnaSBleHRlbmRzIGh7Y29uc3RydWN0b3IodD17fSl7c3VwZXIoKSx0aGlzLmR0PS0xLHRoaXMuYWxsb3dTbGVlcD0hIXQuYWxsb3dTbGVlcCx0aGlzLmNvbnRhY3RzPVtdLHRoaXMuZnJpY3Rpb25FcXVhdGlvbnM9W10sdGhpcy5xdWF0Tm9ybWFsaXplU2tpcD12b2lkIDAhPT10LnF1YXROb3JtYWxpemVTa2lwP3QucXVhdE5vcm1hbGl6ZVNraXA6MCx0aGlzLnF1YXROb3JtYWxpemVGYXN0PXZvaWQgMCE9PXQucXVhdE5vcm1hbGl6ZUZhc3QmJnQucXVhdE5vcm1hbGl6ZUZhc3QsdGhpcy50aW1lPTAsdGhpcy5zdGVwbnVtYmVyPTAsdGhpcy5kZWZhdWx0X2R0PTEvNjAsdGhpcy5uZXh0SWQ9MCx0aGlzLmdyYXZpdHk9bmV3IGksdC5ncmF2aXR5JiZ0aGlzLmdyYXZpdHkuY29weSh0LmdyYXZpdHkpLHRoaXMuYnJvYWRwaGFzZT12b2lkIDAhPT10LmJyb2FkcGhhc2U/dC5icm9hZHBoYXNlOm5ldyBVLHRoaXMuYm9kaWVzPVtdLHRoaXMuc29sdmVyPXZvaWQgMCE9PXQuc29sdmVyP3Quc29sdmVyOm5ldyBaZSx0aGlzLmNvbnN0cmFpbnRzPVtdLHRoaXMubmFycm93cGhhc2U9bmV3IHRzKHRoaXMpLHRoaXMuY29sbGlzaW9uTWF0cml4PW5ldyBsLHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXM9bmV3IGwsdGhpcy5ib2R5T3ZlcmxhcEtlZXBlcj1uZXcgZmksdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXI9bmV3IGZpLHRoaXMubWF0ZXJpYWxzPVtdLHRoaXMuY29udGFjdG1hdGVyaWFscz1bXSx0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlPW5ldyB4aSx0aGlzLmRlZmF1bHRNYXRlcmlhbD1uZXcgeSgiZGVmYXVsdCIpLHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbD1uZXcgb2UodGhpcy5kZWZhdWx0TWF0ZXJpYWwsdGhpcy5kZWZhdWx0TWF0ZXJpYWwse2ZyaWN0aW9uOi4zLHJlc3RpdHV0aW9uOjB9KSx0aGlzLmRvUHJvZmlsaW5nPSExLHRoaXMucHJvZmlsZT17c29sdmU6MCxtYWtlQ29udGFjdENvbnN0cmFpbnRzOjAsYnJvYWRwaGFzZTowLGludGVncmF0ZTowLG5hcnJvd3BoYXNlOjB9LHRoaXMuYWNjdW11bGF0b3I9MCx0aGlzLnN1YnN5c3RlbXM9W10sdGhpcy5hZGRCb2R5RXZlbnQ9e3R5cGU6ImFkZEJvZHkiLGJvZHk6bnVsbH0sdGhpcy5yZW1vdmVCb2R5RXZlbnQ9e3R5cGU6InJlbW92ZUJvZHkiLGJvZHk6bnVsbH0sdGhpcy5pZFRvQm9keU1hcD17fSx0aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQodGhpcyl9Z2V0Q29udGFjdE1hdGVyaWFsKHQsZSl7cmV0dXJuIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuZ2V0KHQuaWQsZS5pZCl9bnVtT2JqZWN0cygpe3JldHVybiB0aGlzLmJvZGllcy5sZW5ndGh9Y29sbGlzaW9uTWF0cml4VGljaygpe2NvbnN0IHQ9dGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91czt0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzPXRoaXMuY29sbGlzaW9uTWF0cml4LHRoaXMuY29sbGlzaW9uTWF0cml4PXQsdGhpcy5jb2xsaXNpb25NYXRyaXgucmVzZXQoKSx0aGlzLmJvZHlPdmVybGFwS2VlcGVyLnRpY2soKSx0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci50aWNrKCl9YWRkQ29uc3RyYWludCh0KXt0aGlzLmNvbnN0cmFpbnRzLnB1c2godCl9cmVtb3ZlQ29uc3RyYWludCh0KXtjb25zdCBlPXRoaXMuY29uc3RyYWludHMuaW5kZXhPZih0KTstMSE9PWUmJnRoaXMuY29uc3RyYWludHMuc3BsaWNlKGUsMSl9cmF5VGVzdCh0LGUscyl7cyBpbnN0YW5jZW9mIEQ/dGhpcy5yYXljYXN0Q2xvc2VzdCh0LGUse3NraXBCYWNrZmFjZXM6ITB9LHMpOnRoaXMucmF5Y2FzdEFsbCh0LGUse3NraXBCYWNrZmFjZXM6ITB9LHMpfXJheWNhc3RBbGwodCxlLHMsaSl7cmV0dXJuIHMubW9kZT1HLkFMTCxzLmZyb209dCxzLnRvPWUscy5jYWxsYmFjaz1pLGJpLmludGVyc2VjdFdvcmxkKHRoaXMscyl9cmF5Y2FzdEFueSh0LGUscyxpKXtyZXR1cm4gcy5tb2RlPUcuQU5ZLHMuZnJvbT10LHMudG89ZSxzLnJlc3VsdD1pLGJpLmludGVyc2VjdFdvcmxkKHRoaXMscyl9cmF5Y2FzdENsb3Nlc3QodCxlLHMsaSl7cmV0dXJuIHMubW9kZT1HLkNMT1NFU1Qscy5mcm9tPXQscy50bz1lLHMucmVzdWx0PWksYmkuaW50ZXJzZWN0V29ybGQodGhpcyxzKX1yZW1vdmUodCl7dC53b3JsZD1udWxsO2NvbnN0IGU9dGhpcy5ib2RpZXMubGVuZ3RoLTEscz10aGlzLmJvZGllcyxpPXMuaW5kZXhPZih0KTtpZigtMSE9PWkpe3Muc3BsaWNlKGksMSk7Zm9yKGxldCB0PTA7dCE9PXMubGVuZ3RoO3QrKylzW3RdLmluZGV4PXQ7dGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhlKSx0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5PXQsZGVsZXRlIHRoaXMuaWRUb0JvZHlNYXBbdC5pZF0sdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMucmVtb3ZlQm9keUV2ZW50KX19Z2V0Qm9keUJ5SWQodCl7cmV0dXJuIHRoaXMuaWRUb0JvZHlNYXBbdF19Z2V0U2hhcGVCeUlkKHQpe2NvbnN0IGU9dGhpcy5ib2RpZXM7Zm9yKGxldCBzPTAsaT1lLmxlbmd0aDtzPGk7cysrKXtjb25zdCBpPWVbc10uc2hhcGVzO2ZvcihsZXQgZT0wLHM9aS5sZW5ndGg7ZTxzO2UrKyl7Y29uc3Qgcz1pW2VdO2lmKHMuaWQ9PT10KXJldHVybiBzfX19YWRkTWF0ZXJpYWwodCl7dGhpcy5tYXRlcmlhbHMucHVzaCh0KX1hZGRDb250YWN0TWF0ZXJpYWwodCl7dGhpcy5jb250YWN0bWF0ZXJpYWxzLnB1c2godCksdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5zZXQodC5tYXRlcmlhbHNbMF0uaWQsdC5tYXRlcmlhbHNbMV0uaWQsdCl9c3RlcCh0LGU9MCxzPTEwKXtpZigwPT09ZSl0aGlzLmludGVybmFsU3RlcCh0KSx0aGlzLnRpbWUrPXQ7ZWxzZXt0aGlzLmFjY3VtdWxhdG9yKz1lO2xldCBpPTA7Zm9yKDt0aGlzLmFjY3VtdWxhdG9yPj10JiZpPHM7KXRoaXMuaW50ZXJuYWxTdGVwKHQpLHRoaXMuYWNjdW11bGF0b3ItPXQsaSsrO2NvbnN0IG89dGhpcy5hY2N1bXVsYXRvciV0L3Q7Zm9yKGxldCB0PTA7dCE9PXRoaXMuYm9kaWVzLmxlbmd0aDt0Kyspe2NvbnN0IGU9dGhpcy5ib2RpZXNbdF07ZS5wcmV2aW91c1Bvc2l0aW9uLmxlcnAoZS5wb3NpdGlvbixvLGUuaW50ZXJwb2xhdGVkUG9zaXRpb24pLGUucHJldmlvdXNRdWF0ZXJuaW9uLnNsZXJwKGUucXVhdGVybmlvbixvLGUuaW50ZXJwb2xhdGVkUXVhdGVybmlvbiksZS5wcmV2aW91c1F1YXRlcm5pb24ubm9ybWFsaXplKCl9dGhpcy50aW1lKz1lfX1pbnRlcm5hbFN0ZXAodCl7dGhpcy5kdD10O2NvbnN0IGU9dGhpcy5jb250YWN0cyxzPUZpLGk9TWksbz10aGlzLm51bU9iamVjdHMoKSxuPXRoaXMuYm9kaWVzLHI9dGhpcy5zb2x2ZXIsYT10aGlzLmdyYXZpdHksbD10aGlzLmRvUHJvZmlsaW5nLGg9dGhpcy5wcm9maWxlLGM9Qi5EWU5BTUlDO2xldCB1O2NvbnN0IGQ9dGhpcy5jb25zdHJhaW50cyxwPVNpLHk9KGEubm9ybSgpLGEueCksbT1hLnksdj1hLno7dmFyIGY9MDtmb3IobCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpLGY9MDtmIT09bztmKyspe2lmKCh6PW5bZl0pLnR5cGU9PT1jKXtjb25zdCB0PXouZm9yY2UsZT16Lm1hc3M7dC54Kz1lKnksdC55Kz1lKm0sdC56Kz1lKnZ9fWZvcihsZXQgdD0wLGU9dGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDt0IT09ZTt0KyspdGhpcy5zdWJzeXN0ZW1zW3RdLnVwZGF0ZSgpO2wmJih1PXBlcmZvcm1hbmNlLm5vdygpKSxzLmxlbmd0aD0wLGkubGVuZ3RoPTAsdGhpcy5icm9hZHBoYXNlLmNvbGxpc2lvblBhaXJzKHRoaXMscyxpKSxsJiYoaC5icm9hZHBoYXNlPXBlcmZvcm1hbmNlLm5vdygpLXUpO3ZhciB3PWQubGVuZ3RoO2ZvcihmPTA7ZiE9PXc7ZisrKXtpZighKFM9ZFtmXSkuY29sbGlkZUNvbm5lY3RlZClmb3IodmFyIHg9cy5sZW5ndGgtMTt4Pj0wO3gtPTEpKFMuYm9keUE9PT1zW3hdJiZTLmJvZHlCPT09aVt4XXx8Uy5ib2R5Qj09PXNbeF0mJlMuYm9keUE9PT1pW3hdKSYmKHMuc3BsaWNlKHgsMSksaS5zcGxpY2UoeCwxKSl9dGhpcy5jb2xsaXNpb25NYXRyaXhUaWNrKCksbCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpO2NvbnN0IGc9emksYj1lLmxlbmd0aDtmb3IoZj0wO2YhPT1iO2YrKylnLnB1c2goZVtmXSk7ZS5sZW5ndGg9MDtjb25zdCBBPXRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO2ZvcihmPTA7ZiE9PUE7ZisrKXAucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ZdKTt0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aD0wLHRoaXMubmFycm93cGhhc2UuZ2V0Q29udGFjdHMocyxpLHRoaXMsZSxnLHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMscCksbCYmKGgubmFycm93cGhhc2U9cGVyZm9ybWFuY2Uubm93KCktdSksbCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpO2ZvcihmPTA7Zjx0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDtmKyspci5hZGRFcXVhdGlvbih0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ZdKTtjb25zdCBFPWUubGVuZ3RoO2ZvcihsZXQgdD0wO3QhPT1FO3QrKyl7dmFyIHo9KFM9ZVt0XSkuYmk7Y29uc3Qgcz1TLmJqLGk9Uy5zaSxvPVMuc2o7bGV0IG47bj16Lm1hdGVyaWFsJiZzLm1hdGVyaWFsJiZ0aGlzLmdldENvbnRhY3RNYXRlcmlhbCh6Lm1hdGVyaWFsLHMubWF0ZXJpYWwpfHx0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7bGV0IGE9bi5mcmljdGlvbjtpZih6Lm1hdGVyaWFsJiZzLm1hdGVyaWFsJiYoei5tYXRlcmlhbC5mcmljdGlvbj49MCYmcy5tYXRlcmlhbC5mcmljdGlvbj49MCYmKGE9ei5tYXRlcmlhbC5mcmljdGlvbipzLm1hdGVyaWFsLmZyaWN0aW9uKSx6Lm1hdGVyaWFsLnJlc3RpdHV0aW9uPj0wJiZzLm1hdGVyaWFsLnJlc3RpdHV0aW9uPj0wJiYoUy5yZXN0aXR1dGlvbj16Lm1hdGVyaWFsLnJlc3RpdHV0aW9uKnMubWF0ZXJpYWwucmVzdGl0dXRpb24pKSxyLmFkZEVxdWF0aW9uKFMpLHouYWxsb3dTbGVlcCYmei50eXBlPT09Qi5EWU5BTUlDJiZ6LnNsZWVwU3RhdGU9PT1CLlNMRUVQSU5HJiZzLnNsZWVwU3RhdGU9PT1CLkFXQUtFJiZzLnR5cGUhPT1CLlNUQVRJQyl7cy52ZWxvY2l0eS5ub3JtMigpK3MuYW5ndWxhclZlbG9jaXR5Lm5vcm0yKCk+PTIqcy5zbGVlcFNwZWVkTGltaXQqKjImJih6Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlPSEwKX1pZihzLmFsbG93U2xlZXAmJnMudHlwZT09PUIuRFlOQU1JQyYmcy5zbGVlcFN0YXRlPT09Qi5TTEVFUElORyYmei5zbGVlcFN0YXRlPT09Qi5BV0FLRSYmei50eXBlIT09Qi5TVEFUSUMpe3oudmVsb2NpdHkubm9ybTIoKSt6LmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpPj0yKnouc2xlZXBTcGVlZExpbWl0KioyJiYocy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZT0hMCl9dGhpcy5jb2xsaXNpb25NYXRyaXguc2V0KHoscywhMCksdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cy5nZXQoeixzKXx8KEVpLmJvZHk9cyxFaS5jb250YWN0PVMsei5kaXNwYXRjaEV2ZW50KEVpKSxFaS5ib2R5PXoscy5kaXNwYXRjaEV2ZW50KEVpKSksdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoei5pZCxzLmlkKSx0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQoaS5pZCxvLmlkKX1mb3IodGhpcy5lbWl0Q29udGFjdEV2ZW50cygpLGwmJihoLm1ha2VDb250YWN0Q29uc3RyYWludHM9cGVyZm9ybWFuY2Uubm93KCktdSx1PXBlcmZvcm1hbmNlLm5vdygpKSxmPTA7ZiE9PW87ZisrKXsoej1uW2ZdKS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSYmKHoud2FrZVVwKCksei5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZT0hMSl9dz1kLmxlbmd0aDtmb3IoZj0wO2YhPT13O2YrKyl7dmFyIFM7KFM9ZFtmXSkudXBkYXRlKCk7Zm9yKGxldCB0PTAsZT1TLmVxdWF0aW9ucy5sZW5ndGg7dCE9PWU7dCsrKXtjb25zdCBlPVMuZXF1YXRpb25zW3RdO3IuYWRkRXF1YXRpb24oZSl9fXIuc29sdmUodCx0aGlzKSxsJiYoaC5zb2x2ZT1wZXJmb3JtYW5jZS5ub3coKS11KSxyLnJlbW92ZUFsbEVxdWF0aW9ucygpO2NvbnN0IEY9TWF0aC5wb3c7Zm9yKGY9MDtmIT09bztmKyspe2lmKCh6PW5bZl0pLnR5cGUmYyl7Y29uc3QgZT1GKDEtei5saW5lYXJEYW1waW5nLHQpLHM9ei52ZWxvY2l0eTtzLm11bHQoZSxzKTtjb25zdCBpPXouYW5ndWxhclZlbG9jaXR5O2lmKGkpe2NvbnN0IGU9RigxLXouYW5ndWxhckRhbXBpbmcsdCk7aS5tdWx0KGUsaSl9fX1mb3IodGhpcy5kaXNwYXRjaEV2ZW50KEJpKSxmPTA7ZiE9PW87ZisrKXsoej1uW2ZdKS5wcmVTdGVwJiZ6LnByZVN0ZXAuY2FsbCh6KX1sJiYodT1wZXJmb3JtYW5jZS5ub3coKSk7Y29uc3QgTT10aGlzLnN0ZXBudW1iZXIlKHRoaXMucXVhdE5vcm1hbGl6ZVNraXArMSk9PTAsQz10aGlzLnF1YXROb3JtYWxpemVGYXN0O2ZvcihmPTA7ZiE9PW87ZisrKW5bZl0uaW50ZWdyYXRlKHQsTSxDKTtmb3IodGhpcy5jbGVhckZvcmNlcygpLHRoaXMuYnJvYWRwaGFzZS5kaXJ0eT0hMCxsJiYoaC5pbnRlZ3JhdGU9cGVyZm9ybWFuY2Uubm93KCktdSksdGhpcy50aW1lKz10LHRoaXMuc3RlcG51bWJlcis9MSx0aGlzLmRpc3BhdGNoRXZlbnQoQWkpLGY9MDtmIT09bztmKyspe2NvbnN0IHQ9KHo9bltmXSkucG9zdFN0ZXA7dCYmdC5jYWxsKHopfWlmKHRoaXMuYWxsb3dTbGVlcClmb3IoZj0wO2YhPT1vO2YrKyluW2ZdLnNsZWVwVGljayh0aGlzLnRpbWUpfWNsZWFyRm9yY2VzKCl7Y29uc3QgdD10aGlzLmJvZGllcyxlPXQubGVuZ3RoO2ZvcihsZXQgcz0wO3MhPT1lO3MrKyl7Y29uc3QgZT10W3NdO2UuZm9yY2UsZS50b3JxdWU7ZS5mb3JjZS5zZXQoMCwwLDApLGUudG9ycXVlLnNldCgwLDAsMCl9fX1uZXcgbjtjb25zdCBiaT1uZXcgRztpZihnaS5wcm90b3R5cGUuYWRkPWdpLnByb3RvdHlwZS5hZGRCb2R5PWZ1bmN0aW9uKHQpe3RoaXMuYm9kaWVzLmluY2x1ZGVzKHQpfHwodC5pbmRleD10aGlzLmJvZGllcy5sZW5ndGgsdGhpcy5ib2RpZXMucHVzaCh0KSx0LndvcmxkPXRoaXMsdC5pbml0UG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSx0LmluaXRWZWxvY2l0eS5jb3B5KHQudmVsb2NpdHkpLHQudGltZUxhc3RTbGVlcHk9dGhpcy50aW1lLHQgaW5zdGFuY2VvZiBCJiYodC5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkodC5hbmd1bGFyVmVsb2NpdHkpLHQuaW5pdFF1YXRlcm5pb24uY29weSh0LnF1YXRlcm5pb24pKSx0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCksdGhpcy5hZGRCb2R5RXZlbnQuYm9keT10LHRoaXMuaWRUb0JvZHlNYXBbdC5pZF09dCx0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5hZGRCb2R5RXZlbnQpKX0sZ2kucHJvdG90eXBlLnJlbW92ZUJvZHk9Z2kucHJvdG90eXBlLnJlbW92ZSwidW5kZWZpbmVkIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYocGVyZm9ybWFuY2U9e30pLCFwZXJmb3JtYW5jZS5ub3cpe2xldCB0PURhdGUubm93KCk7cGVyZm9ybWFuY2UudGltaW5nJiZwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0JiYodD1wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSxwZXJmb3JtYW5jZS5ub3c9KCk9PkRhdGUubm93KCktdH1jb25zdCBBaT17dHlwZToicG9zdFN0ZXAifSxCaT17dHlwZToicHJlU3RlcCJ9LEVpPXt0eXBlOkIuQ09MTElERV9FVkVOVF9OQU1FLGJvZHk6bnVsbCxjb250YWN0Om51bGx9LHppPVtdLFNpPVtdLEZpPVtdLE1pPVtdO2dpLnByb3RvdHlwZS5lbWl0Q29udGFjdEV2ZW50cz0oKCk9Pntjb25zdCB0PVtdLGU9W10scz17dHlwZToiYmVnaW5Db250YWN0Iixib2R5QTpudWxsLGJvZHlCOm51bGx9LGk9e3R5cGU6ImVuZENvbnRhY3QiLGJvZHlBOm51bGwsYm9keUI6bnVsbH0sbz17dHlwZToiYmVnaW5TaGFwZUNvbnRhY3QiLGJvZHlBOm51bGwsYm9keUI6bnVsbCxzaGFwZUE6bnVsbCxzaGFwZUI6bnVsbH0sbj17dHlwZToiZW5kU2hhcGVDb250YWN0Iixib2R5QTpudWxsLGJvZHlCOm51bGwsc2hhcGVBOm51bGwsc2hhcGVCOm51bGx9O3JldHVybiBmdW5jdGlvbigpe2NvbnN0IHI9dGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCJiZWdpbkNvbnRhY3QiKSxhPXRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcigiZW5kQ29udGFjdCIpO2lmKChyfHxhKSYmdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKHQsZSkscil7Zm9yKHZhciBsPTAsaD10Lmxlbmd0aDtsPGg7bCs9MilzLmJvZHlBPXRoaXMuZ2V0Qm9keUJ5SWQodFtsXSkscy5ib2R5Qj10aGlzLmdldEJvZHlCeUlkKHRbbCsxXSksdGhpcy5kaXNwYXRjaEV2ZW50KHMpO3MuYm9keUE9cy5ib2R5Qj1udWxsfWlmKGEpe2ZvcihsPTAsaD1lLmxlbmd0aDtsPGg7bCs9MilpLmJvZHlBPXRoaXMuZ2V0Qm9keUJ5SWQoZVtsXSksaS5ib2R5Qj10aGlzLmdldEJvZHlCeUlkKGVbbCsxXSksdGhpcy5kaXNwYXRjaEV2ZW50KGkpO2kuYm9keUE9aS5ib2R5Qj1udWxsfXQubGVuZ3RoPWUubGVuZ3RoPTA7Y29uc3QgYz10aGlzLmhhc0FueUV2ZW50TGlzdGVuZXIoImJlZ2luU2hhcGVDb250YWN0IiksdT10aGlzLmhhc0FueUV2ZW50TGlzdGVuZXIoImVuZFNoYXBlQ29udGFjdCIpO2lmKChjfHx1KSYmdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIuZ2V0RGlmZih0LGUpLGMpe2ZvcihsPTAsaD10Lmxlbmd0aDtsPGg7bCs9Mil7dmFyIGQ9dGhpcy5nZXRTaGFwZUJ5SWQodFtsXSkscD10aGlzLmdldFNoYXBlQnlJZCh0W2wrMV0pO28uc2hhcGVBPWQsby5zaGFwZUI9cCxvLmJvZHlBPWQuYm9keSxvLmJvZHlCPXAuYm9keSx0aGlzLmRpc3BhdGNoRXZlbnQobyl9by5ib2R5QT1vLmJvZHlCPW8uc2hhcGVBPW8uc2hhcGVCPW51bGx9aWYodSl7Zm9yKGw9MCxoPWUubGVuZ3RoO2w8aDtsKz0yKXtkPXRoaXMuZ2V0U2hhcGVCeUlkKGVbbF0pLHA9dGhpcy5nZXRTaGFwZUJ5SWQoZVtsKzFdKTtuLnNoYXBlQT1kLG4uc2hhcGVCPXAsbi5ib2R5QT1kLmJvZHksbi5ib2R5Qj1wLmJvZHksdGhpcy5kaXNwYXRjaEV2ZW50KG4pfW4uYm9keUE9bi5ib2R5Qj1uLnNoYXBlQT1uLnNoYXBlQj1udWxsfX19KSgpO2xldCBDaT17fSxxaT17fSxUaT1uZXcgZ2ksTmk9e3N0ZXA6MS82MH07Y29uc3QgUGk9e0R5bmFtaWM6Qi5EWU5BTUlDLFN0YXRpYzpCLlNUQVRJQyxLaW5lbWF0aWM6Qi5LSU5FTUFUSUN9O2Z1bmN0aW9uIFJpKCl7c2VsZi5wb3N0TWVzc2FnZSh7b3A6InN5bmMiLGJvZGllczpUaS5ib2RpZXMubWFwKHQ9PnQudXVpZCl9KSxDaT1UaS5ib2RpZXMucmVkdWNlKChlLHMpPT50KHt9LGUse1tzLnV1aWRdOnN9KSx7fSl9c2VsZi5vbm1lc3NhZ2U9cz0+e2NvbnN0e29wOm8sdXVpZDpuLHR5cGU6cixwb3NpdGlvbnM6YSxxdWF0ZXJuaW9uczpsLHByb3BzOmh9PXMuZGF0YTtzd2l0Y2gobyl7Y2FzZSJpbml0Ijp7Y29uc3R7Z3Jhdml0eTp0LHRvbGVyYW5jZTplLHN0ZXA6cyxpdGVyYXRpb25zOmksYWxsb3dTbGVlcDpvLGJyb2FkcGhhc2U6bixheGlzSW5kZXg6cixkZWZhdWx0Q29udGFjdE1hdGVyaWFsOmF9PWgsbD17TmFpdmVCcm9hZHBoYXNlOlUsU0FQQnJvYWRwaGFzZTpBdH07VGkuYWxsb3dTbGVlcD1vLFRpLmdyYXZpdHkuc2V0KHRbMF0sdFsxXSx0WzJdKSxUaS5zb2x2ZXIudG9sZXJhbmNlPWUsVGkuc29sdmVyLml0ZXJhdGlvbnM9aSxUaS5icm9hZHBoYXNlPW5ldyhsW24rIkJyb2FkcGhhc2UiXXx8VSkoVGkpLFRpLmJyb2FkcGhhc2UuYXhpc0luZGV4PW51bGwhPXI/cjowLE9iamVjdC5hc3NpZ24oVGkuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCxhKSxOaS5zdGVwPXM7YnJlYWt9Y2FzZSJzdGVwIjpUaS5zdGVwKE5pLnN0ZXApO2ZvcihsZXQgdD0wO3Q8VGkuYm9kaWVzLmxlbmd0aDt0Kyspe2xldCBlPVRpLmJvZGllc1t0XSxzPWUucG9zaXRpb24saT1lLnF1YXRlcm5pb247YVszKnQrMF09cy54LGFbMyp0KzFdPXMueSxhWzMqdCsyXT1zLnosbFs0KnQrMF09aS54LGxbNCp0KzFdPWkueSxsWzQqdCsyXT1pLnosbFs0KnQrM109aS53fXNlbGYucG9zdE1lc3NhZ2Uoe29wOiJmcmFtZSIscG9zaXRpb25zOmEscXVhdGVybmlvbnM6bH0sW2EuYnVmZmVyLGwuYnVmZmVyXSk7YnJlYWs7Y2FzZSJhZGRCb2RpZXMiOmZvcihsZXQgcz0wO3M8bi5sZW5ndGg7cysrKXtjb25zdCBvPWhbc10se2FyZ3M6YT1bXSxwb3NpdGlvbjpsPVswLDAsMF0scm90YXRpb246Yz1bMCwwLDBdLHNjYWxlOnU9WzEsMSwxXSx0eXBlOmQsbWFzczpwLG9uQ29sbGlkZTp5fT1vLG09ZShvLFsiYXJncyIsInBvc2l0aW9uIiwicm90YXRpb24iLCJzY2FsZSIsInR5cGUiLCJtYXNzIiwib25Db2xsaWRlIl0pLHY9bmV3IEIodCh7fSxtLHttYXNzOiJTdGF0aWMiPT09ZD8wOnAsdHlwZTpQaVtkXX0pKTtzd2l0Y2godi51dWlkPW5bc10scil7Y2FzZSJCb3giOnYuYWRkU2hhcGUobmV3IGcobmV3IGkoLi4uYSkpKTticmVhaztjYXNlIkNvbnZleFBvbHloZWRyb24iOmNvbnN0W3QsZSxzXT1hLG89bmV3IGYoe3ZlcnRpY2VzOnQubWFwKChbdCxlLHNdKT0+bmV3IGkodCxlLHMpKSxub3JtYWxzOnM/cy5tYXAoKFt0LGUsc10pPT5uZXcgaSh0LGUscykpOm51bGwsZmFjZXM6ZX0pO3YuYWRkU2hhcGUobyk7YnJlYWs7Y2FzZSJDeWxpbmRlciI6di5hZGRTaGFwZShuZXcgd2UoLi4uYSkpO2JyZWFrO2Nhc2UiSGVpZ2h0ZmllbGQiOnYuYWRkU2hhcGUobmV3IGdlKC4uLmEpKTticmVhaztjYXNlIlBhcnRpY2xlIjp2LmFkZFNoYXBlKG5ldyB4ZSk7YnJlYWs7Y2FzZSJQbGFuZSI6di5hZGRTaGFwZShuZXcgaik7YnJlYWs7Y2FzZSJTcGhlcmUiOnYuYWRkU2hhcGUobmV3IGZlKC4uLmEpKTticmVhaztjYXNlIlRyaW1lc2giOnYuYWRkU2hhcGUobmV3IEllKC4uLmEpKX12LnBvc2l0aW9uLnNldChsWzBdLGxbMV0sbFsyXSksdi5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihjWzBdLGNbMV0sY1syXSksVGkuYWRkQm9keSh2KSx5JiZ2LmFkZEV2ZW50TGlzdGVuZXIoImNvbGxpZGUiLCh7dHlwZTp0LGNvbnRhY3Q6ZSx0YXJnZXQ6c30pPT57Y29uc3R7bmk6aSxyaTpvLHJqOm59PWU7c2VsZi5wb3N0TWVzc2FnZSh7b3A6ImV2ZW50Iix0eXBlOnQsYm9keTp2LnV1aWQsdGFyZ2V0OnMudXVpZCxjb250YWN0OntuaTppLnRvQXJyYXkoKSxyaTpvLnRvQXJyYXkoKSxyajpuLnRvQXJyYXkoKSxpbXBhY3RWZWxvY2l0eTplLmdldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWwoKX0sY29sbGlzaW9uRmlsdGVyczp7Ym9keUZpbHRlckdyb3VwOnYuY29sbGlzaW9uRmlsdGVyR3JvdXAsYm9keUZpbHRlck1hc2s6di5jb2xsaXNpb25GaWx0ZXJNYXNrLHRhcmdldEZpbHRlckdyb3VwOnMuY29sbGlzaW9uRmlsdGVyR3JvdXAsdGFyZ2V0RmlsdGVyTWFzazpzLmNvbGxpc2lvbkZpbHRlck1hc2t9fSl9KX1SaSgpO2JyZWFrO2Nhc2UicmVtb3ZlQm9kaWVzIjpmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKylUaS5yZW1vdmVCb2R5KENpW25bdF1dKTtSaSgpO2JyZWFrO2Nhc2Uic2V0UG9zaXRpb24iOkNpW25dLnBvc2l0aW9uLnNldChoWzBdLGhbMV0saFsyXSk7YnJlYWs7Y2FzZSJzZXRSb3RhdGlvbiI6Q2lbbl0ucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoaFswXSxoWzFdLGhbMl0sIlhZWiIpO2JyZWFrO2Nhc2Uic2V0VmVsb2NpdHkiOkNpW25dLnZlbG9jaXR5LnNldChoWzBdLGhbMV0saFsyXSk7YnJlYWs7Y2FzZSJzZXRBbmd1bGFyVmVsb2NpdHkiOkNpW25dLmFuZ3VsYXJWZWxvY2l0eS5zZXQoaFswXSxoWzFdLGhbMl0pO2JyZWFrO2Nhc2Uic2V0TWFzcyI6Q2lbbl0ubWFzcz1oO2JyZWFrO2Nhc2Uic2V0TGluZWFyRGFtcGluZyI6Q2lbbl0ubGluZWFyRGFtcGluZz1oO2JyZWFrO2Nhc2Uic2V0QW5ndWxhckRhbXBpbmciOkNpW25dLmFuZ3VsYXJEYW1waW5nPWg7YnJlYWs7Y2FzZSJzZXRBbGxvd1NsZWVwIjpDaVtuXS5hbGxvd1NsZWVwPWg7YnJlYWs7Y2FzZSJzZXRTbGVlcFNwZWVkTGltaXQiOkNpW25dLnNsZWVwU3BlZWRMaW1pdD1oO2JyZWFrO2Nhc2Uic2V0U2xlZXBUaW1lTGltaXQiOkNpW25dLnNsZWVwVGltZUxpbWl0PWg7YnJlYWs7Y2FzZSJzZXRDb2xsaXNpb25GaWx0ZXJHcm91cCI6Q2lbbl0uY29sbGlzaW9uRmlsdGVyR3JvdXA9aDticmVhaztjYXNlInNldENvbGxpc2lvbkZpbHRlck1hc2siOmNhc2Uic2V0Q29sbGlzaW9uRmlsdGVyTWFzayI6Q2lbbl0uY29sbGlzaW9uRmlsdGVyTWFzaz1oO2JyZWFrO2Nhc2Uic2V0Rml4ZWRSb3RhdGlvbiI6Q2lbbl0uZml4ZWRSb3RhdGlvbj1oO2JyZWFrO2Nhc2UiYXBwbHlGb3JjZSI6Q2lbbl0uYXBwbHlGb3JjZShuZXcgaSguLi5oWzBdKSxuZXcgaSguLi5oWzFdKSk7YnJlYWs7Y2FzZSJhcHBseUltcHVsc2UiOkNpW25dLmFwcGx5SW1wdWxzZShuZXcgaSguLi5oWzBdKSxuZXcgaSguLi5oWzFdKSk7YnJlYWs7Y2FzZSJhcHBseUxvY2FsRm9yY2UiOkNpW25dLmFwcGx5TG9jYWxGb3JjZShuZXcgaSguLi5oWzBdKSxuZXcgaSguLi5oWzFdKSk7YnJlYWs7Y2FzZSJhcHBseUxvY2FsSW1wdWxzZSI6Q2lbbl0uYXBwbHlMb2NhbEltcHVsc2UobmV3IGkoLi4uaFswXSksbmV3IGkoLi4uaFsxXSkpO2JyZWFrO2Nhc2UiYWRkQ29uc3RyYWludCI6e2NvbnN0W3MsbyxhXT1oO2xldCBsLHtwaXZvdEE6YyxwaXZvdEI6dSxheGlzQTpkLGF4aXNCOnB9PWEseT1lKGEsWyJwaXZvdEEiLCJwaXZvdEIiLCJheGlzQSIsImF4aXNCIl0pO3N3aXRjaChjPUFycmF5LmlzQXJyYXkoYyk/bmV3IGkoLi4uYyk6dm9pZCAwLHU9QXJyYXkuaXNBcnJheSh1KT9uZXcgaSguLi51KTp2b2lkIDAsZD1BcnJheS5pc0FycmF5KGQpP25ldyBpKC4uLmQpOnZvaWQgMCxwPUFycmF5LmlzQXJyYXkocCk/bmV3IGkoLi4ucCk6dm9pZCAwLHIpe2Nhc2UiUG9pbnRUb1BvaW50IjpsPW5ldyBPdChDaVtzXSxjLENpW29dLHUsYS5tYXhGb3JjZSk7YnJlYWs7Y2FzZSJDb25lVHdpc3QiOmw9bmV3IFl0KENpW3NdLENpW29dLHQoe3Bpdm90QTpjLHBpdm90Qjp1LGF4aXNBOmQsYXhpc0I6cH0seSkpO2JyZWFrO2Nhc2UiSGluZ2UiOmw9bmV3IEp0KENpW3NdLENpW29dLHQoe3Bpdm90QTpjLHBpdm90Qjp1LGF4aXNBOmQsYXhpc0I6cH0seSkpO2JyZWFrO2Nhc2UiRGlzdGFuY2UiOmw9bmV3IFp0KENpW3NdLENpW29dLGEuZGlzdGFuY2UsYS5tYXhGb3JjZSksY29uc29sZS5sb2cobCk7YnJlYWs7Y2FzZSJMb2NrIjpsPW5ldyBLdChDaVtzXSxDaVtvXSxhKTticmVhaztkZWZhdWx0Omw9bmV3IEJ0KENpW3NdLENpW29dLGEpfWwudXVpZD1uLFRpLmFkZENvbnN0cmFpbnQobCk7YnJlYWt9Y2FzZSJyZW1vdmVDb25zdHJhaW50IjpUaS5yZW1vdmVDb25zdHJhaW50KG4pO2JyZWFrO2Nhc2UiZW5hYmxlQ29uc3RyYWludCI6VGkuY29uc3RyYWludHMuZmlsdGVyKCh7dXVpZDp0fSk9PnQ9PT1uKS5tYXAodD0+dC5lbmFibGUoKSk7YnJlYWs7Y2FzZSJkaXNhYmxlQ29uc3RyYWludCI6VGkuY29uc3RyYWludHMuZmlsdGVyKCh7dXVpZDp0fSk9PnQ9PT1uKS5tYXAodD0+dC5kaXNhYmxlKCkpO2JyZWFrO2Nhc2UiYWRkU3ByaW5nIjp7Y29uc3RbdCxlLHNdPWg7bGV0e3dvcmxkQW5jaG9yQTpvLHdvcmxkQW5jaG9yQjpyLGxvY2FsQW5jaG9yQTphLGxvY2FsQW5jaG9yQjpsLHJlc3RMZW5ndGg6YyxzdGlmZm5lc3M6dSxkYW1waW5nOmR9PXM7bz1BcnJheS5pc0FycmF5KG8pP25ldyBpKC4uLm8pOnZvaWQgMCxyPUFycmF5LmlzQXJyYXkocik/bmV3IGkoLi4ucik6dm9pZCAwLGE9QXJyYXkuaXNBcnJheShhKT9uZXcgaSguLi5hKTp2b2lkIDAsbD1BcnJheS5pc0FycmF5KGwpP25ldyBpKC4uLmwpOnZvaWQgMDtsZXQgcD1uZXcgbmUoQ2lbdF0sQ2lbZV0se3dvcmxkQW5jaG9yQTpvLHdvcmxkQW5jaG9yQjpyLGxvY2FsQW5jaG9yQTphLGxvY2FsQW5jaG9yQjpsLHJlc3RMZW5ndGg6YyxzdGlmZm5lc3M6dSxkYW1waW5nOmR9KTtwLnV1aWQ9bjtsZXQgeT10PT5wLmFwcGx5Rm9yY2UoKTtxaVtuXT15LFRpLmFkZEV2ZW50TGlzdGVuZXIoInBvc3RTdGVwIixxaVtuXSk7YnJlYWt9Y2FzZSJyZW1vdmVTcHJpbmciOlRpLnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvc3RTdGVwIixxaVtuXSl9fTsKCg==\",null,!1);export default function({children:m,step:L=1/60,gravity:W=[0,-10,0],tolerance:p=.001,iterations:s=5,allowSleep:a=!0,broadphase:y=\"Naive\",axisIndex:V=0,defaultContactMaterial:h={contactEquationStiffness:1e6},size:x=1e3}){const[Y]=G(()=>new u),[K]=G({}),[S]=G({}),[R]=G(()=>({positions:new Float32Array(3*x),quaternions:new Float32Array(4*x)})),z=d({});l(()=>{function b(){Y.postMessage(c({op:\"step\"},R),[R.positions.buffer,R.quaternions.buffer])}return Y.postMessage({op:\"init\",props:{gravity:W,tolerance:p,step:L,iterations:s,broadphase:y,allowSleep:a,axisIndex:V,defaultContactMaterial:h}}),Y.onmessage=G=>{switch(G.data.op){case\"frame\":R.positions=G.data.positions,R.quaternions=G.data.quaternions,requestAnimationFrame(b);break;case\"sync\":z.current=G.data.bodies.reduce((b,d)=>c({},b,{[d]:G.data.bodies.indexOf(d)}),{});break;case\"event\":switch(G.data.type){case\"collide\":K[G.data.body](c({},G.data,{body:S[G.data.body],target:S[G.data.target]}))}}},b(),()=>Y.terminate()},[]);const k=Z(()=>({worker:Y,bodies:z,buffers:R,refs:S,events:K}),[Y,z,R,K,S]);return b.createElement(X.Provider,{value:k},m)}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n"],"sourceRoot":""}